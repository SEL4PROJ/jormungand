<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>NEWS (unidentified repository version)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>NEWS</h1>

<div class="source">
<pre class="source">Isabelle NEWS -- history of user-relevant changes<br/>=================================================<br/><br/>(Note: Isabelle/jEdit shows a tree-view of the NEWS file in Sidekick.)<br/><br/><br/>New in Isabelle2016-1 (December 2016)<br/>-------------------------------------<br/><br/>*** General ***<br/><br/>* Splitter in proof methods &quot;simp&quot;, &quot;auto&quot; and friends:<br/>  - The syntax &quot;split add&quot; has been discontinued, use plain &quot;split&quot;,<br/>    INCOMPATIBILITY.<br/>  - For situations with many conditional or case expressions, there is<br/>    an alternative splitting strategy that can be much faster. It is<br/>    selected by writing &quot;split!&quot; instead of &quot;split&quot;. It applies safe<br/>    introduction and elimination rules after each split rule. As a<br/>    result the subgoal may be split into several subgoals.<br/><br/>* Command &#39;bundle&#39; provides a local theory target to define a bundle<br/>from the body of specification commands (such as &#39;declare&#39;,<br/>&#39;declaration&#39;, &#39;notation&#39;, &#39;lemmas&#39;, &#39;lemma&#39;). For example:<br/><br/>bundle foo<br/>begin<br/>  declare a [simp]<br/>  declare b [intro]<br/>end<br/><br/>* Command &#39;unbundle&#39; is like &#39;include&#39;, but works within a local theory<br/>context. Unlike &quot;context includes ... begin&quot;, the effect of &#39;unbundle&#39;<br/>on the target context persists, until different declarations are given.<br/><br/>* Simplified outer syntax: uniform category &quot;name&quot; includes long<br/>identifiers. Former &quot;xname&quot; / &quot;nameref&quot; / &quot;name reference&quot; has been<br/>discontinued.<br/><br/>* Embedded content (e.g. the inner syntax of types, terms, props) may be<br/>delimited uniformly via cartouches. This works better than old-fashioned<br/>quotes when sub-languages are nested.<br/><br/>* Mixfix annotations support general block properties, with syntax<br/>&quot;(‹x=a y=b z …›&quot;. Notable property names are &quot;indent&quot;, &quot;consistent&quot;,<br/>&quot;unbreakable&quot;, &quot;markup&quot;. The existing notation &quot;(DIGITS&quot; is equivalent<br/>to &quot;(‹indent=DIGITS›&quot;. The former notation &quot;(00&quot; for unbreakable blocks<br/>is superseded by &quot;(‹unbreabable›&quot; --- rare INCOMPATIBILITY.<br/><br/>* Proof method &quot;blast&quot; is more robust wrt. corner cases of Pure<br/>statements without object-logic judgment.<br/><br/>* Commands &#39;prf&#39; and &#39;full_prf&#39; are somewhat more informative (again):<br/>proof terms are reconstructed and cleaned from administrative thm nodes.<br/><br/>* Code generator: config option &quot;code_timing&quot; triggers measurements of<br/>different phases of code generation. See src/HOL/ex/Code_Timing.thy for<br/>examples.<br/><br/>* Code generator: implicits in Scala (stemming from type class<br/>instances) are generated into companion object of corresponding type<br/>class, to resolve some situations where ambiguities may occur.<br/><br/>* Solve direct: option &quot;solve_direct_strict_warnings&quot; gives explicit<br/>warnings for lemma statements with trivial proofs.<br/><br/><br/>*** Prover IDE -- Isabelle/Scala/jEdit ***<br/><br/>* More aggressive flushing of machine-generated input, according to<br/>system option editor_generated_input_delay (in addition to existing<br/>editor_input_delay for regular user edits). This may affect overall PIDE<br/>reactivity and CPU usage.<br/><br/>* Syntactic indentation according to Isabelle outer syntax. Action<br/>&quot;indent-lines&quot; (shortcut C+i) indents the current line according to<br/>command keywords and some command substructure. Action<br/>&quot;isabelle.newline&quot; (shortcut ENTER) indents the old and the new line<br/>according to command keywords only; see also option<br/>&quot;jedit_indent_newline&quot;.<br/><br/>* Semantic indentation for unstructured proof scripts (&#39;apply&#39; etc.) via<br/>number of subgoals. This requires information of ongoing document<br/>processing and may thus lag behind, when the user is editing too<br/>quickly; see also option &quot;jedit_script_indent&quot; and<br/>&quot;jedit_script_indent_limit&quot;.<br/><br/>* Refined folding mode &quot;isabelle&quot; based on Isar syntax: &#39;next&#39; and &#39;qed&#39;<br/>are treated as delimiters for fold structure; &#39;begin&#39; and &#39;end&#39;<br/>structure of theory specifications is treated as well.<br/><br/>* Command &#39;proof&#39; provides information about proof outline with cases,<br/>e.g. for proof methods &quot;cases&quot;, &quot;induct&quot;, &quot;goal_cases&quot;.<br/><br/>* Completion templates for commands involving &quot;begin ... end&quot; blocks,<br/>e.g. &#39;context&#39;, &#39;notepad&#39;.<br/><br/>* Sidekick parser &quot;isabelle-context&quot; shows nesting of context blocks<br/>according to &#39;begin&#39; and &#39;end&#39; structure.<br/><br/>* Highlighting of entity def/ref positions wrt. cursor.<br/><br/>* Action &quot;isabelle.select-entity&quot; (shortcut CS+ENTER) selects all<br/>occurrences of the formal entity at the caret position. This facilitates<br/>systematic renaming.<br/><br/>* PIDE document markup works across multiple Isar commands, e.g. the<br/>results established at the end of a proof are properly identified in the<br/>theorem statement.<br/><br/>* Cartouche abbreviations work both for &quot; and ` to accomodate typical<br/>situations where old ASCII notation may be updated.<br/><br/>* Dockable window &quot;Symbols&quot; also provides access to &#39;abbrevs&#39; from the<br/>outer syntax of the current theory buffer. This provides clickable<br/>syntax templates, including entries with empty abbrevs name (which are<br/>inaccessible via keyboard completion).<br/><br/>* IDE support for the Isabelle/Pure bootstrap process, with the<br/>following independent stages:<br/><br/>  src/Pure/ROOT0.ML<br/>  src/Pure/ROOT.ML<br/>  src/Pure/Pure.thy<br/>  src/Pure/ML_Bootstrap.thy<br/><br/>The ML ROOT files act like quasi-theories in the context of theory<br/>ML_Bootstrap: this allows continuous checking of all loaded ML files.<br/>The theory files are presented with a modified header to import Pure<br/>from the running Isabelle instance. Results from changed versions of<br/>each stage are *not* propagated to the next stage, and isolated from the<br/>actual Isabelle/Pure that runs the IDE itself. The sequential<br/>dependencies of the above files are only observed for batch build.<br/><br/>* Isabelle/ML and Standard ML files are presented in Sidekick with the<br/>tree structure of section headings: this special comment format is<br/>described in &quot;implementation&quot; chapter 0, e.g. (*** section ***).<br/><br/>* Additional abbreviations for syntactic completion may be specified<br/>within the theory header as &#39;abbrevs&#39;. The theory syntax for &#39;keywords&#39;<br/>has been simplified accordingly: optional abbrevs need to go into the<br/>new &#39;abbrevs&#39; section.<br/><br/>* Global abbreviations via $ISABELLE_HOME/etc/abbrevs and<br/>$ISABELLE_HOME_USER/etc/abbrevs are no longer supported. Minor<br/>INCOMPATIBILITY, use &#39;abbrevs&#39; within theory header instead.<br/><br/>* Action &quot;isabelle.keymap-merge&quot; asks the user to resolve pending<br/>Isabelle keymap changes that are in conflict with the current jEdit<br/>keymap; non-conflicting changes are always applied implicitly. This<br/>action is automatically invoked on Isabelle/jEdit startup and thus<br/>increases chances that users see new keyboard shortcuts when re-using<br/>old keymaps.<br/><br/>* ML and document antiquotations for file-systems paths are more uniform<br/>and diverse:<br/><br/>  @{path NAME}   -- no file-system check<br/>  @{file NAME}   -- check for plain file<br/>  @{dir NAME}    -- check for directory<br/><br/>Minor INCOMPATIBILITY, former uses of @{file} and @{file_unchecked} may<br/>have to be changed.<br/><br/><br/>*** Document preparation ***<br/><br/>* New symbol ○, e.g. for temporal operator.<br/><br/>* New document and ML antiquotation @{locale} for locales, similar to<br/>existing antiquotation @{class}.<br/><br/>* Mixfix annotations support delimiters like \&lt;^control&gt;‹cartouche› --<br/>this allows special forms of document output.<br/><br/>* Raw LaTeX output now works via \&lt;^latex&gt;‹...› instead of raw control<br/>symbol \&lt;^raw:...&gt;. INCOMPATIBILITY, notably for LaTeXsugar.thy and its<br/>derivatives.<br/><br/>* \&lt;^raw:...&gt; symbols are no longer supported.<br/><br/>* Old &#39;header&#39; command is no longer supported (legacy since<br/>Isabelle2015).<br/><br/><br/>*** Isar ***<br/><br/>* Many specification elements support structured statements with &#39;if&#39; /<br/>&#39;for&#39; eigen-context, e.g. &#39;axiomatization&#39;, &#39;abbreviation&#39;,<br/>&#39;definition&#39;, &#39;inductive&#39;, &#39;function&#39;.<br/><br/>* Toplevel theorem statements support eigen-context notation with &#39;if&#39; /<br/>&#39;for&#39; (in postfix), which corresponds to &#39;assumes&#39; / &#39;fixes&#39; in the<br/>traditional long statement form (in prefix). Local premises are called<br/>&quot;that&quot; or &quot;assms&quot;, respectively. Empty premises are *not* bound in the<br/>context: INCOMPATIBILITY.<br/><br/>* Command &#39;define&#39; introduces a local (non-polymorphic) definition, with<br/>optional abstraction over local parameters. The syntax resembles<br/>&#39;definition&#39; and &#39;obtain&#39;. It fits better into the Isar language than<br/>old &#39;def&#39;, which is now a legacy feature.<br/><br/>* Command &#39;obtain&#39; supports structured statements with &#39;if&#39; / &#39;for&#39;<br/>context.<br/><br/>* Command &#39;\&lt;proof&gt;&#39; is an alias for &#39;sorry&#39;, with different<br/>typesetting. E.g. to produce proof holes in examples and documentation.<br/><br/>* The defining position of a literal fact ‹prop› is maintained more<br/>carefully, and made accessible as hyperlink in the Prover IDE.<br/><br/>* Commands &#39;finally&#39; and &#39;ultimately&#39; used to expose the result as<br/>literal fact: this accidental behaviour has been discontinued. Rare<br/>INCOMPATIBILITY, use more explicit means to refer to facts in Isar.<br/><br/>* Command &#39;axiomatization&#39; has become more restrictive to correspond<br/>better to internal axioms as singleton facts with mandatory name. Minor<br/>INCOMPATIBILITY.<br/><br/>* Proof methods may refer to the main facts via the dynamic fact<br/>&quot;method_facts&quot;. This is particularly useful for Eisbach method<br/>definitions.<br/><br/>* Proof method &quot;use&quot; allows to modify the main facts of a given method<br/>expression, e.g.<br/><br/>  (use facts in simp)<br/>  (use facts in ‹simp add: ...›)<br/><br/>* The old proof method &quot;default&quot; has been removed (legacy since<br/>Isabelle2016). INCOMPATIBILITY, use &quot;standard&quot; instead.<br/><br/><br/>*** Pure ***<br/><br/>* Pure provides basic versions of proof methods &quot;simp&quot; and &quot;simp_all&quot;<br/>that only know about meta-equality (==). Potential INCOMPATIBILITY in<br/>theory imports that merge Pure with e.g. Main of Isabelle/HOL: the order<br/>is relevant to avoid confusion of Pure.simp vs. HOL.simp.<br/><br/>* The command &#39;unfolding&#39; and proof method &quot;unfold&quot; include a second<br/>stage where given equations are passed through the attribute &quot;abs_def&quot;<br/>before rewriting. This ensures that definitions are fully expanded,<br/>regardless of the actual parameters that are provided. Rare<br/>INCOMPATIBILITY in some corner cases: use proof method (simp only:)<br/>instead, or declare [[unfold_abs_def = false]] in the proof context.<br/><br/>* Type-inference improves sorts of newly introduced type variables for<br/>the object-logic, using its base sort (i.e. HOL.type for Isabelle/HOL).<br/>Thus terms like &quot;f x&quot; or &quot;⋀x. P x&quot; without any further syntactic context<br/>produce x::&#39;a::type in HOL instead of x::&#39;a::{} in Pure. Rare<br/>INCOMPATIBILITY, need to provide explicit type constraints for Pure<br/>types where this is really intended.<br/><br/><br/>*** HOL ***<br/><br/>* New proof method &quot;argo&quot; using the built-in Argo solver based on SMT<br/>technology. The method can be used to prove goals of quantifier-free<br/>propositional logic, goals based on a combination of quantifier-free<br/>propositional logic with equality, and goals based on a combination of<br/>quantifier-free propositional logic with linear real arithmetic<br/>including min/max/abs. See HOL/ex/Argo_Examples.thy for examples.<br/><br/>* The new &quot;nunchaku&quot; program integrates the Nunchaku model finder. The<br/>tool is experimental. See ~~/src/HOL/Nunchaku/Nunchaku.thy for details.<br/><br/>* Metis: The problem encoding has changed very slightly. This might<br/>break existing proofs. INCOMPATIBILITY.<br/><br/>* Sledgehammer:<br/>  - The MaSh relevance filter is now faster than before.<br/>  - Produce syntactically correct Vampire 4.0 problem files.<br/><br/>* (Co)datatype package:<br/>  - New commands for defining corecursive functions and reasoning about<br/>    them in &quot;~~/src/HOL/Library/BNF_Corec.thy&quot;: &#39;corec&#39;, &#39;corecursive&#39;,<br/>    &#39;friend_of_corec&#39;, and &#39;corecursion_upto&#39;; and &#39;corec_unique&#39; proof<br/>    method. See &#39;isabelle doc corec&#39;.<br/>  - The predicator :: (&#39;a ⇒ bool) ⇒ &#39;a F ⇒ bool is now a first-class<br/>    citizen in bounded natural functors.<br/>  - &#39;primrec&#39; now allows nested calls through the predicator in addition<br/>    to the map function.<br/>  - &#39;bnf&#39; automatically discharges reflexive proof obligations.<br/>  - &#39;bnf&#39; outputs a slightly modified proof obligation expressing rel in<br/>       terms of map and set<br/>       (not giving a specification for rel makes this one reflexive).<br/>  - &#39;bnf&#39; outputs a new proof obligation expressing pred in terms of set<br/>       (not giving a specification for pred makes this one reflexive).<br/>    INCOMPATIBILITY: manual &#39;bnf&#39; declarations may need adjustment.<br/>  - Renamed lemmas:<br/>      rel_prod_apply ~&gt; rel_prod_inject<br/>      pred_prod_apply ~&gt; pred_prod_inject<br/>    INCOMPATIBILITY.<br/>  - The &quot;size&quot; plugin has been made compatible again with locales.<br/>  - The theorems about &quot;rel&quot; and &quot;set&quot; may have a slightly different (but<br/>    equivalent) form.<br/>    INCOMPATIBILITY.<br/><br/>* The &#39;coinductive&#39; command produces a proper coinduction rule for<br/>mutual coinductive predicates. This new rule replaces the old rule,<br/>which exposed details of the internal fixpoint construction and was<br/>hard to use. INCOMPATIBILITY.<br/><br/>* New abbreviations for negated existence (but not bounded existence):<br/><br/>  ∄x. P x ≡ ¬ (∃x. P x)<br/>  ∄!x. P x ≡ ¬ (∃!x. P x)<br/><br/>* The print mode &quot;HOL&quot; for ASCII syntax of binders &quot;!&quot;, &quot;?&quot;, &quot;?!&quot;, &quot;@&quot;<br/>has been removed for output. It is retained for input only, until it is<br/>eliminated altogether.<br/><br/>* The unique existence quantifier no longer provides &#39;binder&#39; syntax,<br/>but uses syntax translations (as for bounded unique existence). Thus<br/>iterated quantification ∃!x y. P x y with its slightly confusing<br/>sequential meaning ∃!x. ∃!y. P x y is no longer possible. Instead,<br/>pattern abstraction admits simultaneous unique existence ∃!(x, y). P x y<br/>(analogous to existing notation ∃!(x, y)∈A. P x y). Potential<br/>INCOMPATIBILITY in rare situations.<br/><br/>* Conventional syntax &quot;%(). t&quot; for unit abstractions. Slight syntactic<br/>INCOMPATIBILITY.<br/><br/>* Renamed constants and corresponding theorems:<br/><br/>    setsum ~&gt; sum<br/>    setprod ~&gt; prod<br/>    listsum ~&gt; sum_list<br/>    listprod ~&gt; prod_list<br/><br/>INCOMPATIBILITY.<br/><br/>* Sligthly more standardized theorem names:<br/>    sgn_times ~&gt; sgn_mult<br/>    sgn_mult&#39; ~&gt; Real_Vector_Spaces.sgn_mult<br/>    divide_zero_left ~&gt; div_0<br/>    zero_mod_left ~&gt; mod_0<br/>    divide_zero ~&gt; div_by_0<br/>    divide_1 ~&gt; div_by_1<br/>    nonzero_mult_divide_cancel_left ~&gt; nonzero_mult_div_cancel_left<br/>    div_mult_self1_is_id ~&gt; nonzero_mult_div_cancel_left<br/>    nonzero_mult_divide_cancel_right ~&gt; nonzero_mult_div_cancel_right<br/>    div_mult_self2_is_id ~&gt; nonzero_mult_div_cancel_right<br/>    is_unit_divide_mult_cancel_left ~&gt; is_unit_div_mult_cancel_left<br/>    is_unit_divide_mult_cancel_right ~&gt; is_unit_div_mult_cancel_right<br/>    mod_div_equality ~&gt; div_mult_mod_eq<br/>    mod_div_equality2 ~&gt; mult_div_mod_eq<br/>    mod_div_equality3 ~&gt; mod_div_mult_eq<br/>    mod_div_equality4 ~&gt; mod_mult_div_eq<br/>    minus_div_eq_mod ~&gt; minus_div_mult_eq_mod<br/>    minus_div_eq_mod2 ~&gt; minus_mult_div_eq_mod<br/>    minus_mod_eq_div ~&gt; minus_mod_eq_div_mult<br/>    minus_mod_eq_div2 ~&gt; minus_mod_eq_mult_div<br/>    div_mod_equality&#39; ~&gt; minus_mod_eq_div_mult [symmetric]<br/>    mod_div_equality&#39; ~&gt; minus_div_mult_eq_mod [symmetric]<br/>    zmod_zdiv_equality ~&gt; mult_div_mod_eq [symmetric]<br/>    zmod_zdiv_equality&#39; ~&gt; minus_div_mult_eq_mod [symmetric]<br/>    Divides.mult_div_cancel ~&gt; minus_mod_eq_mult_div [symmetric]<br/>    mult_div_cancel ~&gt; minus_mod_eq_mult_div [symmetric]<br/>    zmult_div_cancel ~&gt; minus_mod_eq_mult_div [symmetric]<br/>    div_1 ~&gt; div_by_Suc_0<br/>    mod_1 ~&gt; mod_by_Suc_0<br/>INCOMPATIBILITY.<br/><br/>* New type class &quot;idom_abs_sgn&quot; specifies algebraic properties<br/>of sign and absolute value functions.  Type class &quot;sgn_if&quot; has<br/>disappeared.  Slight INCOMPATIBILITY.<br/><br/>* Dedicated syntax LENGTH(&#39;a) for length of types.<br/><br/>* Characters (type char) are modelled as finite algebraic type<br/>corresponding to {0..255}.<br/><br/>  - Logical representation:<br/>    * 0 is instantiated to the ASCII zero character.<br/>    * All other characters are represented as &quot;Char n&quot;<br/>      with n being a raw numeral expression less than 256.<br/>    * Expressions of the form &quot;Char n&quot; with n greater than 255<br/>      are non-canonical.<br/>  - Printing and parsing:<br/>    * Printable characters are printed and parsed as &quot;CHR &#39;&#39;…&#39;&#39;&quot;<br/>      (as before).<br/>    * The ASCII zero character is printed and parsed as &quot;0&quot;.<br/>    * All other canonical characters are printed as &quot;CHR 0xXX&quot;<br/>      with XX being the hexadecimal character code.  &quot;CHR n&quot;<br/>      is parsable for every numeral expression n.<br/>    * Non-canonical characters have no special syntax and are<br/>      printed as their logical representation.<br/>  - Explicit conversions from and to the natural numbers are<br/>    provided as char_of_nat, nat_of_char (as before).<br/>  - The auxiliary nibble type has been discontinued.<br/><br/>INCOMPATIBILITY.<br/><br/>* Type class &quot;div&quot; with operation &quot;mod&quot; renamed to type class &quot;modulo&quot;<br/>with operation &quot;modulo&quot;, analogously to type class &quot;divide&quot;. This<br/>eliminates the need to qualify any of those names in the presence of<br/>infix &quot;mod&quot; syntax. INCOMPATIBILITY.<br/><br/>* Statements and proofs of Knaster-Tarski fixpoint combinators lfp/gfp<br/>have been clarified. The fixpoint properties are lfp_fixpoint, its<br/>symmetric lfp_unfold (as before), and the duals for gfp. Auxiliary items<br/>for the proof (lfp_lemma2 etc.) are no longer exported, but can be<br/>easily recovered by composition with eq_refl. Minor INCOMPATIBILITY.<br/><br/>* Constant &quot;surj&quot; is a mere input abbreviation, to avoid hiding an<br/>equation in term output. Minor INCOMPATIBILITY.<br/><br/>* Command &#39;code_reflect&#39; accepts empty constructor lists for datatypes,<br/>which renders those abstract effectively.<br/><br/>* Command &#39;export_code&#39; checks given constants for abstraction<br/>violations: a small guarantee that given constants specify a safe<br/>interface for the generated code.<br/><br/>* Code generation for Scala: ambiguous implicts in class diagrams are<br/>spelt out explicitly.<br/><br/>* Static evaluators (Code_Evaluation.static_* in Isabelle/ML) rely on<br/>explicitly provided auxiliary definitions for required type class<br/>dictionaries rather than half-working magic. INCOMPATIBILITY, see the<br/>tutorial on code generation for details.<br/><br/>* Theory Set_Interval: substantial new theorems on indexed sums and<br/>products.<br/><br/>* Locale bijection establishes convenient default simp rules such as<br/>&quot;inv f (f a) = a&quot; for total bijections.<br/><br/>* Abstract locales semigroup, abel_semigroup, semilattice,<br/>semilattice_neutr, ordering, ordering_top, semilattice_order,<br/>semilattice_neutr_order, comm_monoid_set, semilattice_set,<br/>semilattice_neutr_set, semilattice_order_set,<br/>semilattice_order_neutr_set monoid_list, comm_monoid_list,<br/>comm_monoid_list_set, comm_monoid_mset, comm_monoid_fun use boldified<br/>syntax uniformly that does not clash with corresponding global syntax.<br/>INCOMPATIBILITY.<br/><br/>* Former locale lifting_syntax is now a bundle, which is easier to<br/>include in a local context or theorem statement, e.g. &quot;context includes<br/>lifting_syntax begin ... end&quot;. Minor INCOMPATIBILITY.<br/><br/>* Some old / obsolete theorems have been renamed / removed, potential<br/>INCOMPATIBILITY.<br/><br/>  nat_less_cases  --  removed, use linorder_cases instead<br/>  inv_image_comp  --  removed, use image_inv_f_f instead<br/>  image_surj_f_inv_f  ~&gt;  image_f_inv_f<br/><br/>* Some theorems about groups and orders have been generalised from<br/>  groups to semi-groups that are also monoids:<br/>    le_add_same_cancel1<br/>    le_add_same_cancel2<br/>    less_add_same_cancel1<br/>    less_add_same_cancel2<br/>    add_le_same_cancel1<br/>    add_le_same_cancel2<br/>    add_less_same_cancel1<br/>    add_less_same_cancel2<br/><br/>* Some simplifications theorems about rings have been removed, since<br/>  superseeded by a more general version:<br/>    less_add_cancel_left_greater_zero ~&gt; less_add_same_cancel1<br/>    less_add_cancel_right_greater_zero ~&gt; less_add_same_cancel2<br/>    less_eq_add_cancel_left_greater_eq_zero ~&gt; le_add_same_cancel1<br/>    less_eq_add_cancel_right_greater_eq_zero ~&gt; le_add_same_cancel2<br/>    less_eq_add_cancel_left_less_eq_zero ~&gt; add_le_same_cancel1<br/>    less_eq_add_cancel_right_less_eq_zero ~&gt; add_le_same_cancel2<br/>    less_add_cancel_left_less_zero ~&gt; add_less_same_cancel1<br/>    less_add_cancel_right_less_zero ~&gt; add_less_same_cancel2<br/>INCOMPATIBILITY.<br/><br/>* Renamed split_if -&gt; if_split and split_if_asm -&gt; if_split_asm to<br/>resemble the f.split naming convention, INCOMPATIBILITY.<br/><br/>* Added class topological_monoid.<br/><br/>* The following theorems have been renamed:<br/><br/>  setsum_left_distrib ~&gt; sum_distrib_right<br/>  setsum_right_distrib ~&gt; sum_distrib_left<br/><br/>INCOMPATIBILITY.<br/><br/>* Compound constants INFIMUM and SUPREMUM are mere abbreviations now.<br/>INCOMPATIBILITY.<br/><br/>* &quot;Gcd (f ` A)&quot; and &quot;Lcm (f ` A)&quot; are printed with optional<br/>comprehension-like syntax analogously to &quot;Inf (f ` A)&quot; and &quot;Sup (f `<br/>A)&quot;.<br/><br/>* Class semiring_Lcd merged into semiring_Gcd. INCOMPATIBILITY.<br/><br/>* The type class ordered_comm_monoid_add is now called<br/>ordered_cancel_comm_monoid_add. A new type class ordered_comm_monoid_add<br/>is introduced as the combination of ordered_ab_semigroup_add +<br/>comm_monoid_add. INCOMPATIBILITY.<br/><br/>* Introduced the type classes canonically_ordered_comm_monoid_add and<br/>dioid.<br/><br/>* Introduced the type class ordered_ab_semigroup_monoid_add_imp_le. When<br/>instantiating linordered_semiring_strict and ordered_ab_group_add, an<br/>explicit instantiation of ordered_ab_semigroup_monoid_add_imp_le might<br/>be required. INCOMPATIBILITY.<br/><br/>* Dropped various legacy fact bindings, whose replacements are often<br/>of a more general type also:<br/>  lcm_left_commute_nat ~&gt; lcm.left_commute<br/>  lcm_left_commute_int ~&gt; lcm.left_commute<br/>  gcd_left_commute_nat ~&gt; gcd.left_commute<br/>  gcd_left_commute_int ~&gt; gcd.left_commute<br/>  gcd_greatest_iff_nat ~&gt; gcd_greatest_iff<br/>  gcd_greatest_iff_int ~&gt; gcd_greatest_iff<br/>  coprime_dvd_mult_nat ~&gt; coprime_dvd_mult<br/>  coprime_dvd_mult_int ~&gt; coprime_dvd_mult<br/>  zpower_numeral_even ~&gt; power_numeral_even<br/>  gcd_mult_cancel_nat ~&gt; gcd_mult_cancel<br/>  gcd_mult_cancel_int ~&gt; gcd_mult_cancel<br/>  div_gcd_coprime_nat ~&gt; div_gcd_coprime<br/>  div_gcd_coprime_int ~&gt; div_gcd_coprime<br/>  zpower_numeral_odd ~&gt; power_numeral_odd<br/>  zero_less_int_conv ~&gt; of_nat_0_less_iff<br/>  gcd_greatest_nat ~&gt; gcd_greatest<br/>  gcd_greatest_int ~&gt; gcd_greatest<br/>  coprime_mult_nat ~&gt; coprime_mult<br/>  coprime_mult_int ~&gt; coprime_mult<br/>  lcm_commute_nat ~&gt; lcm.commute<br/>  lcm_commute_int ~&gt; lcm.commute<br/>  int_less_0_conv ~&gt; of_nat_less_0_iff<br/>  gcd_commute_nat ~&gt; gcd.commute<br/>  gcd_commute_int ~&gt; gcd.commute<br/>  Gcd_insert_nat ~&gt; Gcd_insert<br/>  Gcd_insert_int ~&gt; Gcd_insert<br/>  of_int_int_eq ~&gt; of_int_of_nat_eq<br/>  lcm_least_nat ~&gt; lcm_least<br/>  lcm_least_int ~&gt; lcm_least<br/>  lcm_assoc_nat ~&gt; lcm.assoc<br/>  lcm_assoc_int ~&gt; lcm.assoc<br/>  int_le_0_conv ~&gt; of_nat_le_0_iff<br/>  int_eq_0_conv ~&gt; of_nat_eq_0_iff<br/>  Gcd_empty_nat ~&gt; Gcd_empty<br/>  Gcd_empty_int ~&gt; Gcd_empty<br/>  gcd_assoc_nat ~&gt; gcd.assoc<br/>  gcd_assoc_int ~&gt; gcd.assoc<br/>  zero_zle_int ~&gt; of_nat_0_le_iff<br/>  lcm_dvd2_nat ~&gt; dvd_lcm2<br/>  lcm_dvd2_int ~&gt; dvd_lcm2<br/>  lcm_dvd1_nat ~&gt; dvd_lcm1<br/>  lcm_dvd1_int ~&gt; dvd_lcm1<br/>  gcd_zero_nat ~&gt; gcd_eq_0_iff<br/>  gcd_zero_int ~&gt; gcd_eq_0_iff<br/>  gcd_dvd2_nat ~&gt; gcd_dvd2<br/>  gcd_dvd2_int ~&gt; gcd_dvd2<br/>  gcd_dvd1_nat ~&gt; gcd_dvd1<br/>  gcd_dvd1_int ~&gt; gcd_dvd1<br/>  int_numeral ~&gt; of_nat_numeral<br/>  lcm_ac_nat ~&gt; ac_simps<br/>  lcm_ac_int ~&gt; ac_simps<br/>  gcd_ac_nat ~&gt; ac_simps<br/>  gcd_ac_int ~&gt; ac_simps<br/>  abs_int_eq ~&gt; abs_of_nat<br/>  zless_int ~&gt; of_nat_less_iff<br/>  zdiff_int ~&gt; of_nat_diff<br/>  zadd_int ~&gt; of_nat_add<br/>  int_mult ~&gt; of_nat_mult<br/>  int_Suc ~&gt; of_nat_Suc<br/>  inj_int ~&gt; inj_of_nat<br/>  int_1 ~&gt; of_nat_1<br/>  int_0 ~&gt; of_nat_0<br/>  Lcm_empty_nat ~&gt; Lcm_empty<br/>  Lcm_empty_int ~&gt; Lcm_empty<br/>  Lcm_insert_nat ~&gt; Lcm_insert<br/>  Lcm_insert_int ~&gt; Lcm_insert<br/>  comp_fun_idem_gcd_nat ~&gt; comp_fun_idem_gcd<br/>  comp_fun_idem_gcd_int ~&gt; comp_fun_idem_gcd<br/>  comp_fun_idem_lcm_nat ~&gt; comp_fun_idem_lcm<br/>  comp_fun_idem_lcm_int ~&gt; comp_fun_idem_lcm<br/>  Lcm_eq_0 ~&gt; Lcm_eq_0_I<br/>  Lcm0_iff ~&gt; Lcm_0_iff<br/>  Lcm_dvd_int ~&gt; Lcm_least<br/>  divides_mult_nat ~&gt; divides_mult<br/>  divides_mult_int ~&gt; divides_mult<br/>  lcm_0_nat ~&gt; lcm_0_right<br/>  lcm_0_int ~&gt; lcm_0_right<br/>  lcm_0_left_nat ~&gt; lcm_0_left<br/>  lcm_0_left_int ~&gt; lcm_0_left<br/>  dvd_gcd_D1_nat ~&gt; dvd_gcdD1<br/>  dvd_gcd_D1_int ~&gt; dvd_gcdD1<br/>  dvd_gcd_D2_nat ~&gt; dvd_gcdD2<br/>  dvd_gcd_D2_int ~&gt; dvd_gcdD2<br/>  coprime_dvd_mult_iff_nat ~&gt; coprime_dvd_mult_iff<br/>  coprime_dvd_mult_iff_int ~&gt; coprime_dvd_mult_iff<br/>  realpow_minus_mult ~&gt; power_minus_mult<br/>  realpow_Suc_le_self ~&gt; power_Suc_le_self<br/>  dvd_Gcd, dvd_Gcd_nat, dvd_Gcd_int removed in favour of Gcd_greatest<br/>INCOMPATIBILITY.<br/><br/>* Renamed HOL/Quotient_Examples/FSet.thy to<br/>HOL/Quotient_Examples/Quotient_FSet.thy INCOMPATIBILITY.<br/><br/>* Session HOL-Library: theory FinFun bundles &quot;finfun_syntax&quot; and<br/>&quot;no_finfun_syntax&quot; allow to control optional syntax in local contexts;<br/>this supersedes former theory FinFun_Syntax. INCOMPATIBILITY, e.g. use<br/>&quot;unbundle finfun_syntax&quot; to imitate import of<br/>&quot;~~/src/HOL/Library/FinFun_Syntax&quot;.<br/><br/>* Session HOL-Library: theory Multiset_Permutations (executably) defines<br/>the set of permutations of a given set or multiset, i.e. the set of all<br/>lists that contain every element of the carrier (multi-)set exactly<br/>once.<br/><br/>* Session HOL-Library: multiset membership is now expressed using<br/>set_mset rather than count.<br/><br/>  - Expressions &quot;count M a &gt; 0&quot; and similar simplify to membership<br/>    by default.<br/><br/>  - Converting between &quot;count M a = 0&quot; and non-membership happens using<br/>    equations count_eq_zero_iff and not_in_iff.<br/><br/>  - Rules count_inI and in_countE obtain facts of the form<br/>    &quot;count M a = n&quot; from membership.<br/><br/>  - Rules count_in_diffI and in_diff_countE obtain facts of the form<br/>    &quot;count M a = n + count N a&quot; from membership on difference sets.<br/><br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library: theory LaTeXsugar uses new-style &quot;dummy_pats&quot; for<br/>displaying equations in functional programming style --- variables<br/>present on the left-hand but not on the righ-hand side are replaced by<br/>underscores.<br/><br/>* Session HOL-Library: theory Combinator_PER provides combinator to<br/>build partial equivalence relations from a predicate and an equivalence<br/>relation.<br/><br/>* Session HOL-Library: theory Perm provides basic facts about almost<br/>everywhere fix bijections.<br/><br/>* Session HOL-Library: theory Normalized_Fraction allows viewing an<br/>element of a field of fractions as a normalized fraction (i.e. a pair of<br/>numerator and denominator such that the two are coprime and the<br/>denominator is normalized wrt. unit factors).<br/><br/>* Session HOL-NSA has been renamed to HOL-Nonstandard_Analysis.<br/><br/>* Session HOL-Multivariate_Analysis has been renamed to HOL-Analysis.<br/><br/>* Session HOL-Analysis: measure theory has been moved here from<br/>HOL-Probability. When importing HOL-Analysis some theorems need<br/>additional name spaces prefixes due to name clashes. INCOMPATIBILITY.<br/><br/>* Session HOL-Analysis: more complex analysis including Cauchy&#39;s<br/>inequality, Liouville theorem, open mapping theorem, maximum modulus<br/>principle, Residue theorem, Schwarz Lemma.<br/><br/>* Session HOL-Analysis: Theory of polyhedra: faces, extreme points,<br/>polytopes, and the Krein–Milman Minkowski theorem.<br/><br/>* Session HOL-Analysis: Numerous results ported from the HOL Light<br/>libraries: homeomorphisms, continuous function extensions, invariance of<br/>domain.<br/><br/>* Session HOL-Probability: the type of emeasure and nn_integral was<br/>changed from ereal to ennreal, INCOMPATIBILITY.<br/><br/>  emeasure :: &#39;a measure ⇒ &#39;a set ⇒ ennreal<br/>  nn_integral :: &#39;a measure ⇒ (&#39;a ⇒ ennreal) ⇒ ennreal<br/><br/>* Session HOL-Probability: Code generation and QuickCheck for<br/>Probability Mass Functions.<br/><br/>* Session HOL-Probability: theory Random_Permutations contains some<br/>theory about choosing a permutation of a set uniformly at random and<br/>folding over a list in random order.<br/><br/>* Session HOL-Probability: theory SPMF formalises discrete<br/>subprobability distributions.<br/><br/>* Session HOL-Library: the names of multiset theorems have been<br/>normalised to distinguish which ordering the theorems are about<br/><br/>    mset_less_eqI ~&gt; mset_subset_eqI<br/>    mset_less_insertD ~&gt; mset_subset_insertD<br/>    mset_less_eq_count ~&gt; mset_subset_eq_count<br/>    mset_less_diff_self ~&gt; mset_subset_diff_self<br/>    mset_le_exists_conv ~&gt; mset_subset_eq_exists_conv<br/>    mset_le_mono_add_right_cancel ~&gt; mset_subset_eq_mono_add_right_cancel<br/>    mset_le_mono_add_left_cancel ~&gt; mset_subset_eq_mono_add_left_cancel<br/>    mset_le_mono_add ~&gt; mset_subset_eq_mono_add<br/>    mset_le_add_left ~&gt; mset_subset_eq_add_left<br/>    mset_le_add_right ~&gt; mset_subset_eq_add_right<br/>    mset_le_single ~&gt; mset_subset_eq_single<br/>    mset_le_multiset_union_diff_commute ~&gt; mset_subset_eq_multiset_union_diff_commute<br/>    diff_le_self ~&gt; diff_subset_eq_self<br/>    mset_leD ~&gt; mset_subset_eqD<br/>    mset_lessD ~&gt; mset_subsetD<br/>    mset_le_insertD ~&gt; mset_subset_eq_insertD<br/>    mset_less_of_empty ~&gt; mset_subset_of_empty<br/>    mset_less_size ~&gt; mset_subset_size<br/>    wf_less_mset_rel ~&gt; wf_subset_mset_rel<br/>    count_le_replicate_mset_le ~&gt; count_le_replicate_mset_subset_eq<br/>    mset_remdups_le ~&gt; mset_remdups_subset_eq<br/>    ms_lesseq_impl ~&gt; subset_eq_mset_impl<br/><br/>Some functions have been renamed:<br/>    ms_lesseq_impl -&gt; subset_eq_mset_impl<br/><br/>* HOL-Library: multisets are now ordered with the multiset ordering<br/>    #⊆# ~&gt; ≤<br/>    #⊂# ~&gt; &lt;<br/>    le_multiset ~&gt; less_eq_multiset<br/>    less_multiset ~&gt; le_multiset<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library: the prefix multiset_order has been discontinued:<br/>the theorems can be directly accessed. As a consequence, the lemmas<br/>&quot;order_multiset&quot; and &quot;linorder_multiset&quot; have been discontinued, and the<br/>interpretations &quot;multiset_linorder&quot; and &quot;multiset_wellorder&quot; have been<br/>replaced by instantiations. INCOMPATIBILITY.<br/><br/>* Session HOL-Library: some theorems about the multiset ordering have<br/>been renamed:<br/><br/>    le_multiset_def ~&gt; less_eq_multiset_def<br/>    less_multiset_def ~&gt; le_multiset_def<br/>    less_eq_imp_le_multiset ~&gt; subset_eq_imp_le_multiset<br/>    mult_less_not_refl ~&gt; mset_le_not_refl<br/>    mult_less_trans ~&gt; mset_le_trans<br/>    mult_less_not_sym ~&gt; mset_le_not_sym<br/>    mult_less_asym ~&gt; mset_le_asym<br/>    mult_less_irrefl ~&gt; mset_le_irrefl<br/>    union_less_mono2{,1,2} ~&gt; union_le_mono2{,1,2}<br/><br/>    le_multiset<sub>H</sub><sub>O</sub> ~&gt; less_eq_multiset<sub>H</sub><sub>O</sub><br/>    le_multiset_total ~&gt; less_eq_multiset_total<br/>    less_multiset_right_total ~&gt; subset_eq_imp_le_multiset<br/>    le_multiset_empty_left ~&gt; less_eq_multiset_empty_left<br/>    le_multiset_empty_right ~&gt; less_eq_multiset_empty_right<br/>    less_multiset_empty_right ~&gt; le_multiset_empty_left<br/>    less_multiset_empty_left ~&gt; le_multiset_empty_right<br/>    union_less_diff_plus ~&gt; union_le_diff_plus<br/>    ex_gt_count_imp_less_multiset ~&gt; ex_gt_count_imp_le_multiset<br/>    less_multiset_plus_left_nonempty ~&gt; le_multiset_plus_left_nonempty<br/>    le_multiset_plus_right_nonempty ~&gt; le_multiset_plus_right_nonempty<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library: the lemma mset_map has now the attribute [simp].<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library: some theorems about multisets have been removed.<br/>INCOMPATIBILITY, use the following replacements:<br/><br/>    le_multiset_plus_plus_left_iff ~&gt; add_less_cancel_right<br/>    less_multiset_plus_plus_left_iff ~&gt; add_less_cancel_right<br/>    le_multiset_plus_plus_right_iff ~&gt; add_less_cancel_left<br/>    less_multiset_plus_plus_right_iff ~&gt; add_less_cancel_left<br/>    add_eq_self_empty_iff ~&gt; add_cancel_left_right<br/>    mset_subset_add_bothsides ~&gt; subset_mset.add_less_cancel_right<br/>    mset_less_add_bothsides ~&gt; subset_mset.add_less_cancel_right<br/>    mset_le_add_bothsides ~&gt; subset_mset.add_less_cancel_right<br/>    empty_inter ~&gt; subset_mset.inf_bot_left<br/>    inter_empty ~&gt; subset_mset.inf_bot_right<br/>    empty_sup ~&gt; subset_mset.sup_bot_left<br/>    sup_empty ~&gt; subset_mset.sup_bot_right<br/>    bdd_below_multiset ~&gt; subset_mset.bdd_above_bot<br/>    subset_eq_empty ~&gt; subset_mset.le_zero_eq<br/>    le_empty ~&gt; subset_mset.le_zero_eq<br/>    mset_subset_empty_nonempty ~&gt; subset_mset.zero_less_iff_neq_zero<br/>    mset_less_empty_nonempty ~&gt; subset_mset.zero_less_iff_neq_zero<br/><br/>* Session HOL-Library: some typeclass constraints about multisets have<br/>been reduced from ordered or linordered to preorder. Multisets have the<br/>additional typeclasses order_bot, no_top,<br/>ordered_ab_semigroup_add_imp_le, ordered_cancel_comm_monoid_add,<br/>linordered_cancel_ab_semigroup_add, and<br/>ordered_ab_semigroup_monoid_add_imp_le. INCOMPATIBILITY.<br/><br/>* Session HOL-Library: there are some new simplification rules about<br/>multisets, the multiset ordering, and the subset ordering on multisets.<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library: the subset ordering on multisets has now the<br/>interpretations ordered_ab_semigroup_monoid_add_imp_le and<br/>bounded_lattice_bot. INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: single has been removed in favor<br/>of add_mset that roughly corresponds to Set.insert. Some theorems have<br/>removed or changed:<br/><br/>  single_not_empty ~&gt; add_mset_not_empty or empty_not_add_mset<br/>  fold_mset_insert ~&gt; fold_mset_add_mset<br/>  image_mset_insert ~&gt; image_mset_add_mset<br/>  union_single_eq_diff<br/>  multi_self_add_other_not_self<br/>  diff_single_eq_union<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: some theorems have been changed<br/>to use add_mset instead of single:<br/><br/>  mset_add<br/>  multi_self_add_other_not_self<br/>  diff_single_eq_union<br/>  union_single_eq_diff<br/>  union_single_eq_member<br/>  add_eq_conv_diff<br/>  insert_noteq_member<br/>  add_eq_conv_ex<br/>  multi_member_split<br/>  multiset_add_sub_el_shuffle<br/>  mset_subset_eq_insertD<br/>  mset_subset_insertD<br/>  insert_subset_eq_iff<br/>  insert_union_subset_iff<br/>  multi_psub_of_add_self<br/>  inter_add_left1<br/>  inter_add_left2<br/>  inter_add_right1<br/>  inter_add_right2<br/>  sup_union_left1<br/>  sup_union_left2<br/>  sup_union_right1<br/>  sup_union_right2<br/>  size_eq_Suc_imp_eq_union<br/>  multi_nonempty_split<br/>  mset_insort<br/>  mset_update<br/>  mult1I<br/>  less_add<br/>  mset_zip_take_Cons_drop_twice<br/>  rel_mset_Zero<br/>  msed_map_invL<br/>  msed_map_invR<br/>  msed_rel_invL<br/>  msed_rel_invR<br/>  le_multiset_right_total<br/>  multiset_induct<br/>  multiset_induct2_size<br/>  multiset_induct2<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: the definitions of some<br/>constants have changed to use add_mset instead of adding a single<br/>element:<br/><br/>  image_mset<br/>  mset<br/>  replicate_mset<br/>  mult1<br/>  pred_mset<br/>  rel_mset&#39;<br/>  mset_insort<br/><br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: due to the above changes, the<br/>attributes of some multiset theorems have been changed:<br/><br/>  insert_DiffM  [] ~&gt; [simp]<br/>  insert_DiffM2 [simp] ~&gt; []<br/>  diff_add_mset_swap [simp]<br/>  fold_mset_add_mset [simp]<br/>  diff_diff_add [simp] (for multisets only)<br/>  diff_cancel [simp] ~&gt; []<br/>  count_single [simp] ~&gt; []<br/>  set_mset_single [simp] ~&gt; []<br/>  size_multiset_single [simp] ~&gt; []<br/>  size_single [simp] ~&gt; []<br/>  image_mset_single [simp] ~&gt; []<br/>  mset_subset_eq_mono_add_right_cancel [simp] ~&gt; []<br/>  mset_subset_eq_mono_add_left_cancel [simp] ~&gt; []<br/>  fold_mset_single [simp] ~&gt; []<br/>  subset_eq_empty [simp] ~&gt; []<br/>  empty_sup [simp] ~&gt; []<br/>  sup_empty [simp] ~&gt; []<br/>  inter_empty [simp] ~&gt; []<br/>  empty_inter [simp] ~&gt; []<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: the order of the variables in<br/>the second cases of multiset_induct, multiset_induct2_size,<br/>multiset_induct2 has been changed (e.g. Add A a ~&gt; Add a A).<br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: there is now a simplification<br/>procedure on multisets. It mimics the behavior of the procedure on<br/>natural numbers. INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: renamed sums and products of<br/>multisets:<br/><br/>  msetsum ~&gt; sum_mset<br/>  msetprod ~&gt; prod_mset<br/><br/>* Session HOL-Library, theory Multiset: the notation for intersection<br/>and union of multisets have been changed:<br/><br/>  #∩ ~&gt; ∩#<br/>  #∪ ~&gt; ∪#<br/><br/>INCOMPATIBILITY.<br/><br/>* Session HOL-Library, theory Multiset: the lemma<br/>one_step_implies_mult_aux on multisets has been removed, use<br/>one_step_implies_mult instead. INCOMPATIBILITY.<br/><br/>* Session HOL-Library: theory Complete_Partial_Order2 provides reasoning<br/>support for monotonicity and continuity in chain-complete partial orders<br/>and about admissibility conditions for fixpoint inductions.<br/><br/>* Session HOL-Library: theory Library/Polynomial contains also<br/>derivation of polynomials (formerly in Library/Poly_Deriv) but not<br/>gcd/lcm on polynomials over fields. This has been moved to a separate<br/>theory Library/Polynomial_GCD_euclidean.thy, to pave way for a possible<br/>future different type class instantiation for polynomials over factorial<br/>rings. INCOMPATIBILITY.<br/><br/>* Session HOL-Library: theory Sublist provides function &quot;prefixes&quot; with<br/>the following renaming<br/><br/>  prefixeq -&gt; prefix<br/>  prefix -&gt; strict_prefix<br/>  suffixeq -&gt; suffix<br/>  suffix -&gt; strict_suffix<br/><br/>Added theory of longest common prefixes.<br/><br/>* Session HOL-Number_Theory: algebraic foundation for primes:<br/>Generalisation of predicate &quot;prime&quot; and introduction of predicates<br/>&quot;prime_elem&quot;, &quot;irreducible&quot;, a &quot;prime_factorization&quot; function, and the<br/>&quot;factorial_ring&quot; typeclass with instance proofs for nat, int, poly. Some<br/>theorems now have different names, most notably &quot;prime_def&quot; is now<br/>&quot;prime_nat_iff&quot;. INCOMPATIBILITY.<br/><br/>* Session Old_Number_Theory has been removed, after porting remaining<br/>theories.<br/><br/>* Session HOL-Types_To_Sets provides an experimental extension of<br/>Higher-Order Logic to allow translation of types to sets.<br/><br/><br/>*** ML ***<br/><br/>* Integer.gcd and Integer.lcm use efficient operations from the Poly/ML<br/>library (notably for big integers). Subtle change of semantics:<br/>Integer.gcd and Integer.lcm both normalize the sign, results are never<br/>negative. This coincides with the definitions in HOL/GCD.thy.<br/>INCOMPATIBILITY.<br/><br/>* Structure Rat for rational numbers is now an integral part of<br/>Isabelle/ML, with special notation @int/nat or @int for numerals (an<br/>abbreviation for antiquotation @{Pure.rat argument}) and ML pretty<br/>printing. Standard operations on type Rat.rat are provided via ad-hoc<br/>overloading of + - * / &lt; &lt;= &gt; &gt;= ~ abs. INCOMPATIBILITY, need to<br/>use + instead of +/ etc. Moreover, exception Rat.DIVZERO has been<br/>superseded by General.Div.<br/><br/>* ML antiquotation @{path} is superseded by @{file}, which ensures that<br/>the argument is a plain file. Minor INCOMPATIBILITY.<br/><br/>* Antiquotation @{make_string} is available during Pure bootstrap --<br/>with approximative output quality.<br/><br/>* Low-level ML system structures (like PolyML and RunCall) are no longer<br/>exposed to Isabelle/ML user-space. Potential INCOMPATIBILITY.<br/><br/>* The ML function &quot;ML&quot; provides easy access to run-time compilation.<br/>This is particularly useful for conditional compilation, without<br/>requiring separate files.<br/><br/>* Option ML_exception_debugger controls detailed exception trace via the<br/>Poly/ML debugger. Relevant ML modules need to be compiled beforehand<br/>with ML_file_debug, or with ML_file and option ML_debugger enabled. Note<br/>debugger information requires consirable time and space: main<br/>Isabelle/HOL with full debugger support may need ML_system_64.<br/><br/>* Local_Theory.restore has been renamed to Local_Theory.reset to<br/>emphasize its disruptive impact on the cumulative context, notably the<br/>scope of &#39;private&#39; or &#39;qualified&#39; names. Note that Local_Theory.reset is<br/>only appropriate when targets are managed, e.g. starting from a global<br/>theory and returning to it. Regular definitional packages should use<br/>balanced blocks of Local_Theory.open_target versus<br/>Local_Theory.close_target instead. Rare INCOMPATIBILITY.<br/><br/>* Structure TimeLimit (originally from the SML/NJ library) has been<br/>replaced by structure Timeout, with slightly different signature.<br/>INCOMPATIBILITY.<br/><br/>* Discontinued cd and pwd operations, which are not well-defined in a<br/>multi-threaded environment. Note that files are usually located<br/>relatively to the master directory of a theory (see also<br/>File.full_path). Potential INCOMPATIBILITY.<br/><br/>* Binding.empty_atts supersedes Thm.empty_binding and<br/>Attrib.empty_binding. Minor INCOMPATIBILITY.<br/><br/><br/>*** System ***<br/><br/>* SML/NJ and old versions of Poly/ML are no longer supported.<br/><br/>* Poly/ML heaps now follow the hierarchy of sessions, and thus require<br/>much less disk space.<br/><br/>* The Isabelle ML process is now managed directly by Isabelle/Scala, and<br/>shell scripts merely provide optional command-line access. In<br/>particular:<br/><br/>  . Scala module ML_Process to connect to the raw ML process,<br/>    with interaction via stdin/stdout/stderr or in batch mode;<br/>  . command-line tool &quot;isabelle console&quot; as interactive wrapper;<br/>  . command-line tool &quot;isabelle process&quot; as batch mode wrapper.<br/><br/>* The executable &quot;isabelle_process&quot; has been discontinued. Tools and<br/>prover front-ends should use ML_Process or Isabelle_Process in<br/>Isabelle/Scala. INCOMPATIBILITY.<br/><br/>* New command-line tool &quot;isabelle process&quot; supports ML evaluation of<br/>literal expressions (option -e) or files (option -f) in the context of a<br/>given heap image. Errors lead to premature exit of the ML process with<br/>return code 1.<br/><br/>* The command-line tool &quot;isabelle build&quot; supports option -N for cyclic<br/>shuffling of NUMA CPU nodes. This may help performance tuning on Linux<br/>servers with separate CPU/memory modules.<br/><br/>* System option &quot;threads&quot; (for the size of the Isabelle/ML thread farm)<br/>is also passed to the underlying ML runtime system as --gcthreads,<br/>unless there is already a default provided via ML_OPTIONS settings.<br/><br/>* System option &quot;checkpoint&quot; helps to fine-tune the global heap space<br/>management of isabelle build. This is relevant for big sessions that may<br/>exhaust the small 32-bit address space of the ML process (which is used<br/>by default).<br/><br/>* System option &quot;profiling&quot; specifies the mode for global ML profiling<br/>in &quot;isabelle build&quot;. Possible values are &quot;time&quot;, &quot;allocations&quot;. The<br/>command-line tool &quot;isabelle profiling_report&quot; helps to digest the<br/>resulting log files.<br/><br/>* System option &quot;ML_process_policy&quot; specifies an optional command prefix<br/>for the underlying ML process, e.g. to control CPU affinity on<br/>multiprocessor systems. The &quot;isabelle jedit&quot; tool allows to override the<br/>implicit default via option -p.<br/><br/>* Command-line tool &quot;isabelle console&quot; provides option -r to help to<br/>bootstrapping Isabelle/Pure interactively.<br/><br/>* Command-line tool &quot;isabelle yxml&quot; has been discontinued.<br/>INCOMPATIBILITY, use operations from the modules &quot;XML&quot; and &quot;YXML&quot; in<br/>Isabelle/ML or Isabelle/Scala.<br/><br/>* Many Isabelle tools that require a Java runtime system refer to the<br/>settings ISABELLE_TOOL_JAVA_OPTIONS32 / ISABELLE_TOOL_JAVA_OPTIONS64,<br/>depending on the underlying platform. The settings for &quot;isabelle build&quot;<br/>ISABELLE_BUILD_JAVA_OPTIONS32 / ISABELLE_BUILD_JAVA_OPTIONS64 have been<br/>discontinued. Potential INCOMPATIBILITY.<br/><br/>* The Isabelle system environment always ensures that the main<br/>executables are found within the shell search $PATH: &quot;isabelle&quot; and<br/>&quot;isabelle_scala_script&quot;.<br/><br/>* Isabelle tools may consist of .scala files: the Scala compiler is<br/>invoked on the spot. The source needs to define some object that extends<br/>Isabelle_Tool.Body.<br/><br/>* File.bash_string, File.bash_path etc. represent Isabelle/ML and<br/>Isabelle/Scala strings authentically within GNU bash. This is useful to<br/>produce robust shell scripts under program control, without worrying<br/>about spaces or special characters. Note that user output works via<br/>Path.print (ML) or Path.toString (Scala). INCOMPATIBILITY, the old (and<br/>less versatile) operations File.shell_quote, File.shell_path etc. have<br/>been discontinued.<br/><br/>* The isabelle_java executable allows to run a Java process within the<br/>name space of Java and Scala components that are bundled with Isabelle,<br/>but without the Isabelle settings environment.<br/><br/>* Isabelle/Scala: the SSH module supports ssh and sftp connections, for<br/>remote command-execution and file-system access. This resembles<br/>operations from module File and Isabelle_System to some extent. Note<br/>that Path specifications need to be resolved remotely via<br/>ssh.remote_path instead of File.standard_path: the implicit process<br/>environment is different, Isabelle settings are not available remotely.<br/><br/>* Isabelle/Scala: the Mercurial module supports repositories via the<br/>regular hg command-line interface. The repositroy clone and working<br/>directory may reside on a local or remote file-system (via ssh<br/>connection).<br/><br/><br/><br/>New in Isabelle2016 (February 2016)<br/>-----------------------------------<br/><br/>*** General ***<br/><br/>* Eisbach is now based on Pure instead of HOL. Objects-logics may import<br/>either the theory ~~/src/HOL/Eisbach/Eisbach (for HOL etc.) or<br/>~~/src/HOL/Eisbach/Eisbach_Old_Appl_Syntax (for FOL, ZF etc.). Note that<br/>the HOL-Eisbach session located in ~~/src/HOL/Eisbach/ contains further<br/>examples that do require HOL.<br/><br/>* Better resource usage on all platforms (Linux, Windows, Mac OS X) for<br/>both Isabelle/ML and Isabelle/Scala.  Slightly reduced heap space usage.<br/><br/>* Former &quot;xsymbols&quot; syntax with Isabelle symbols is used by default,<br/>without any special print mode. Important ASCII replacement syntax<br/>remains available under print mode &quot;ASCII&quot;, but less important syntax<br/>has been removed (see below).<br/><br/>* Support for more arrow symbols, with rendering in LaTeX and Isabelle<br/>fonts: ⇚ ⇛ ⤎ ⤏ ⇠ ⇢.<br/><br/>* Special notation \&lt;struct&gt; for the first implicit &#39;structure&#39; in the<br/>context has been discontinued. Rare INCOMPATIBILITY, use explicit<br/>structure name instead, notably in indexed notation with block-subscript<br/>(e.g. ⊙⇘A⇙).<br/><br/>* The glyph for ◇ in the IsabelleText font now corresponds better to its<br/>counterpart □ as quantifier-like symbol. A small diamond is available as<br/>⋄; the old symbol \&lt;struct&gt; loses this rendering and any special<br/>meaning.<br/><br/>* Syntax for formal comments &quot;-- text&quot; now also supports the symbolic<br/>form &quot;― text&quot;. Command-line tool &quot;isabelle update_cartouches -c&quot; helps<br/>to update old sources.<br/><br/>* Toplevel theorem statements have been simplified as follows:<br/><br/>  theorems             ~&gt;  lemmas<br/>  schematic_lemma      ~&gt;  schematic_goal<br/>  schematic_theorem    ~&gt;  schematic_goal<br/>  schematic_corollary  ~&gt;  schematic_goal<br/><br/>Command-line tool &quot;isabelle update_theorems&quot; updates theory sources<br/>accordingly.<br/><br/>* Toplevel theorem statement &#39;proposition&#39; is another alias for<br/>&#39;theorem&#39;.<br/><br/>* The old &#39;defs&#39; command has been removed (legacy since Isabelle2014).<br/>INCOMPATIBILITY, use regular &#39;definition&#39; instead. Overloaded and/or<br/>deferred definitions require a surrounding &#39;overloading&#39; block.<br/><br/><br/>*** Prover IDE -- Isabelle/Scala/jEdit ***<br/><br/>* IDE support for the source-level debugger of Poly/ML, to work with<br/>Isabelle/ML and official Standard ML. Option &quot;ML_debugger&quot; and commands<br/>&#39;ML_file_debug&#39;, &#39;ML_file_no_debug&#39;, &#39;SML_file_debug&#39;,<br/>&#39;SML_file_no_debug&#39; control compilation of sources with or without<br/>debugging information. The Debugger panel allows to set breakpoints (via<br/>context menu), step through stopped threads, evaluate local ML<br/>expressions etc. At least one Debugger view needs to be active to have<br/>any effect on the running ML program.<br/><br/>* The State panel manages explicit proof state output, with dynamic<br/>auto-update according to cursor movement. Alternatively, the jEdit<br/>action &quot;isabelle.update-state&quot; (shortcut S+ENTER) triggers manual<br/>update.<br/><br/>* The Output panel no longer shows proof state output by default, to<br/>avoid GUI overcrowding. INCOMPATIBILITY, use the State panel instead or<br/>enable option &quot;editor_output_state&quot;.<br/><br/>* The text overview column (status of errors, warnings etc.) is updated<br/>asynchronously, leading to much better editor reactivity. Moreover, the<br/>full document node content is taken into account. The width of the<br/>column is scaled according to the main text area font, for improved<br/>visibility.<br/><br/>* The main text area no longer changes its color hue in outdated<br/>situations. The text overview column takes over the role to indicate<br/>unfinished edits in the PIDE pipeline. This avoids flashing text display<br/>due to ad-hoc updates by auxiliary GUI components, such as the State<br/>panel.<br/><br/>* Slightly improved scheduling for urgent print tasks (e.g. command<br/>state output, interactive queries) wrt. long-running background tasks.<br/><br/>* Completion of symbols via prefix of \&lt;name&gt; or \&lt;^name&gt; or \name is<br/>always possible, independently of the language context. It is never<br/>implicit: a popup will show up unconditionally.<br/><br/>* Additional abbreviations for syntactic completion may be specified in<br/>$ISABELLE_HOME/etc/abbrevs and $ISABELLE_HOME_USER/etc/abbrevs, with<br/>support for simple templates using ASCII 007 (bell) as placeholder.<br/><br/>* Symbols ⊕, ⨁, ⊗, ⨂, ⊙, ⨀, ⊖, ⊘ no longer provide abbreviations for<br/>completion like &quot;+o&quot;, &quot;*o&quot;, &quot;.o&quot; etc. -- due to conflicts with other<br/>ASCII syntax. INCOMPATIBILITY, use plain backslash-completion or define<br/>suitable abbreviations in $ISABELLE_HOME_USER/etc/abbrevs.<br/><br/>* Action &quot;isabelle-emph&quot; (with keyboard shortcut C+e LEFT) controls<br/>emphasized text style; the effect is visible in document output, not in<br/>the editor.<br/><br/>* Action &quot;isabelle-reset&quot; now uses keyboard shortcut C+e BACK_SPACE,<br/>instead of former C+e LEFT.<br/><br/>* The command-line tool &quot;isabelle jedit&quot; and the isabelle.Main<br/>application wrapper treat the default $USER_HOME/Scratch.thy more<br/>uniformly, and allow the dummy file argument &quot;:&quot; to open an empty buffer<br/>instead.<br/><br/>* New command-line tool &quot;isabelle jedit_client&quot; allows to connect to an<br/>already running Isabelle/jEdit process. This achieves the effect of<br/>single-instance applications seen on common GUI desktops.<br/><br/>* The default look-and-feel for Linux is the traditional &quot;Metal&quot;, which<br/>works better with GUI scaling for very high-resolution displays (e.g.<br/>4K). Moreover, it is generally more robust than &quot;Nimbus&quot;.<br/><br/>* Update to jedit-5.3.0, with improved GUI scaling and support of<br/>high-resolution displays (e.g. 4K).<br/><br/>* The main Isabelle executable is managed as single-instance Desktop<br/>application uniformly on all platforms: Linux, Windows, Mac OS X.<br/><br/><br/>*** Document preparation ***<br/><br/>* Commands &#39;paragraph&#39; and &#39;subparagraph&#39; provide additional section<br/>headings. Thus there are 6 levels of standard headings, as in HTML.<br/><br/>* Command &#39;text_raw&#39; has been clarified: input text is processed as in<br/>&#39;text&#39; (with antiquotations and control symbols). The key difference is<br/>the lack of the surrounding isabelle markup environment in output.<br/><br/>* Text is structured in paragraphs and nested lists, using notation that<br/>is similar to Markdown. The control symbols for list items are as<br/>follows:<br/><br/>  ▪  itemize<br/>  ▸  enumerate<br/>  ➧  description<br/><br/>* There is a new short form for antiquotations with a single argument<br/>that is a cartouche: \&lt;^name&gt;‹...› is equivalent to @{name ‹...›} and<br/>‹...› without control symbol is equivalent to @{cartouche ‹...›}.<br/>\&lt;^name&gt; without following cartouche is equivalent to @{name}. The<br/>standard Isabelle fonts provide glyphs to render important control<br/>symbols, e.g. &quot;▩&quot;, &quot;∗&quot;, &quot;❙&quot;.<br/><br/>* Antiquotations @{noindent}, @{smallskip}, @{medskip}, @{bigskip} with<br/>corresponding control symbols ⇤, ┈, ┉, ━ specify spacing formally, using<br/>standard LaTeX macros of the same names.<br/><br/>* Antiquotation @{cartouche} in Isabelle/Pure is the same as @{text}.<br/>Consequently, ‹...› without any decoration prints literal quasi-formal<br/>text. Command-line tool &quot;isabelle update_cartouches -t&quot; helps to update<br/>old sources, by approximative patching of the content of string and<br/>cartouche tokens seen in theory sources.<br/><br/>* The @{text} antiquotation now ignores the antiquotation option<br/>&quot;source&quot;. The given text content is output unconditionally, without any<br/>surrounding quotes etc. Subtle INCOMPATIBILITY, put quotes into the<br/>argument where they are really intended, e.g. @{text ‹&quot;foo&quot;›}. Initial<br/>or terminal spaces are ignored.<br/><br/>* Antiquotations @{emph} and @{bold} output LaTeX source recursively,<br/>adding appropriate text style markup. These may be used in the short<br/>form ∗‹...› and ❙‹...›.<br/><br/>* Document antiquotation @{footnote} outputs LaTeX source recursively,<br/>marked as \footnote{}. This may be used in the short form ⁋‹...›.<br/><br/>* Antiquotation @{verbatim [display]} supports option &quot;indent&quot;.<br/><br/>* Antiquotation @{theory_text} prints uninterpreted theory source text<br/>(Isar outer syntax with command keywords etc.). This may be used in the<br/>short form ⬚‹...›. @{theory_text [display]} supports option &quot;indent&quot;.<br/><br/>* Antiquotation @{doc ENTRY} provides a reference to the given<br/>documentation, with a hyperlink in the Prover IDE.<br/><br/>* Antiquotations @{command}, @{method}, @{attribute} print checked<br/>entities of the Isar language.<br/><br/>* HTML presentation uses the standard IsabelleText font and Unicode<br/>rendering of Isabelle symbols like Isabelle/Scala/jEdit.  The former<br/>print mode &quot;HTML&quot; loses its special meaning.<br/><br/><br/>*** Isar ***<br/><br/>* Local goals (&#39;have&#39;, &#39;show&#39;, &#39;hence&#39;, &#39;thus&#39;) allow structured rule<br/>statements like fixes/assumes/shows in theorem specifications, but the<br/>notation is postfix with keywords &#39;if&#39; (or &#39;when&#39;) and &#39;for&#39;. For<br/>example:<br/><br/>  have result: &quot;C x y&quot;<br/>    if &quot;A x&quot; and &quot;B y&quot;<br/>    for x :: &#39;a and y :: &#39;a<br/>    &lt;proof&gt;<br/><br/>The local assumptions are bound to the name &quot;that&quot;. The result is<br/>exported from context of the statement as usual. The above roughly<br/>corresponds to a raw proof block like this:<br/><br/>  {<br/>    fix x :: &#39;a and y :: &#39;a<br/>    assume that: &quot;A x&quot; &quot;B y&quot;<br/>    have &quot;C x y&quot; &lt;proof&gt;<br/>  }<br/>  note result = this<br/><br/>The keyword &#39;when&#39; may be used instead of &#39;if&#39;, to indicate &#39;presume&#39;<br/>instead of &#39;assume&#39; above.<br/><br/>* Assumptions (&#39;assume&#39;, &#39;presume&#39;) allow structured rule statements<br/>using &#39;if&#39; and &#39;for&#39;, similar to &#39;have&#39; etc. above. For example:<br/><br/>  assume result: &quot;C x y&quot;<br/>    if &quot;A x&quot; and &quot;B y&quot;<br/>    for x :: &#39;a and y :: &#39;a<br/><br/>This assumes &quot;⋀x y::&#39;a. A x ⟹ B y ⟹ C x y&quot; and produces a general<br/>result as usual: &quot;A ?x ⟹ B ?y ⟹ C ?x ?y&quot;.<br/><br/>Vacuous quantification in assumptions is omitted, i.e. a for-context<br/>only effects propositions according to actual use of variables. For<br/>example:<br/><br/>  assume &quot;A x&quot; and &quot;B y&quot; for x and y<br/><br/>is equivalent to:<br/><br/>  assume &quot;⋀x. A x&quot; and &quot;⋀y. B y&quot;<br/><br/>* The meaning of &#39;show&#39; with Pure rule statements has changed: premises<br/>are treated in the sense of &#39;assume&#39;, instead of &#39;presume&#39;. This means,<br/>a goal like &quot;⋀x. A x ⟹ B x ⟹ C x&quot; can be solved completely as<br/>follows:<br/><br/>  show &quot;⋀x. A x ⟹ B x ⟹ C x&quot;<br/><br/>or:<br/><br/>  show &quot;C x&quot; if &quot;A x&quot; &quot;B x&quot; for x<br/><br/>Rare INCOMPATIBILITY, the old behaviour may be recovered as follows:<br/><br/>  show &quot;C x&quot; when &quot;A x&quot; &quot;B x&quot; for x<br/><br/>* New command &#39;consider&#39; states rules for generalized elimination and<br/>case splitting. This is like a toplevel statement &quot;theorem obtains&quot; used<br/>within a proof body; or like a multi-branch &#39;obtain&#39; without activation<br/>of the local context elements yet.<br/><br/>* Proof method &quot;cases&quot; allows to specify the rule as first entry of<br/>chained facts.  This is particularly useful with &#39;consider&#39;:<br/><br/>  consider (a) A | (b) B | (c) C &lt;proof&gt;<br/>  then have something<br/>  proof cases<br/>    case a<br/>    then show ?thesis &lt;proof&gt;<br/>  next<br/>    case b<br/>    then show ?thesis &lt;proof&gt;<br/>  next<br/>    case c<br/>    then show ?thesis &lt;proof&gt;<br/>  qed<br/><br/>* Command &#39;case&#39; allows fact name and attribute specification like this:<br/><br/>  case a: (c xs)<br/>  case a [attributes]: (c xs)<br/><br/>Facts that are introduced by invoking the case context are uniformly<br/>qualified by &quot;a&quot;; the same name is used for the cumulative fact. The old<br/>form &quot;case (c xs) [attributes]&quot; is no longer supported. Rare<br/>INCOMPATIBILITY, need to adapt uses of case facts in exotic situations,<br/>and always put attributes in front.<br/><br/>* The standard proof method of commands &#39;proof&#39; and &#39;..&#39; is now called<br/>&quot;standard&quot; to make semantically clear what it is; the old name &quot;default&quot;<br/>is still available as legacy for some time. Documentation now explains<br/>&#39;..&#39; more accurately as &quot;by standard&quot; instead of &quot;by rule&quot;.<br/><br/>* Nesting of Isar goal structure has been clarified: the context after<br/>the initial backwards refinement is retained for the whole proof, within<br/>all its context sections (as indicated via &#39;next&#39;). This is e.g.<br/>relevant for &#39;using&#39;, &#39;including&#39;, &#39;supply&#39;:<br/><br/>  have &quot;A ∧ A&quot; if a: A for A<br/>    supply [simp] = a<br/>  proof<br/>    show A by simp<br/>  next<br/>    show A by simp<br/>  qed<br/><br/>* Command &#39;obtain&#39; binds term abbreviations (via &#39;is&#39; patterns) in the<br/>proof body as well, abstracted over relevant parameters.<br/><br/>* Improved type-inference for theorem statement &#39;obtains&#39;: separate<br/>parameter scope for of each clause.<br/><br/>* Term abbreviations via &#39;is&#39; patterns also work for schematic<br/>statements: result is abstracted over unknowns.<br/><br/>* Command &#39;subgoal&#39; allows to impose some structure on backward<br/>refinements, to avoid proof scripts degenerating into long of &#39;apply&#39;<br/>sequences. Further explanations and examples are given in the isar-ref<br/>manual.<br/><br/>* Command &#39;supply&#39; supports fact definitions during goal refinement<br/>(&#39;apply&#39; scripts).<br/><br/>* Proof method &quot;goal_cases&quot; turns the current subgoals into cases within<br/>the context; the conclusion is bound to variable ?case in each case. For<br/>example:<br/><br/>lemma &quot;⋀x. A x ⟹ B x ⟹ C x&quot;<br/>  and &quot;⋀y z. U y ⟹ V z ⟹ W y z&quot;<br/>proof goal_cases<br/>  case (1 x)<br/>  then show ?case using ‹A x› ‹B x› sorry<br/>next<br/>  case (2 y z)<br/>  then show ?case using ‹U y› ‹V z› sorry<br/>qed<br/><br/>lemma &quot;⋀x. A x ⟹ B x ⟹ C x&quot;<br/>  and &quot;⋀y z. U y ⟹ V z ⟹ W y z&quot;<br/>proof goal_cases<br/>  case prems: 1<br/>  then show ?case using prems sorry<br/>next<br/>  case prems: 2<br/>  then show ?case using prems sorry<br/>qed<br/><br/>* The undocumented feature of implicit cases goal1, goal2, goal3, etc.<br/>is marked as legacy, and will be removed eventually. The proof method<br/>&quot;goals&quot; achieves a similar effect within regular Isar; often it can be<br/>done more adequately by other means (e.g. &#39;consider&#39;).<br/><br/>* The vacuous fact &quot;TERM x&quot; may be established &quot;by fact&quot; or as `TERM x`<br/>as well, not just &quot;by this&quot; or &quot;.&quot; as before.<br/><br/>* Method &quot;sleep&quot; succeeds after a real-time delay (in seconds). This is<br/>occasionally useful for demonstration and testing purposes.<br/><br/><br/>*** Pure ***<br/><br/>* Qualifiers in locale expressions default to mandatory (&#39;!&#39;) regardless<br/>of the command. Previously, for &#39;locale&#39; and &#39;sublocale&#39; the default was<br/>optional (&#39;?&#39;). The old synatx &#39;!&#39; has been discontinued.<br/>INCOMPATIBILITY, remove &#39;!&#39; and add &#39;?&#39; as required.<br/><br/>* Keyword &#39;rewrites&#39; identifies rewrite morphisms in interpretation<br/>commands. Previously, the keyword was &#39;where&#39;. INCOMPATIBILITY.<br/><br/>* More gentle suppression of syntax along locale morphisms while<br/>printing terms. Previously &#39;abbreviation&#39; and &#39;notation&#39; declarations<br/>would be suppressed for morphisms except term identity. Now<br/>&#39;abbreviation&#39; is also kept for morphims that only change the involved<br/>parameters, and only &#39;notation&#39; is suppressed. This can be of great help<br/>when working with complex locale hierarchies, because proof states are<br/>displayed much more succinctly. It also means that only notation needs<br/>to be redeclared if desired, as illustrated by this example:<br/><br/>  locale struct = fixes composition :: &quot;&#39;a =&gt; &#39;a =&gt; &#39;a&quot; (infixl &quot;⋅&quot; 65)<br/>  begin<br/>    definition derived (infixl &quot;⊙&quot; 65) where ...<br/>  end<br/><br/>  locale morphism =<br/>    left: struct composition + right: struct composition&#39;<br/>    for composition (infix &quot;⋅&quot; 65) and composition&#39; (infix &quot;⋅&#39;&#39;&quot; 65)<br/>  begin<br/>    notation right.derived (&quot;⊙&#39;&#39;&quot;)<br/>  end<br/><br/>* Command &#39;global_interpretation&#39; issues interpretations into global<br/>theories, with optional rewrite definitions following keyword &#39;defines&#39;.<br/><br/>* Command &#39;sublocale&#39; accepts optional rewrite definitions after keyword<br/>&#39;defines&#39;.<br/><br/>* Command &#39;permanent_interpretation&#39; has been discontinued. Use<br/>&#39;global_interpretation&#39; or &#39;sublocale&#39; instead. INCOMPATIBILITY.<br/><br/>* Command &#39;print_definitions&#39; prints dependencies of definitional<br/>specifications. This functionality used to be part of &#39;print_theory&#39;.<br/><br/>* Configuration option rule_insts_schematic has been discontinued<br/>(intermediate legacy feature in Isabelle2015). INCOMPATIBILITY.<br/><br/>* Abbreviations in type classes now carry proper sort constraint. Rare<br/>INCOMPATIBILITY in situations where the previous misbehaviour has been<br/>exploited.<br/><br/>* Refinement of user-space type system in type classes: pseudo-local<br/>operations behave more similar to abbreviations. Potential<br/>INCOMPATIBILITY in exotic situations.<br/><br/><br/>*** HOL ***<br/><br/>* The &#39;typedef&#39; command has been upgraded from a partially checked<br/>&quot;axiomatization&quot;, to a full definitional specification that takes the<br/>global collection of overloaded constant / type definitions into<br/>account. Type definitions with open dependencies on overloaded<br/>definitions need to be specified as &quot;typedef (overloaded)&quot;. This<br/>provides extra robustness in theory construction. Rare INCOMPATIBILITY.<br/><br/>* Qualification of various formal entities in the libraries is done more<br/>uniformly via &quot;context begin qualified definition ... end&quot; instead of<br/>old-style &quot;hide_const (open) ...&quot;. Consequently, both the defined<br/>constant and its defining fact become qualified, e.g. Option.is_none and<br/>Option.is_none_def. Occasional INCOMPATIBILITY in applications.<br/><br/>* Some old and rarely used ASCII replacement syntax has been removed.<br/>INCOMPATIBILITY, standard syntax with symbols should be used instead.<br/>The subsequent commands help to reproduce the old forms, e.g. to<br/>simplify porting old theories:<br/><br/>  notation iff  (infixr &quot;&lt;-&gt;&quot; 25)<br/><br/>  notation Times  (infixr &quot;&lt;*&gt;&quot; 80)<br/><br/>  type_notation Map.map  (infixr &quot;~=&gt;&quot; 0)<br/>  notation Map.map_comp  (infixl &quot;o&#39;_m&quot; 55)<br/><br/>  type_notation FinFun.finfun (&quot;(_ =&gt;f /_)&quot; [22, 21] 21)<br/><br/>  notation FuncSet.funcset  (infixr &quot;-&gt;&quot; 60)<br/>  notation FuncSet.extensional_funcset  (infixr &quot;-&gt;<sub>E</sub>&quot; 60)<br/><br/>  notation Omega_Words_Fun.conc (infixr &quot;conc&quot; 65)<br/><br/>  notation Preorder.equiv (&quot;op ~~&quot;)<br/>    and Preorder.equiv (&quot;(_/ ~~ _)&quot; [51, 51] 50)<br/><br/>  notation (in topological_space) tendsto (infixr &quot;---&gt;&quot; 55)<br/>  notation (in topological_space) LIMSEQ (&quot;((_)/ ----&gt; (_))&quot; [60, 60] 60)<br/>  notation LIM (&quot;((_)/ -- (_)/ --&gt; (_))&quot; [60, 0, 60] 60)<br/><br/>  notation NSA.approx (infixl &quot;@=&quot; 50)<br/>  notation NSLIMSEQ (&quot;((_)/ ----NS&gt; (_))&quot; [60, 60] 60)<br/>  notation NSLIM (&quot;((_)/ -- (_)/ --NS&gt; (_))&quot; [60, 0, 60] 60)<br/><br/>* The alternative notation &quot;∷&quot; for type and sort constraints has been<br/>removed: in LaTeX document output it looks the same as &quot;::&quot;.<br/>INCOMPATIBILITY, use plain &quot;::&quot; instead.<br/><br/>* Commands &#39;inductive&#39; and &#39;inductive_set&#39; work better when names for<br/>intro rules are omitted: the &quot;cases&quot; and &quot;induct&quot; rules no longer<br/>declare empty case_names, but no case_names at all. This allows to use<br/>numbered cases in proofs, without requiring method &quot;goal_cases&quot;.<br/><br/>* Inductive definitions (&#39;inductive&#39;, &#39;coinductive&#39;, etc.) expose<br/>low-level facts of the internal construction only if the option<br/>&quot;inductive_internals&quot; is enabled. This refers to the internal predicate<br/>definition and its monotonicity result. Rare INCOMPATIBILITY.<br/><br/>* Recursive function definitions (&#39;fun&#39;, &#39;function&#39;, &#39;partial_function&#39;)<br/>expose low-level facts of the internal construction only if the option<br/>&quot;function_internals&quot; is enabled. Its internal inductive definition is<br/>also subject to &quot;inductive_internals&quot;. Rare INCOMPATIBILITY.<br/><br/>* BNF datatypes (&#39;datatype&#39;, &#39;codatatype&#39;, etc.) expose low-level facts<br/>of the internal construction only if the option &quot;bnf_internals&quot; is<br/>enabled. This supersedes the former option &quot;bnf_note_all&quot;. Rare<br/>INCOMPATIBILITY.<br/><br/>* Combinator to represent case distinction on products is named<br/>&quot;case_prod&quot;, uniformly, discontinuing any input aliasses. Very popular<br/>theorem aliasses have been retained.<br/><br/>Consolidated facts:<br/>  PairE ~&gt; prod.exhaust<br/>  Pair_eq ~&gt; prod.inject<br/>  pair_collapse ~&gt; prod.collapse<br/>  Pair_fst_snd_eq ~&gt; prod_eq_iff<br/>  split_twice ~&gt; prod.case_distrib<br/>  split_weak_cong ~&gt; prod.case_cong_weak<br/>  split_split ~&gt; prod.split<br/>  split_split_asm ~&gt; prod.split_asm<br/>  splitI ~&gt; case_prodI<br/>  splitD ~&gt; case_prodD<br/>  splitI2 ~&gt; case_prodI2<br/>  splitI2&#39; ~&gt; case_prodI2&#39;<br/>  splitE ~&gt; case_prodE<br/>  splitE&#39; ~&gt; case_prodE&#39;<br/>  split_pair ~&gt; case_prod_Pair<br/>  split_eta ~&gt; case_prod_eta<br/>  split_comp ~&gt; case_prod_comp<br/>  mem_splitI ~&gt; mem_case_prodI<br/>  mem_splitI2 ~&gt; mem_case_prodI2<br/>  mem_splitE ~&gt; mem_case_prodE<br/>  The_split ~&gt; The_case_prod<br/>  cond_split_eta ~&gt; cond_case_prod_eta<br/>  Collect_split_in_rel_leE ~&gt; Collect_case_prod_in_rel_leE<br/>  Collect_split_in_rel_leI ~&gt; Collect_case_prod_in_rel_leI<br/>  in_rel_Collect_split_eq ~&gt; in_rel_Collect_case_prod_eq<br/>  Collect_split_Grp_eqD ~&gt; Collect_case_prod_Grp_eqD<br/>  Collect_split_Grp_inD ~&gt; Collect_case_prod_Grp_in<br/>  Domain_Collect_split ~&gt; Domain_Collect_case_prod<br/>  Image_Collect_split ~&gt; Image_Collect_case_prod<br/>  Range_Collect_split ~&gt; Range_Collect_case_prod<br/>  Eps_split ~&gt; Eps_case_prod<br/>  Eps_split_eq ~&gt; Eps_case_prod_eq<br/>  split_rsp ~&gt; case_prod_rsp<br/>  curry_split ~&gt; curry_case_prod<br/>  split_curry ~&gt; case_prod_curry<br/><br/>Changes in structure HOLogic:<br/>  split_const ~&gt; case_prod_const<br/>  mk_split ~&gt; mk_case_prod<br/>  mk_psplits ~&gt; mk_ptupleabs<br/>  strip_psplits ~&gt; strip_ptupleabs<br/><br/>INCOMPATIBILITY.<br/><br/>* The coercions to type &#39;real&#39; have been reorganised. The function<br/>&#39;real&#39; is no longer overloaded, but has type &#39;nat =&gt; real&#39; and<br/>abbreviates of_nat for that type. Also &#39;real_of_int :: int =&gt; real&#39;<br/>abbreviates of_int for that type. Other overloaded instances of &#39;real&#39;<br/>have been replaced by &#39;real_of_ereal&#39; and &#39;real_of_float&#39;.<br/><br/>Consolidated facts (among others):<br/>  real_of_nat_le_iff -&gt; of_nat_le_iff<br/>  real_of_nat_numeral of_nat_numeral<br/>  real_of_int_zero of_int_0<br/>  real_of_nat_zero of_nat_0<br/>  real_of_one of_int_1<br/>  real_of_int_add of_int_add<br/>  real_of_nat_add of_nat_add<br/>  real_of_int_diff of_int_diff<br/>  real_of_nat_diff of_nat_diff<br/>  floor_subtract floor_diff_of_int<br/>  real_of_int_inject of_int_eq_iff<br/>  real_of_int_gt_zero_cancel_iff of_int_0_less_iff<br/>  real_of_int_ge_zero_cancel_iff of_int_0_le_iff<br/>  real_of_nat_ge_zero of_nat_0_le_iff<br/>  real_of_int_ceiling_ge le_of_int_ceiling<br/>  ceiling_less_eq ceiling_less_iff<br/>  ceiling_le_eq ceiling_le_iff<br/>  less_floor_eq less_floor_iff<br/>  floor_less_eq floor_less_iff<br/>  floor_divide_eq_div floor_divide_of_int_eq<br/>  real_of_int_zero_cancel of_nat_eq_0_iff<br/>  ceiling_real_of_int ceiling_of_int<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory Map: lemma map_of_is_SomeD was a clone of map_of_SomeD and has<br/>been removed. INCOMPATIBILITY.<br/><br/>* Quickcheck setup for finite sets.<br/><br/>* Discontinued simp_legacy_precond. Potential INCOMPATIBILITY.<br/><br/>* Sledgehammer:<br/>  - The MaSh relevance filter has been sped up.<br/>  - Proof reconstruction has been improved, to minimize the incidence of<br/>    cases where Sledgehammer gives a proof that does not work.<br/>  - Auto Sledgehammer now minimizes and preplays the results.<br/>  - Handle Vampire 4.0 proof output without raising exception.<br/>  - Eliminated &quot;MASH&quot; environment variable. Use the &quot;MaSh&quot; option in<br/>    Isabelle/jEdit instead. INCOMPATIBILITY.<br/>  - Eliminated obsolete &quot;blocking&quot; option and related subcommands.<br/><br/>* Nitpick:<br/>  - Fixed soundness bug in translation of &quot;finite&quot; predicate.<br/>  - Fixed soundness bug in &quot;destroy_constrs&quot; optimization.<br/>  - Fixed soundness bug in translation of &quot;rat&quot; type.<br/>  - Removed &quot;check_potential&quot; and &quot;check_genuine&quot; options.<br/>  - Eliminated obsolete &quot;blocking&quot; option.<br/><br/>* (Co)datatype package:<br/>  - New commands &quot;lift_bnf&quot; and &quot;copy_bnf&quot; for lifting (copying) a BNF<br/>    structure on the raw type to an abstract type defined using typedef.<br/>  - Always generate &quot;case_transfer&quot; theorem.<br/>  - For mutual types, generate slightly stronger &quot;rel_induct&quot;,<br/>    &quot;rel_coinduct&quot;, and &quot;coinduct&quot; theorems. INCOMPATIBILITY.<br/>  - Allow discriminators and selectors with the same name as the type<br/>    being defined.<br/>  - Avoid various internal name clashes (e.g., &#39;datatype f = f&#39;).<br/><br/>* Transfer: new methods for interactive debugging of &#39;transfer&#39; and<br/>&#39;transfer_prover&#39;: &#39;transfer_start&#39;, &#39;transfer_step&#39;, &#39;transfer_end&#39;,<br/>&#39;transfer_prover_start&#39; and &#39;transfer_prover_end&#39;.<br/><br/>* New diagnostic command print_record for displaying record definitions.<br/><br/>* Division on integers is bootstrapped directly from division on<br/>naturals and uses generic numeral algorithm for computations. Slight<br/>INCOMPATIBILITY, simproc numeral_divmod replaces and generalizes former<br/>simprocs binary_int_div and binary_int_mod<br/><br/>* Tightened specification of class semiring_no_zero_divisors. Minor<br/>INCOMPATIBILITY.<br/><br/>* Class algebraic_semidom introduces common algebraic notions of<br/>integral (semi)domains, particularly units. Although logically subsumed<br/>by fields, is is not a super class of these in order not to burden<br/>fields with notions that are trivial there.<br/><br/>* Class normalization_semidom specifies canonical representants for<br/>equivalence classes of associated elements in an integral (semi)domain.<br/>This formalizes associated elements as well.<br/><br/>* Abstract specification of gcd/lcm operations in classes semiring_gcd,<br/>semiring_Gcd, semiring_Lcd. Minor INCOMPATIBILITY: facts gcd_nat.commute<br/>and gcd_int.commute are subsumed by gcd.commute, as well as<br/>gcd_nat.assoc and gcd_int.assoc by gcd.assoc.<br/><br/>* Former constants Fields.divide (_ / _) and Divides.div (_ div _) are<br/>logically unified to Rings.divide in syntactic type class Rings.divide,<br/>with infix syntax (_ div _). Infix syntax (_ / _) for field division is<br/>added later as abbreviation in class Fields.inverse. INCOMPATIBILITY,<br/>instantiations must refer to Rings.divide rather than the former<br/>separate constants, hence infix syntax (_ / _) is usually not available<br/>during instantiation.<br/><br/>* New cancellation simprocs for boolean algebras to cancel complementary<br/>terms for sup and inf. For example, &quot;sup x (sup y (- x))&quot; simplifies to<br/>&quot;top&quot;. INCOMPATIBILITY.<br/><br/>* Class uniform_space introduces uniform spaces btw topological spaces<br/>and metric spaces. Minor INCOMPATIBILITY: open_&lt;type&gt;_def needs to be<br/>introduced in the form of an uniformity. Some constants are more general<br/>now, it may be necessary to add type class constraints.<br/><br/>  open_real_def ↝ open_dist<br/>  open_complex_def ↝ open_dist<br/><br/>* Library/Monad_Syntax: notation uses symbols ⤜ and ⪢. INCOMPATIBILITY.<br/><br/>* Library/Multiset:<br/>  - Renamed multiset inclusion operators:<br/>      &lt; ~&gt; &lt;#<br/>      &gt; ~&gt; &gt;#<br/>      &lt;= ~&gt; &lt;=#<br/>      &gt;= ~&gt; &gt;=#<br/>      ≤ ~&gt; ≤#<br/>      ≥ ~&gt; ≥#<br/>    INCOMPATIBILITY.<br/>  - Added multiset inclusion operator syntax:<br/>      ⊂#<br/>      ⊆#<br/>      ⊃#<br/>      ⊇#<br/>  - &quot;&#39;a multiset&quot; is no longer an instance of the &quot;order&quot;,<br/>    &quot;ordered_ab_semigroup_add_imp_le&quot;, &quot;ordered_cancel_comm_monoid_diff&quot;,<br/>    &quot;semilattice_inf&quot;, and &quot;semilattice_sup&quot; type classes. The theorems<br/>    previously provided by these type classes (directly or indirectly)<br/>    are now available through the &quot;subset_mset&quot; interpretation<br/>    (e.g. add_mono ~&gt; subset_mset.add_mono).<br/>    INCOMPATIBILITY.<br/>  - Renamed conversions:<br/>      multiset_of ~&gt; mset<br/>      multiset_of_set ~&gt; mset_set<br/>      set_of ~&gt; set_mset<br/>    INCOMPATIBILITY<br/>  - Renamed lemmas:<br/>      mset_le_def ~&gt; subseteq_mset_def<br/>      mset_less_def ~&gt; subset_mset_def<br/>      less_eq_multiset.rep_eq ~&gt; subseteq_mset_def<br/>    INCOMPATIBILITY<br/>  - Removed lemmas generated by lift_definition:<br/>    less_eq_multiset.abs_eq, less_eq_multiset.rsp,<br/>    less_eq_multiset.transfer, less_eq_multiset_def<br/>    INCOMPATIBILITY<br/><br/>* Library/Omega_Words_Fun: Infinite words modeled as functions nat ⇒ &#39;a.<br/><br/>* Library/Bourbaki_Witt_Fixpoint: Added formalisation of the<br/>Bourbaki-Witt fixpoint theorem for increasing functions in<br/>chain-complete partial orders.<br/><br/>* Library/Old_Recdef: discontinued obsolete &#39;defer_recdef&#39; command.<br/>Minor INCOMPATIBILITY, use &#39;function&#39; instead.<br/><br/>* Library/Periodic_Fun: a locale that provides convenient lemmas for<br/>periodic functions.<br/><br/>* Library/Formal_Power_Series: proper definition of division (with<br/>remainder) for formal power series; instances for Euclidean Ring and<br/>GCD.<br/><br/>* HOL-Imperative_HOL: obsolete theory Legacy_Mrec has been removed.<br/><br/>* HOL-Statespace: command &#39;statespace&#39; uses mandatory qualifier for<br/>import of parent, as for general &#39;locale&#39; expressions. INCOMPATIBILITY,<br/>remove &#39;!&#39; and add &#39;?&#39; as required.<br/><br/>* HOL-Decision_Procs: The &quot;approximation&quot; method works with &quot;powr&quot;<br/>(exponentiation on real numbers) again.<br/><br/>* HOL-Multivariate_Analysis: theory Cauchy_Integral_Thm with Contour<br/>integrals (= complex path integrals), Cauchy&#39;s integral theorem, winding<br/>numbers and Cauchy&#39;s integral formula, Liouville theorem, Fundamental<br/>Theorem of Algebra. Ported from HOL Light.<br/><br/>* HOL-Multivariate_Analysis: topological concepts such as connected<br/>components, homotopic paths and the inside or outside of a set.<br/><br/>* HOL-Multivariate_Analysis: radius of convergence of power series and<br/>various summability tests; Harmonic numbers and the Euler–Mascheroni<br/>constant; the Generalised Binomial Theorem; the complex and real<br/>Gamma/log-Gamma/Digamma/ Polygamma functions and their most important<br/>properties.<br/><br/>* HOL-Probability: The central limit theorem based on Levy&#39;s uniqueness<br/>and continuity theorems, weak convergence, and characterisitc functions.<br/><br/>* HOL-Data_Structures: new and growing session of standard data<br/>structures.<br/><br/><br/>*** ML ***<br/><br/>* The following combinators for low-level profiling of the ML runtime<br/>system are available:<br/><br/>  profile_time          (*CPU time*)<br/>  profile_time_thread   (*CPU time on this thread*)<br/>  profile_allocations   (*overall heap allocations*)<br/><br/>* Antiquotation @{undefined} or ❖ inlines (raise Match).<br/><br/>* Antiquotation @{method NAME} inlines the (checked) name of the given<br/>Isar proof method.<br/><br/>* Pretty printing of Poly/ML compiler output in Isabelle has been<br/>improved: proper treatment of break offsets and blocks with consistent<br/>breaks.<br/><br/>* The auxiliary module Pure/display.ML has been eliminated. Its<br/>elementary thm print operations are now in Pure/more_thm.ML and thus<br/>called Thm.pretty_thm, Thm.string_of_thm etc. INCOMPATIBILITY.<br/><br/>* Simproc programming interfaces have been simplified:<br/>Simplifier.make_simproc and Simplifier.define_simproc supersede various<br/>forms of Simplifier.mk_simproc, Simplifier.simproc_global etc. Note that<br/>term patterns for the left-hand sides are specified with implicitly<br/>fixed variables, like top-level theorem statements. INCOMPATIBILITY.<br/><br/>* Instantiation rules have been re-organized as follows:<br/><br/>  Thm.instantiate  (*low-level instantiation with named arguments*)<br/>  Thm.instantiate&#39; (*version with positional arguments*)<br/><br/>  Drule.infer_instantiate  (*instantiation with type inference*)<br/>  Drule.infer_instantiate&#39;  (*version with positional arguments*)<br/><br/>The LHS only requires variable specifications, instead of full terms.<br/>Old cterm_instantiate is superseded by infer_instantiate.<br/>INCOMPATIBILITY, need to re-adjust some ML names and types accordingly.<br/><br/>* Old tactic shorthands atac, rtac, etac, dtac, ftac have been<br/>discontinued. INCOMPATIBILITY, use regular assume_tac, resolve_tac etc.<br/>instead (with proper context).<br/><br/>* Thm.instantiate (and derivatives) no longer require the LHS of the<br/>instantiation to be certified: plain variables are given directly.<br/><br/>* Subgoal.SUBPROOF and Subgoal.FOCUS combinators use anonymous<br/>quasi-bound variables (like the Simplifier), instead of accidentally<br/>named local fixes. This has the potential to improve stability of proof<br/>tools, but can also cause INCOMPATIBILITY for tools that don&#39;t observe<br/>the proof context discipline.<br/><br/>* Isar proof methods are based on a slightly more general type<br/>context_tactic, which allows to change the proof context dynamically<br/>(e.g. to update cases) and indicate explicit Seq.Error results. Former<br/>METHOD_CASES is superseded by CONTEXT_METHOD; further combinators are<br/>provided in src/Pure/Isar/method.ML for convenience. INCOMPATIBILITY.<br/><br/><br/>*** System ***<br/><br/>* Command-line tool &quot;isabelle console&quot; enables print mode &quot;ASCII&quot;.<br/><br/>* Command-line tool &quot;isabelle update_then&quot; expands old Isar command<br/>conflations:<br/><br/>    hence  ~&gt;  then have<br/>    thus   ~&gt;  then show<br/><br/>This syntax is more orthogonal and improves readability and<br/>maintainability of proofs.<br/><br/>* Global session timeout is multiplied by timeout_scale factor. This<br/>allows to adjust large-scale tests (e.g. AFP) to overall hardware<br/>performance.<br/><br/>* Property values in etc/symbols may contain spaces, if written with the<br/>replacement character &quot;␣&quot; (Unicode point 0x2324). For example:<br/><br/>    ⋆  code: 0x0022c6  group: operator  font: Deja␣Vu␣Sans␣Mono<br/><br/>* Java runtime environment for x86_64-windows allows to use larger heap<br/>space.<br/><br/>* Java runtime options are determined separately for 32bit vs. 64bit<br/>platforms as follows.<br/><br/>  - Isabelle desktop application: platform-specific files that are<br/>    associated with the main app bundle<br/><br/>  - isabelle jedit: settings<br/>    JEDIT_JAVA_SYSTEM_OPTIONS<br/>    JEDIT_JAVA_OPTIONS32 vs. JEDIT_JAVA_OPTIONS64<br/><br/>  - isabelle build: settings<br/>    ISABELLE_BUILD_JAVA_OPTIONS32 vs. ISABELLE_BUILD_JAVA_OPTIONS64<br/><br/>* Bash shell function &quot;jvmpath&quot; has been renamed to &quot;platform_path&quot;: it<br/>is relevant both for Poly/ML and JVM processes.<br/><br/>* Poly/ML default platform architecture may be changed from 32bit to<br/>64bit via system option ML_system_64. A system restart (and rebuild) is<br/>required after change.<br/><br/>* Poly/ML 5.6 runs natively on x86-windows and x86_64-windows, which<br/>both allow larger heap space than former x86-cygwin.<br/><br/>* Heap images are 10-15% smaller due to less wasteful persistent theory<br/>content (using ML type theory_id instead of theory);<br/><br/><br/><br/>New in Isabelle2015 (May 2015)<br/>------------------------------<br/><br/>*** General ***<br/><br/>* Local theory specification commands may have a &#39;private&#39; or<br/>&#39;qualified&#39; modifier to restrict name space accesses to the local scope,<br/>as provided by some &quot;context begin ... end&quot; block. For example:<br/><br/>  context<br/>  begin<br/><br/>  private definition ...<br/>  private lemma ...<br/><br/>  qualified definition ...<br/>  qualified lemma ...<br/><br/>  lemma ...<br/>  theorem ...<br/><br/>  end<br/><br/>* Command &#39;experiment&#39; opens an anonymous locale context with private<br/>naming policy.<br/><br/>* Command &#39;notepad&#39; requires proper nesting of begin/end and its proof<br/>structure in the body: &#39;oops&#39; is no longer supported here. Minor<br/>INCOMPATIBILITY, use &#39;sorry&#39; instead.<br/><br/>* Command &#39;named_theorems&#39; declares a dynamic fact within the context,<br/>together with an attribute to maintain the content incrementally. This<br/>supersedes functor Named_Thms in Isabelle/ML, but with a subtle change<br/>of semantics due to external visual order vs. internal reverse order.<br/><br/>* &#39;find_theorems&#39;: search patterns which are abstractions are<br/>schematically expanded before search. Search results match the naive<br/>expectation more closely, particularly wrt. abbreviations.<br/>INCOMPATIBILITY.<br/><br/>* Commands &#39;method_setup&#39; and &#39;attribute_setup&#39; now work within a local<br/>theory context.<br/><br/>* Outer syntax commands are managed authentically within the theory<br/>context, without implicit global state. Potential for accidental<br/>INCOMPATIBILITY, make sure that required theories are really imported.<br/><br/>* Historical command-line terminator &quot;;&quot; is no longer accepted (and<br/>already used differently in Isar). Minor INCOMPATIBILITY, use &quot;isabelle<br/>update_semicolons&quot; to remove obsolete semicolons from old theory<br/>sources.<br/><br/>* Structural composition of proof methods (meth1; meth2) in Isar<br/>corresponds to (tac1 THEN_ALL_NEW tac2) in ML.<br/><br/>* The Eisbach proof method language allows to define new proof methods<br/>by combining existing ones with their usual syntax. The &quot;match&quot; proof<br/>method provides basic fact/term matching in addition to<br/>premise/conclusion matching through Subgoal.focus, and binds fact names<br/>from matches as well as term patterns within matches. The Isabelle<br/>documentation provides an entry &quot;eisbach&quot; for the Eisbach User Manual.<br/>Sources and various examples are in ~~/src/HOL/Eisbach/.<br/><br/><br/>*** Prover IDE -- Isabelle/Scala/jEdit ***<br/><br/>* Improved folding mode &quot;isabelle&quot; based on Isar syntax. Alternatively,<br/>the &quot;sidekick&quot; mode may be used for document structure.<br/><br/>* Extended bracket matching based on Isar language structure. System<br/>option jedit_structure_limit determines maximum number of lines to scan<br/>in the buffer.<br/><br/>* Support for BibTeX files: context menu, context-sensitive token<br/>marker, SideKick parser.<br/><br/>* Document antiquotation @{cite} provides formal markup, which is<br/>interpreted semi-formally based on .bib files that happen to be open in<br/>the editor (hyperlinks, completion etc.).<br/><br/>* Less waste of vertical space via negative line spacing (see Global<br/>Options / Text Area).<br/><br/>* Improved graphview panel with optional output of PNG or PDF, for<br/>display of &#39;thy_deps&#39;, &#39;class_deps&#39; etc.<br/><br/>* The commands &#39;thy_deps&#39; and &#39;class_deps&#39; allow optional bounds to<br/>restrict the visualized hierarchy.<br/><br/>* Improved scheduling for asynchronous print commands (e.g. provers<br/>managed by the Sledgehammer panel) wrt. ongoing document processing.<br/><br/><br/>*** Document preparation ***<br/><br/>* Document markup commands &#39;chapter&#39;, &#39;section&#39;, &#39;subsection&#39;,<br/>&#39;subsubsection&#39;, &#39;text&#39;, &#39;txt&#39;, &#39;text_raw&#39; work uniformly in any<br/>context, even before the initial &#39;theory&#39; command. Obsolete proof<br/>commands &#39;sect&#39;, &#39;subsect&#39;, &#39;subsubsect&#39;, &#39;txt_raw&#39; have been<br/>discontinued, use &#39;section&#39;, &#39;subsection&#39;, &#39;subsubsection&#39;, &#39;text_raw&#39;<br/>instead. The old &#39;header&#39; command is still retained for some time, but<br/>should be replaced by &#39;chapter&#39;, &#39;section&#39; etc. (using &quot;isabelle<br/>update_header&quot;). Minor INCOMPATIBILITY.<br/><br/>* Official support for &quot;tt&quot; style variants, via \isatt{...} or<br/>\begin{isabellett}...\end{isabellett}. The somewhat fragile \verb or<br/>verbatim environment of LaTeX is no longer used. This allows @{ML} etc.<br/>as argument to other macros (such as footnotes).<br/><br/>* Document antiquotation @{verbatim} prints ASCII text literally in &quot;tt&quot;<br/>style.<br/><br/>* Discontinued obsolete option &quot;document_graph&quot;: session_graph.pdf is<br/>produced unconditionally for HTML browser_info and PDF-LaTeX document.<br/><br/>* Diagnostic commands and document markup commands within a proof do not<br/>affect the command tag for output. Thus commands like &#39;thm&#39; are subject<br/>to proof document structure, and no longer &quot;stick out&quot; accidentally.<br/>Commands &#39;text&#39; and &#39;txt&#39; merely differ in the LaTeX style, not their<br/>tags. Potential INCOMPATIBILITY in exotic situations.<br/><br/>* System option &quot;pretty_margin&quot; is superseded by &quot;thy_output_margin&quot;,<br/>which is also accessible via document antiquotation option &quot;margin&quot;.<br/>Only the margin for document output may be changed, but not the global<br/>pretty printing: that is 76 for plain console output, and adapted<br/>dynamically in GUI front-ends. Implementations of document<br/>antiquotations need to observe the margin explicitly according to<br/>Thy_Output.string_of_margin. Minor INCOMPATIBILITY.<br/><br/>* Specification of &#39;document_files&#39; in the session ROOT file is<br/>mandatory for document preparation. The legacy mode with implicit<br/>copying of the document/ directory is no longer supported. Minor<br/>INCOMPATIBILITY.<br/><br/><br/>*** Pure ***<br/><br/>* Proof methods with explicit instantiation (&quot;rule_tac&quot;, &quot;subgoal_tac&quot;<br/>etc.) allow an optional context of local variables (&#39;for&#39; declaration):<br/>these variables become schematic in the instantiated theorem; this<br/>behaviour is analogous to &#39;for&#39; in attributes &quot;where&quot; and &quot;of&quot;.<br/>Configuration option rule_insts_schematic (default false) controls use<br/>of schematic variables outside the context. Minor INCOMPATIBILITY,<br/>declare rule_insts_schematic = true temporarily and update to use local<br/>variable declarations or dummy patterns instead.<br/><br/>* Explicit instantiation via attributes &quot;where&quot;, &quot;of&quot;, and proof methods<br/>&quot;rule_tac&quot; with derivatives like &quot;subgoal_tac&quot; etc. admit dummy patterns<br/>(&quot;_&quot;) that stand for anonymous local variables.<br/><br/>* Generated schematic variables in standard format of exported facts are<br/>incremented to avoid material in the proof context. Rare<br/>INCOMPATIBILITY, explicit instantiation sometimes needs to refer to<br/>different index.<br/><br/>* Lexical separation of signed and unsigned numerals: categories &quot;num&quot;<br/>and &quot;float&quot; are unsigned. INCOMPATIBILITY: subtle change in precedence<br/>of numeral signs, particularly in expressions involving infix syntax<br/>like &quot;(- 1) ^ n&quot;.<br/><br/>* Old inner token category &quot;xnum&quot; has been discontinued.  Potential<br/>INCOMPATIBILITY for exotic syntax: may use mixfix grammar with &quot;num&quot;<br/>token category instead.<br/><br/><br/>*** HOL ***<br/><br/>* New (co)datatype package:<br/>  - The &#39;datatype_new&#39; command has been renamed &#39;datatype&#39;. The old<br/>    command of that name is now called &#39;old_datatype&#39; and is provided<br/>    by &quot;~~/src/HOL/Library/Old_Datatype.thy&quot;. See<br/>    &#39;isabelle doc datatypes&#39; for information on porting.<br/>    INCOMPATIBILITY.<br/>  - Renamed theorems:<br/>      disc_corec ~&gt; corec_disc<br/>      disc_corec_iff ~&gt; corec_disc_iff<br/>      disc_exclude ~&gt; distinct_disc<br/>      disc_exhaust ~&gt; exhaust_disc<br/>      disc_map_iff ~&gt; map_disc_iff<br/>      sel_corec ~&gt; corec_sel<br/>      sel_exhaust ~&gt; exhaust_sel<br/>      sel_map ~&gt; map_sel<br/>      sel_set ~&gt; set_sel<br/>      sel_split ~&gt; split_sel<br/>      sel_split_asm ~&gt; split_sel_asm<br/>      strong_coinduct ~&gt; coinduct_strong<br/>      weak_case_cong ~&gt; case_cong_weak<br/>    INCOMPATIBILITY.<br/>  - The &quot;no_code&quot; option to &quot;free_constructors&quot;, &quot;datatype_new&quot;, and<br/>    &quot;codatatype&quot; has been renamed &quot;plugins del: code&quot;.<br/>    INCOMPATIBILITY.<br/>  - The rules &quot;set_empty&quot; have been removed. They are easy<br/>    consequences of other set rules &quot;by auto&quot;.<br/>    INCOMPATIBILITY.<br/>  - The rule &quot;set_cases&quot; is now registered with the &quot;[cases set]&quot;<br/>    attribute. This can influence the behavior of the &quot;cases&quot; proof<br/>    method when more than one case rule is applicable (e.g., an<br/>    assumption is of the form &quot;w : set ws&quot; and the method &quot;cases w&quot;<br/>    is invoked). The solution is to specify the case rule explicitly<br/>    (e.g. &quot;cases w rule: widget.exhaust&quot;).<br/>    INCOMPATIBILITY.<br/>  - Renamed theories:<br/>      BNF_Comp ~&gt; BNF_Composition<br/>      BNF_FP_Base ~&gt; BNF_Fixpoint_Base<br/>      BNF_GFP ~&gt; BNF_Greatest_Fixpoint<br/>      BNF_LFP ~&gt; BNF_Least_Fixpoint<br/>      BNF_Constructions_on_Wellorders ~&gt; BNF_Wellorder_Constructions<br/>      Cardinals/Constructions_on_Wellorders ~&gt; Cardinals/Wellorder_Constructions<br/>    INCOMPATIBILITY.<br/>  - Lifting and Transfer setup for basic HOL types sum and prod (also<br/>    option) is now performed by the BNF package. Theories Lifting_Sum,<br/>    Lifting_Product and Lifting_Option from Main became obsolete and<br/>    were removed. Changed definitions of the relators rel_prod and<br/>    rel_sum (using inductive).<br/>    INCOMPATIBILITY: use rel_prod.simps and rel_sum.simps instead<br/>    of rel_prod_def and rel_sum_def.<br/>    Minor INCOMPATIBILITY: (rarely used by name) transfer theorem names<br/>    changed (e.g. map_prod_transfer ~&gt; prod.map_transfer).<br/>  - Parametricity theorems for map functions, relators, set functions,<br/>    constructors, case combinators, discriminators, selectors and<br/>    (co)recursors are automatically proved and registered as transfer<br/>    rules.<br/><br/>* Old datatype package:<br/>  - The old &#39;datatype&#39; command has been renamed &#39;old_datatype&#39;, and<br/>    &#39;rep_datatype&#39; has been renamed &#39;old_rep_datatype&#39;. They are<br/>    provided by &quot;~~/src/HOL/Library/Old_Datatype.thy&quot;. See<br/>    &#39;isabelle doc datatypes&#39; for information on porting.<br/>    INCOMPATIBILITY.<br/>  - Renamed theorems:<br/>      weak_case_cong ~&gt; case_cong_weak<br/>    INCOMPATIBILITY.<br/>  - Renamed theory:<br/>      ~~/src/HOL/Datatype.thy ~&gt; ~~/src/HOL/Library/Old_Datatype.thy<br/>    INCOMPATIBILITY.<br/><br/>* Nitpick:<br/>  - Fixed soundness bug related to the strict and non-strict subset<br/>    operations.<br/><br/>* Sledgehammer:<br/>  - CVC4 is now included with Isabelle instead of CVC3 and run by<br/>    default.<br/>  - Z3 is now always enabled by default, now that it is fully open<br/>    source. The &quot;z3_non_commercial&quot; option is discontinued.<br/>  - Minimization is now always enabled by default.<br/>    Removed sub-command:<br/>      min<br/>  - Proof reconstruction, both one-liners and Isar, has been<br/>    dramatically improved.<br/>  - Improved support for CVC4 and veriT.<br/><br/>* Old and new SMT modules:<br/>  - The old &#39;smt&#39; method has been renamed &#39;old_smt&#39; and moved to<br/>    &#39;src/HOL/Library/Old_SMT.thy&#39;. It is provided for compatibility,<br/>    until applications have been ported to use the new &#39;smt&#39; method. For<br/>    the method to work, an older version of Z3 (e.g. Z3 3.2 or 4.0) must<br/>    be installed, and the environment variable &quot;OLD_Z3_SOLVER&quot; must<br/>    point to it.<br/>    INCOMPATIBILITY.<br/>  - The &#39;smt2&#39; method has been renamed &#39;smt&#39;.<br/>    INCOMPATIBILITY.<br/>  - New option &#39;smt_reconstruction_step_timeout&#39; to limit the<br/>    reconstruction time of Z3 proof steps in the new &#39;smt&#39; method.<br/>  - New option &#39;smt_statistics&#39; to display statistics of the new &#39;smt&#39;<br/>    method, especially runtime statistics of Z3 proof reconstruction.<br/><br/>* Lifting: command &#39;lift_definition&#39; allows to execute lifted constants<br/>that have as a return type a datatype containing a subtype. This<br/>overcomes long-time limitations in the area of code generation and<br/>lifting, and avoids tedious workarounds.<br/><br/>* Command and antiquotation &quot;value&quot; provide different evaluation slots<br/>(again), where the previous strategy (NBE after ML) serves as default.<br/>Minor INCOMPATIBILITY.<br/><br/>* Add NO_MATCH-simproc, allows to check for syntactic non-equality.<br/><br/>* field_simps: Use NO_MATCH-simproc for distribution rules, to avoid<br/>non-termination in case of distributing a division. With this change<br/>field_simps is in some cases slightly less powerful, if it fails try to<br/>add algebra_simps, or use divide_simps. Minor INCOMPATIBILITY.<br/><br/>* Separate class no_zero_divisors has been given up in favour of fully<br/>algebraic semiring_no_zero_divisors. INCOMPATIBILITY.<br/><br/>* Class linordered_semidom really requires no zero divisors.<br/>INCOMPATIBILITY.<br/><br/>* Classes division_ring, field and linordered_field always demand<br/>&quot;inverse 0 = 0&quot;. Given up separate classes division_ring_inverse_zero,<br/>field_inverse_zero and linordered_field_inverse_zero. INCOMPATIBILITY.<br/><br/>* Classes cancel_ab_semigroup_add / cancel_monoid_add specify explicit<br/>additive inverse operation. INCOMPATIBILITY.<br/><br/>* Complex powers and square roots. The functions &quot;ln&quot; and &quot;powr&quot; are now<br/>overloaded for types real and complex, and 0 powr y = 0 by definition.<br/>INCOMPATIBILITY: type constraints may be necessary.<br/><br/>* The functions &quot;sin&quot; and &quot;cos&quot; are now defined for any type of sort<br/>&quot;{real_normed_algebra_1,banach}&quot; type, so in particular on &quot;real&quot; and<br/>&quot;complex&quot; uniformly. Minor INCOMPATIBILITY: type constraints may be<br/>needed.<br/><br/>* New library of properties of the complex transcendental functions sin,<br/>cos, tan, exp, Ln, Arctan, Arcsin, Arccos. Ported from HOL Light.<br/><br/>* The factorial function, &quot;fact&quot;, now has type &quot;nat =&gt; &#39;a&quot; (of a sort<br/>that admits numeric types including nat, int, real and complex.<br/>INCOMPATIBILITY: an expression such as &quot;fact 3 = 6&quot; may require a type<br/>constraint, and the combination &quot;real (fact k)&quot; is likely to be<br/>unsatisfactory. If a type conversion is still necessary, then use<br/>&quot;of_nat (fact k)&quot; or &quot;real_of_nat (fact k)&quot;.<br/><br/>* Removed functions &quot;natfloor&quot; and &quot;natceiling&quot;, use &quot;nat o floor&quot; and<br/>&quot;nat o ceiling&quot; instead. A few of the lemmas have been retained and<br/>adapted: in their names &quot;natfloor&quot;/&quot;natceiling&quot; has been replaced by<br/>&quot;nat_floor&quot;/&quot;nat_ceiling&quot;.<br/><br/>* Qualified some duplicated fact names required for boostrapping the<br/>type class hierarchy:<br/>  ab_add_uminus_conv_diff ~&gt; diff_conv_add_uminus<br/>  field_inverse_zero ~&gt; inverse_zero<br/>  field_divide_inverse ~&gt; divide_inverse<br/>  field_inverse ~&gt; left_inverse<br/>Minor INCOMPATIBILITY.<br/><br/>* Eliminated fact duplicates:<br/>  mult_less_imp_less_right ~&gt; mult_right_less_imp_less<br/>  mult_less_imp_less_left ~&gt; mult_left_less_imp_less<br/>Minor INCOMPATIBILITY.<br/><br/>* Fact consolidation: even_less_0_iff is subsumed by<br/>double_add_less_zero_iff_single_add_less_zero (simp by default anyway).<br/><br/>* Generalized and consolidated some theorems concerning divsibility:<br/>  dvd_reduce ~&gt; dvd_add_triv_right_iff<br/>  dvd_plus_eq_right ~&gt; dvd_add_right_iff<br/>  dvd_plus_eq_left ~&gt; dvd_add_left_iff<br/>Minor INCOMPATIBILITY.<br/><br/>* &quot;even&quot; and &quot;odd&quot; are mere abbreviations for &quot;2 dvd _&quot; and &quot;~ 2 dvd _&quot;<br/>and part of theory Main.<br/>  even_def ~&gt; even_iff_mod_2_eq_zero<br/>INCOMPATIBILITY.<br/><br/>* Lemma name consolidation: divide_Numeral1 ~&gt; divide_numeral_1. Minor<br/>INCOMPATIBILITY.<br/><br/>* Bootstrap of listsum as special case of abstract product over lists.<br/>Fact rename:<br/>    listsum_def ~&gt; listsum.eq_foldr<br/>INCOMPATIBILITY.<br/><br/>* Product over lists via constant &quot;listprod&quot;.<br/><br/>* Theory List: renamed drop_Suc_conv_tl and nth_drop&#39; to<br/>Cons_nth_drop_Suc.<br/><br/>* New infrastructure for compiling, running, evaluating and testing<br/>generated code in target languages in HOL/Library/Code_Test. See<br/>HOL/Codegenerator_Test/Code_Test* for examples.<br/><br/>* Library/Multiset:<br/>  - Introduced &quot;replicate_mset&quot; operation.<br/>  - Introduced alternative characterizations of the multiset ordering in<br/>    &quot;Library/Multiset_Order&quot;.<br/>  - Renamed multiset ordering:<br/>      &lt;# ~&gt; #&lt;#<br/>      &lt;=# ~&gt; #&lt;=#<br/>      ⊂# ~&gt; #⊂#<br/>      ⊆# ~&gt; #⊆#<br/>    INCOMPATIBILITY.<br/>  - Introduced abbreviations for ill-named multiset operations:<br/>      &lt;#, ⊂# abbreviate &lt; (strict subset)<br/>      &lt;=#, ≤#, ⊆# abbreviate &lt;= (subset or equal)<br/>    INCOMPATIBILITY.<br/>  - Renamed<br/>      in_multiset_of ~&gt; in_multiset_in_set<br/>      Multiset.fold ~&gt; fold_mset<br/>      Multiset.filter ~&gt; filter_mset<br/>    INCOMPATIBILITY.<br/>  - Removed mcard, is equal to size.<br/>  - Added attributes:<br/>      image_mset.id [simp]<br/>      image_mset_id [simp]<br/>      elem_multiset_of_set [simp, intro]<br/>      comp_fun_commute_plus_mset [simp]<br/>      comp_fun_commute.fold_mset_insert [OF comp_fun_commute_plus_mset, simp]<br/>      in_mset_fold_plus_iff [iff]<br/>      set_of_Union_mset [simp]<br/>      in_Union_mset_iff [iff]<br/>    INCOMPATIBILITY.<br/><br/>* Library/Sum_of_Squares: simplified and improved &quot;sos&quot; method. Always<br/>use local CSDP executable, which is much faster than the NEOS server.<br/>The &quot;sos_cert&quot; functionality is invoked as &quot;sos&quot; with additional<br/>argument. Minor INCOMPATIBILITY.<br/><br/>* HOL-Decision_Procs: New counterexample generator quickcheck<br/>[approximation] for inequalities of transcendental functions. Uses<br/>hardware floating point arithmetic to randomly discover potential<br/>counterexamples. Counterexamples are certified with the &quot;approximation&quot;<br/>method. See HOL/Decision_Procs/ex/Approximation_Quickcheck_Ex.thy for<br/>examples.<br/><br/>* HOL-Probability: Reworked measurability prover<br/>  - applies destructor rules repeatedly<br/>  - removed application splitting (replaced by destructor rule)<br/>  - added congruence rules to rewrite measure spaces under the sets<br/>    projection<br/><br/>* New proof method &quot;rewrite&quot; (in theory ~~/src/HOL/Library/Rewrite) for<br/>single-step rewriting with subterm selection based on patterns.<br/><br/><br/>*** ML ***<br/><br/>* Subtle change of name space policy: undeclared entries are now<br/>considered inaccessible, instead of accessible via the fully-qualified<br/>internal name. This mainly affects Name_Space.intern (and derivatives),<br/>which may produce an unexpected Long_Name.hidden prefix. Note that<br/>contemporary applications use the strict Name_Space.check (and<br/>derivatives) instead, which is not affected by the change. Potential<br/>INCOMPATIBILITY in rare applications of Name_Space.intern.<br/><br/>* Subtle change of error semantics of Toplevel.proof_of: regular user<br/>ERROR instead of internal Toplevel.UNDEF.<br/><br/>* Basic combinators map, fold, fold_map, split_list, apply are available<br/>as parameterized antiquotations, e.g. @{map 4} for lists of quadruples.<br/><br/>* Renamed &quot;pairself&quot; to &quot;apply2&quot;, in accordance to @{apply 2}.<br/>INCOMPATIBILITY.<br/><br/>* Former combinators NAMED_CRITICAL and CRITICAL for central critical<br/>sections have been discontinued, in favour of the more elementary<br/>Multithreading.synchronized and its high-level derivative<br/>Synchronized.var (which is usually sufficient in applications). Subtle<br/>INCOMPATIBILITY: synchronized access needs to be atomic and cannot be<br/>nested.<br/><br/>* Synchronized.value (ML) is actually synchronized (as in Scala): subtle<br/>change of semantics with minimal potential for INCOMPATIBILITY.<br/><br/>* The main operations to certify logical entities are Thm.ctyp_of and<br/>Thm.cterm_of with a local context; old-style global theory variants are<br/>available as Thm.global_ctyp_of and Thm.global_cterm_of.<br/>INCOMPATIBILITY.<br/><br/>* Elementary operations in module Thm are no longer pervasive.<br/>INCOMPATIBILITY, need to use qualified Thm.prop_of, Thm.cterm_of,<br/>Thm.term_of etc.<br/><br/>* Proper context for various elementary tactics: assume_tac,<br/>resolve_tac, eresolve_tac, dresolve_tac, forward_tac, match_tac,<br/>compose_tac, Splitter.split_tac etc. INCOMPATIBILITY.<br/><br/>* Tactical PARALLEL_ALLGOALS is the most common way to refer to<br/>PARALLEL_GOALS.<br/><br/>* Goal.prove_multi is superseded by the fully general Goal.prove_common,<br/>which also allows to specify a fork priority.<br/><br/>* Antiquotation @{command_spec &quot;COMMAND&quot;} is superseded by<br/>@{command_keyword COMMAND} (usually without quotes and with PIDE<br/>markup). Minor INCOMPATIBILITY.<br/><br/>* Cartouches within ML sources are turned into values of type<br/>Input.source (with formal position information).<br/><br/><br/>*** System ***<br/><br/>* The Isabelle tool &quot;update_cartouches&quot; changes theory files to use<br/>cartouches instead of old-style {* verbatim *} or `alt_string` tokens.<br/><br/>* The Isabelle tool &quot;build&quot; provides new options -X, -k, -x.<br/><br/>* Discontinued old-fashioned &quot;codegen&quot; tool. Code generation can always<br/>be externally triggered using an appropriate ROOT file plus a<br/>corresponding theory. Parametrization is possible using environment<br/>variables, or ML snippets in the most extreme cases. Minor<br/>INCOMPATIBILITY.<br/><br/>* JVM system property &quot;isabelle.threads&quot; determines size of Scala thread<br/>pool, like Isabelle system option &quot;threads&quot; for ML.<br/><br/>* JVM system property &quot;isabelle.laf&quot; determines the default Swing<br/>look-and-feel, via internal class name or symbolic name as in the jEdit<br/>menu Global Options / Appearance.<br/><br/>* Support for Proof General and Isar TTY loop has been discontinued.<br/>Minor INCOMPATIBILITY, use standard PIDE infrastructure instead.<br/><br/><br/><br/>New in Isabelle2014 (August 2014)<br/>---------------------------------<br/><br/>*** General ***<br/><br/>* Support for official Standard ML within the Isabelle context.<br/>Command &#39;SML_file&#39; reads and evaluates the given Standard ML file.<br/>Toplevel bindings are stored within the theory context; the initial<br/>environment is restricted to the Standard ML implementation of<br/>Poly/ML, without the add-ons of Isabelle/ML.  Commands &#39;SML_import&#39;<br/>and &#39;SML_export&#39; allow to exchange toplevel bindings between the two<br/>separate environments.  See also ~~/src/Tools/SML/Examples.thy for<br/>some examples.<br/><br/>* Standard tactics and proof methods such as &quot;clarsimp&quot;, &quot;auto&quot; and<br/>&quot;safe&quot; now preserve equality hypotheses &quot;x = expr&quot; where x is a free<br/>variable.  Locale assumptions and chained facts containing &quot;x&quot;<br/>continue to be useful.  The new method &quot;hypsubst_thin&quot; and the<br/>configuration option &quot;hypsubst_thin&quot; (within the attribute name space)<br/>restore the previous behavior.  INCOMPATIBILITY, especially where<br/>induction is done after these methods or when the names of free and<br/>bound variables clash.  As first approximation, old proofs may be<br/>repaired by &quot;using [[hypsubst_thin = true]]&quot; in the critical spot.<br/><br/>* More static checking of proof methods, which allows the system to<br/>form a closure over the concrete syntax.  Method arguments should be<br/>processed in the original proof context as far as possible, before<br/>operating on the goal state.  In any case, the standard discipline for<br/>subgoal-addressing needs to be observed: no subgoals or a subgoal<br/>number that is out of range produces an empty result sequence, not an<br/>exception.  Potential INCOMPATIBILITY for non-conformant tactical<br/>proof tools.<br/><br/>* Lexical syntax (inner and outer) supports text cartouches with<br/>arbitrary nesting, and without escapes of quotes etc.  The Prover IDE<br/>supports input via ` (backquote).<br/><br/>* The outer syntax categories &quot;text&quot; (for formal comments and document<br/>markup commands) and &quot;altstring&quot; (for literal fact references) allow<br/>cartouches as well, in addition to the traditional mix of quotations.<br/><br/>* Syntax of document antiquotation @{rail} now uses ⏎ instead<br/>of &quot;\\&quot;, to avoid the optical illusion of escaped backslash within<br/>string token.  General renovation of its syntax using text cartouches.<br/>Minor INCOMPATIBILITY.<br/><br/>* Discontinued legacy_isub_isup, which was a temporary workaround for<br/>Isabelle/ML in Isabelle2013-1.  The prover process no longer accepts<br/>old identifier syntax with \&lt;^isub&gt; or \&lt;^isup&gt;.  Potential<br/>INCOMPATIBILITY.<br/><br/>* Document antiquotation @{url} produces markup for the given URL,<br/>which results in an active hyperlink within the text.<br/><br/>* Document antiquotation @{file_unchecked} is like @{file}, but does<br/>not check existence within the file-system.<br/><br/>* Updated and extended manuals: codegen, datatypes, implementation,<br/>isar-ref, jedit, system.<br/><br/><br/>*** Prover IDE -- Isabelle/Scala/jEdit ***<br/><br/>* Improved Document panel: simplified interaction where every single<br/>mouse click (re)opens document via desktop environment or as jEdit<br/>buffer.<br/><br/>* Support for Navigator plugin (with toolbar buttons), with connection<br/>to PIDE hyperlinks.<br/><br/>* Auxiliary files (&#39;ML_file&#39; etc.) are managed by the Prover IDE.<br/>Open text buffers take precedence over copies within the file-system.<br/><br/>* Improved support for Isabelle/ML, with jEdit mode &quot;isabelle-ml&quot; for<br/>auxiliary ML files.<br/><br/>* Improved syntactic and semantic completion mechanism, with simple<br/>templates, completion language context, name-space completion,<br/>file-name completion, spell-checker completion.<br/><br/>* Refined GUI popup for completion: more robust key/mouse event<br/>handling and propagation to enclosing text area -- avoid loosing<br/>keystrokes with slow / remote graphics displays.<br/><br/>* Completion popup supports both ENTER and TAB (default) to select an<br/>item, depending on Isabelle options.<br/><br/>* Refined insertion of completion items wrt. jEdit text: multiple<br/>selections, rectangular selections, rectangular selection as &quot;tall<br/>caret&quot;.<br/><br/>* Integrated spell-checker for document text, comments etc. with<br/>completion popup and context-menu.<br/><br/>* More general &quot;Query&quot; panel supersedes &quot;Find&quot; panel, with GUI access<br/>to commands &#39;find_theorems&#39; and &#39;find_consts&#39;, as well as print<br/>operations for the context.  Minor incompatibility in keyboard<br/>shortcuts etc.: replace action isabelle-find by isabelle-query.<br/><br/>* Search field for all output panels (&quot;Output&quot;, &quot;Query&quot;, &quot;Info&quot; etc.)<br/>to highlight text via regular expression.<br/><br/>* Option &quot;jedit_print_mode&quot; (see also &quot;Plugin Options / Isabelle /<br/>General&quot;) allows to specify additional print modes for the prover<br/>process, without requiring old-fashioned command-line invocation of<br/>&quot;isabelle jedit -m MODE&quot;.<br/><br/>* More support for remote files (e.g. http) using standard Java<br/>networking operations instead of jEdit virtual file-systems.<br/><br/>* Empty editors buffers that are no longer required (e.g.\ via theory<br/>imports) are automatically removed from the document model.<br/><br/>* Improved monitor panel.<br/><br/>* Improved Console/Scala plugin: more uniform scala.Console output,<br/>more robust treatment of threads and interrupts.<br/><br/>* Improved management of dockable windows: clarified keyboard focus<br/>and window placement wrt. main editor view; optional menu item to<br/>&quot;Detach&quot; a copy where this makes sense.<br/><br/>* New Simplifier Trace panel provides an interactive view of the<br/>simplification process, enabled by the &quot;simp_trace_new&quot; attribute<br/>within the context.<br/><br/><br/>*** Pure ***<br/><br/>* Low-level type-class commands &#39;classes&#39;, &#39;classrel&#39;, &#39;arities&#39; have<br/>been discontinued to avoid the danger of non-trivial axiomatization<br/>that is not immediately visible.  INCOMPATIBILITY, use regular<br/>&#39;instance&#39; command with proof.  The required OFCLASS(...) theorem<br/>might be postulated via &#39;axiomatization&#39; beforehand, or the proof<br/>finished trivially if the underlying class definition is made vacuous<br/>(without any assumptions).  See also Isabelle/ML operations<br/>Axclass.class_axiomatization, Axclass.classrel_axiomatization,<br/>Axclass.arity_axiomatization.<br/><br/>* Basic constants of Pure use more conventional names and are always<br/>qualified.  Rare INCOMPATIBILITY, but with potentially serious<br/>consequences, notably for tools in Isabelle/ML.  The following<br/>renaming needs to be applied:<br/><br/>  ==             ~&gt;  Pure.eq<br/>  ==&gt;            ~&gt;  Pure.imp<br/>  all            ~&gt;  Pure.all<br/>  TYPE           ~&gt;  Pure.type<br/>  dummy_pattern  ~&gt;  Pure.dummy_pattern<br/><br/>Systematic porting works by using the following theory setup on a<br/>*previous* Isabelle version to introduce the new name accesses for the<br/>old constants:<br/><br/>setup {*<br/>  fn thy =&gt; thy<br/>    |&gt; Sign.root_path<br/>    |&gt; Sign.const_alias (Binding.qualify true &quot;Pure&quot; @{binding eq}) &quot;==&quot;<br/>    |&gt; Sign.const_alias (Binding.qualify true &quot;Pure&quot; @{binding imp}) &quot;==&gt;&quot;<br/>    |&gt; Sign.const_alias (Binding.qualify true &quot;Pure&quot; @{binding all}) &quot;all&quot;<br/>    |&gt; Sign.restore_naming thy<br/>*}<br/><br/>Thus ML antiquotations like @{const_name Pure.eq} may be used already.<br/>Later the application is moved to the current Isabelle version, and<br/>the auxiliary aliases are deleted.<br/><br/>* Attributes &quot;where&quot; and &quot;of&quot; allow an optional context of local<br/>variables (&#39;for&#39; declaration): these variables become schematic in the<br/>instantiated theorem.<br/><br/>* Obsolete attribute &quot;standard&quot; has been discontinued (legacy since<br/>Isabelle2012).  Potential INCOMPATIBILITY, use explicit &#39;for&#39; context<br/>where instantiations with schematic variables are intended (for<br/>declaration commands like &#39;lemmas&#39; or attributes like &quot;of&quot;).  The<br/>following temporary definition may help to port old applications:<br/><br/>  attribute_setup standard =<br/>    &quot;Scan.succeed (Thm.rule_attribute (K Drule.export_without_context))&quot;<br/><br/>* More thorough check of proof context for goal statements and<br/>attributed fact expressions (concerning background theory, declared<br/>hyps).  Potential INCOMPATIBILITY, tools need to observe standard<br/>context discipline.  See also Assumption.add_assumes and the more<br/>primitive Thm.assume_hyps.<br/><br/>* Inner syntax token language allows regular quoted strings &quot;...&quot;<br/>(only makes sense in practice, if outer syntax is delimited<br/>differently, e.g. via cartouches).<br/><br/>* Command &#39;print_term_bindings&#39; supersedes &#39;print_binds&#39; for clarity,<br/>but the latter is retained some time as Proof General legacy.<br/><br/>* Code generator preprocessor: explicit control of simp tracing on a<br/>per-constant basis.  See attribute &quot;code_preproc&quot;.<br/><br/><br/>*** HOL ***<br/><br/>* Code generator: enforce case of identifiers only for strict target<br/>language requirements.  INCOMPATIBILITY.<br/><br/>* Code generator: explicit proof contexts in many ML interfaces.<br/>INCOMPATIBILITY.<br/><br/>* Code generator: minimize exported identifiers by default.  Minor<br/>INCOMPATIBILITY.<br/><br/>* Code generation for SML and OCaml: dropped arcane &quot;no_signatures&quot;<br/>option.  Minor INCOMPATIBILITY.<br/><br/>* &quot;declare [[code abort: ...]]&quot; replaces &quot;code_abort ...&quot;.<br/>INCOMPATIBILITY.<br/><br/>* &quot;declare [[code drop: ...]]&quot; drops all code equations associated<br/>with the given constants.<br/><br/>* Code generations are provided for make, fields, extend and truncate<br/>operations on records.<br/><br/>* Command and antiquotation &quot;value&quot; are now hardcoded against nbe and<br/>ML.  Minor INCOMPATIBILITY.<br/><br/>* Renamed command &#39;enriched_type&#39; to &#39;functor&#39;. INCOMPATIBILITY.<br/><br/>* The symbol &quot;⏎&quot; may be used within char or string literals<br/>to represent (Char Nibble0 NibbleA), i.e. ASCII newline.<br/><br/>* Qualified String.implode and String.explode.  INCOMPATIBILITY.<br/><br/>* Simplifier: Enhanced solver of preconditions of rewrite rules can<br/>now deal with conjunctions.  For help with converting proofs, the old<br/>behaviour of the simplifier can be restored like this: declare/using<br/>[[simp_legacy_precond]].  This configuration option will disappear<br/>again in the future.  INCOMPATIBILITY.<br/><br/>* Simproc &quot;finite_Collect&quot; is no longer enabled by default, due to<br/>spurious crashes and other surprises.  Potential INCOMPATIBILITY.<br/><br/>* Moved new (co)datatype package and its dependencies from session<br/>  &quot;HOL-BNF&quot; to &quot;HOL&quot;.  The commands &#39;bnf&#39;, &#39;wrap_free_constructors&#39;,<br/>  &#39;datatype_new&#39;, &#39;codatatype&#39;, &#39;primcorec&#39;, &#39;primcorecursive&#39; are now<br/>  part of theory &quot;Main&quot;.<br/><br/>  Theory renamings:<br/>    FunDef.thy ~&gt; Fun_Def.thy (and Fun_Def_Base.thy)<br/>    Library/Wfrec.thy ~&gt; Wfrec.thy<br/>    Library/Zorn.thy ~&gt; Zorn.thy<br/>    Cardinals/Order_Relation.thy ~&gt; Order_Relation.thy<br/>    Library/Order_Union.thy ~&gt; Cardinals/Order_Union.thy<br/>    Cardinals/Cardinal_Arithmetic_Base.thy ~&gt; BNF_Cardinal_Arithmetic.thy<br/>    Cardinals/Cardinal_Order_Relation_Base.thy ~&gt; BNF_Cardinal_Order_Relation.thy<br/>    Cardinals/Constructions_on_Wellorders_Base.thy ~&gt; BNF_Constructions_on_Wellorders.thy<br/>    Cardinals/Wellorder_Embedding_Base.thy ~&gt; BNF_Wellorder_Embedding.thy<br/>    Cardinals/Wellorder_Relation_Base.thy ~&gt; BNF_Wellorder_Relation.thy<br/>    BNF/Ctr_Sugar.thy ~&gt; Ctr_Sugar.thy<br/>    BNF/Basic_BNFs.thy ~&gt; Basic_BNFs.thy<br/>    BNF/BNF_Comp.thy ~&gt; BNF_Comp.thy<br/>    BNF/BNF_Def.thy ~&gt; BNF_Def.thy<br/>    BNF/BNF_FP_Base.thy ~&gt; BNF_FP_Base.thy<br/>    BNF/BNF_GFP.thy ~&gt; BNF_GFP.thy<br/>    BNF/BNF_LFP.thy ~&gt; BNF_LFP.thy<br/>    BNF/BNF_Util.thy ~&gt; BNF_Util.thy<br/>    BNF/Coinduction.thy ~&gt; Coinduction.thy<br/>    BNF/More_BNFs.thy ~&gt; Library/More_BNFs.thy<br/>    BNF/Countable_Type.thy ~&gt; Library/Countable_Set_Type.thy<br/>    BNF/Examples/* ~&gt; BNF_Examples/*<br/><br/>  New theories:<br/>    Wellorder_Extension.thy (split from Zorn.thy)<br/>    Library/Cardinal_Notations.thy<br/>    Library/BNF_Axomatization.thy<br/>    BNF_Examples/Misc_Primcorec.thy<br/>    BNF_Examples/Stream_Processor.thy<br/><br/>  Discontinued theories:<br/>    BNF/BNF.thy<br/>    BNF/Equiv_Relations_More.thy<br/><br/>INCOMPATIBILITY.<br/><br/>* New (co)datatype package:<br/>  - Command &#39;primcorec&#39; is fully implemented.<br/>  - Command &#39;datatype_new&#39; generates size functions (&quot;size_xxx&quot; and<br/>    &quot;size&quot;) as required by &#39;fun&#39;.<br/>  - BNFs are integrated with the Lifting tool and new-style<br/>    (co)datatypes with Transfer.<br/>  - Renamed commands:<br/>      datatype_new_compat ~&gt; datatype_compat<br/>      primrec_new ~&gt; primrec<br/>      wrap_free_constructors ~&gt; free_constructors<br/>    INCOMPATIBILITY.<br/>  - The generated constants &quot;xxx_case&quot; and &quot;xxx_rec&quot; have been renamed<br/>    &quot;case_xxx&quot; and &quot;rec_xxx&quot; (e.g., &quot;prod_case&quot; ~&gt; &quot;case_prod&quot;).<br/>    INCOMPATIBILITY.<br/>  - The constant &quot;xxx_(un)fold&quot; and related theorems are no longer<br/>    generated.  Use &quot;xxx_(co)rec&quot; or define &quot;xxx_(un)fold&quot; manually<br/>    using &quot;prim(co)rec&quot;.<br/>    INCOMPATIBILITY.<br/>  - No discriminators are generated for nullary constructors by<br/>    default, eliminating the need for the odd &quot;=:&quot; syntax.<br/>    INCOMPATIBILITY.<br/>  - No discriminators or selectors are generated by default by<br/>    &quot;datatype_new&quot;, unless custom names are specified or the new<br/>    &quot;discs_sels&quot; option is passed.<br/>    INCOMPATIBILITY.<br/><br/>* Old datatype package:<br/>  - The generated theorems &quot;xxx.cases&quot; and &quot;xxx.recs&quot; have been<br/>    renamed &quot;xxx.case&quot; and &quot;xxx.rec&quot; (e.g., &quot;sum.cases&quot; -&gt;<br/>    &quot;sum.case&quot;).  INCOMPATIBILITY.<br/>  - The generated constants &quot;xxx_case&quot;, &quot;xxx_rec&quot;, and &quot;xxx_size&quot; have<br/>    been renamed &quot;case_xxx&quot;, &quot;rec_xxx&quot;, and &quot;size_xxx&quot; (e.g.,<br/>    &quot;prod_case&quot; ~&gt; &quot;case_prod&quot;).  INCOMPATIBILITY.<br/><br/>* The types &quot;&#39;a list&quot; and &quot;&#39;a option&quot;, their set and map functions,<br/>  their relators, and their selectors are now produced using the new<br/>  BNF-based datatype package.<br/><br/>  Renamed constants:<br/>    Option.set ~&gt; set_option<br/>    Option.map ~&gt; map_option<br/>    option_rel ~&gt; rel_option<br/><br/>  Renamed theorems:<br/>    set_def ~&gt; set_rec[abs_def]<br/>    map_def ~&gt; map_rec[abs_def]<br/>    Option.map_def ~&gt; map_option_case[abs_def] (with &quot;case_option&quot; instead of &quot;rec_option&quot;)<br/>    option.recs ~&gt; option.rec<br/>    list_all2_def ~&gt; list_all2_iff<br/>    set.simps ~&gt; set_simps (or the slightly different &quot;list.set&quot;)<br/>    map.simps ~&gt; list.map<br/>    hd.simps ~&gt; list.sel(1)<br/>    tl.simps ~&gt; list.sel(2-3)<br/>    the.simps ~&gt; option.sel<br/><br/>INCOMPATIBILITY.<br/><br/>* The following map functions and relators have been renamed:<br/>    sum_map ~&gt; map_sum<br/>    map_pair ~&gt; map_prod<br/>    prod_rel ~&gt; rel_prod<br/>    sum_rel ~&gt; rel_sum<br/>    fun_rel ~&gt; rel_fun<br/>    set_rel ~&gt; rel_set<br/>    filter_rel ~&gt; rel_filter<br/>    fset_rel ~&gt; rel_fset (in &quot;src/HOL/Library/FSet.thy&quot;)<br/>    cset_rel ~&gt; rel_cset (in &quot;src/HOL/Library/Countable_Set_Type.thy&quot;)<br/>    vset ~&gt; rel_vset (in &quot;src/HOL/Library/Quotient_Set.thy&quot;)<br/><br/>INCOMPATIBILITY.<br/><br/>* Lifting and Transfer:<br/>  - a type variable as a raw type is supported<br/>  - stronger reflexivity prover<br/>  - rep_eq is always generated by lift_definition<br/>  - setup for Lifting/Transfer is now automated for BNFs<br/>    + holds for BNFs that do not contain a dead variable<br/>    + relator_eq, relator_mono, relator_distr, relator_domain,<br/>      relator_eq_onp, quot_map, transfer rules for bi_unique, bi_total,<br/>      right_unique, right_total, left_unique, left_total are proved<br/>      automatically<br/>    + definition of a predicator is generated automatically<br/>    + simplification rules for a predicator definition are proved<br/>      automatically for datatypes<br/>  - consolidation of the setup of Lifting/Transfer<br/>    + property that a relator preservers reflexivity is not needed any<br/>      more<br/>      Minor INCOMPATIBILITY.<br/>    + left_total and left_unique rules are now transfer rules<br/>      (reflexivity_rule attribute not needed anymore)<br/>      INCOMPATIBILITY.<br/>    + Domainp does not have to be a separate assumption in<br/>      relator_domain theorems (=&gt; more natural statement)<br/>      INCOMPATIBILITY.<br/>  - registration of code equations is more robust<br/>    Potential INCOMPATIBILITY.<br/>  - respectfulness proof obligation is preprocessed to a more readable<br/>    form<br/>    Potential INCOMPATIBILITY.<br/>  - eq_onp is always unfolded in respectfulness proof obligation<br/>    Potential INCOMPATIBILITY.<br/>  - unregister lifting setup for Code_Numeral.integer and<br/>    Code_Numeral.natural<br/>    Potential INCOMPATIBILITY.<br/>  - Lifting.invariant -&gt; eq_onp<br/>    INCOMPATIBILITY.<br/><br/>* New internal SAT solver &quot;cdclite&quot; that produces models and proof<br/>traces.  This solver replaces the internal SAT solvers &quot;enumerate&quot; and<br/>&quot;dpll&quot;.  Applications that explicitly used one of these two SAT<br/>solvers should use &quot;cdclite&quot; instead. In addition, &quot;cdclite&quot; is now<br/>the default SAT solver for the &quot;sat&quot; and &quot;satx&quot; proof methods and<br/>corresponding tactics; the old default can be restored using &quot;declare<br/>[[sat_solver = zchaff_with_proofs]]&quot;.  Minor INCOMPATIBILITY.<br/><br/>* SMT module: A new version of the SMT module, temporarily called<br/>&quot;SMT2&quot;, uses SMT-LIB 2 and supports recent versions of Z3 (e.g.,<br/>4.3). The new proof method is called &quot;smt2&quot;. CVC3 and CVC4 are also<br/>supported as oracles. Yices is no longer supported, because no version<br/>of the solver can handle both SMT-LIB 2 and quantifiers.<br/><br/>* Activation of Z3 now works via &quot;z3_non_commercial&quot; system option<br/>(without requiring restart), instead of former settings variable<br/>&quot;Z3_NON_COMMERCIAL&quot;.  The option can be edited in Isabelle/jEdit menu<br/>Plugin Options / Isabelle / General.<br/><br/>* Sledgehammer:<br/>  - Z3 can now produce Isar proofs.<br/>  - MaSh overhaul:<br/>    . New SML-based learning algorithms eliminate the dependency on<br/>      Python and increase performance and reliability.<br/>    . MaSh and MeSh are now used by default together with the<br/>      traditional MePo (Meng-Paulson) relevance filter. To disable<br/>      MaSh, set the &quot;MaSh&quot; system option in Isabelle/jEdit Plugin<br/>      Options / Isabelle / General to &quot;none&quot;.<br/>  - New option:<br/>      smt_proofs<br/>  - Renamed options:<br/>      isar_compress ~&gt; compress<br/>      isar_try0 ~&gt; try0<br/><br/>INCOMPATIBILITY.<br/><br/>* Removed solvers remote_cvc3 and remote_z3. Use cvc3 and z3 instead.<br/><br/>* Nitpick:<br/>  - Fixed soundness bug whereby mutually recursive datatypes could<br/>    take infinite values.<br/>  - Fixed soundness bug with low-level number functions such as<br/>    &quot;Abs_Integ&quot; and &quot;Rep_Integ&quot;.<br/>  - Removed &quot;std&quot; option.<br/>  - Renamed &quot;show_datatypes&quot; to &quot;show_types&quot; and &quot;hide_datatypes&quot; to<br/>    &quot;hide_types&quot;.<br/><br/>* Metis: Removed legacy proof method &#39;metisFT&#39;. Use &#39;metis<br/>(full_types)&#39; instead. INCOMPATIBILITY.<br/><br/>* Try0: Added &#39;algebra&#39; and &#39;meson&#39; to the set of proof methods.<br/><br/>* Adjustion of INF and SUP operations:<br/>  - Elongated constants INFI and SUPR to INFIMUM and SUPREMUM.<br/>  - Consolidated theorem names containing INFI and SUPR: have INF and<br/>    SUP instead uniformly.<br/>  - More aggressive normalization of expressions involving INF and Inf<br/>    or SUP and Sup.<br/>  - INF_image and SUP_image do not unfold composition.<br/>  - Dropped facts INF_comp, SUP_comp.<br/>  - Default congruence rules strong_INF_cong and strong_SUP_cong, with<br/>    simplifier implication in premises.  Generalize and replace former<br/>    INT_cong, SUP_cong<br/><br/>INCOMPATIBILITY.<br/><br/>* SUP and INF generalized to conditionally_complete_lattice.<br/><br/>* Swapped orientation of facts image_comp and vimage_comp:<br/><br/>  image_compose ~&gt; image_comp [symmetric]<br/>  image_comp ~&gt; image_comp [symmetric]<br/>  vimage_compose ~&gt; vimage_comp [symmetric]<br/>  vimage_comp ~&gt; vimage_comp [symmetric]<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory reorganization: split of Big_Operators.thy into<br/>Groups_Big.thy and Lattices_Big.thy.<br/><br/>* Consolidated some facts about big group operators:<br/><br/>    setsum_0&#39; ~&gt; setsum.neutral<br/>    setsum_0 ~&gt; setsum.neutral_const<br/>    setsum_addf ~&gt; setsum.distrib<br/>    setsum_cartesian_product ~&gt; setsum.cartesian_product<br/>    setsum_cases ~&gt; setsum.If_cases<br/>    setsum_commute ~&gt; setsum.commute<br/>    setsum_cong ~&gt; setsum.cong<br/>    setsum_delta ~&gt; setsum.delta<br/>    setsum_delta&#39; ~&gt; setsum.delta&#39;<br/>    setsum_diff1&#39; ~&gt; setsum.remove<br/>    setsum_empty ~&gt; setsum.empty<br/>    setsum_infinite ~&gt; setsum.infinite<br/>    setsum_insert ~&gt; setsum.insert<br/>    setsum_inter_restrict&#39;&#39; ~&gt; setsum.inter_filter<br/>    setsum_mono_zero_cong_left ~&gt; setsum.mono_neutral_cong_left<br/>    setsum_mono_zero_cong_right ~&gt; setsum.mono_neutral_cong_right<br/>    setsum_mono_zero_left ~&gt; setsum.mono_neutral_left<br/>    setsum_mono_zero_right ~&gt; setsum.mono_neutral_right<br/>    setsum_reindex ~&gt; setsum.reindex<br/>    setsum_reindex_cong ~&gt; setsum.reindex_cong<br/>    setsum_reindex_nonzero ~&gt; setsum.reindex_nontrivial<br/>    setsum_restrict_set ~&gt; setsum.inter_restrict<br/>    setsum_Plus ~&gt; setsum.Plus<br/>    setsum_setsum_restrict ~&gt; setsum.commute_restrict<br/>    setsum_Sigma ~&gt; setsum.Sigma<br/>    setsum_subset_diff ~&gt; setsum.subset_diff<br/>    setsum_Un_disjoint ~&gt; setsum.union_disjoint<br/>    setsum_UN_disjoint ~&gt; setsum.UNION_disjoint<br/>    setsum_Un_Int ~&gt; setsum.union_inter<br/>    setsum_Union_disjoint ~&gt; setsum.Union_disjoint<br/>    setsum_UNION_zero ~&gt; setsum.Union_comp<br/>    setsum_Un_zero ~&gt; setsum.union_inter_neutral<br/>    strong_setprod_cong ~&gt; setprod.strong_cong<br/>    strong_setsum_cong ~&gt; setsum.strong_cong<br/>    setprod_1&#39; ~&gt; setprod.neutral<br/>    setprod_1 ~&gt; setprod.neutral_const<br/>    setprod_cartesian_product ~&gt; setprod.cartesian_product<br/>    setprod_cong ~&gt; setprod.cong<br/>    setprod_delta ~&gt; setprod.delta<br/>    setprod_delta&#39; ~&gt; setprod.delta&#39;<br/>    setprod_empty ~&gt; setprod.empty<br/>    setprod_infinite ~&gt; setprod.infinite<br/>    setprod_insert ~&gt; setprod.insert<br/>    setprod_mono_one_cong_left ~&gt; setprod.mono_neutral_cong_left<br/>    setprod_mono_one_cong_right ~&gt; setprod.mono_neutral_cong_right<br/>    setprod_mono_one_left ~&gt; setprod.mono_neutral_left<br/>    setprod_mono_one_right ~&gt; setprod.mono_neutral_right<br/>    setprod_reindex ~&gt; setprod.reindex<br/>    setprod_reindex_cong ~&gt; setprod.reindex_cong<br/>    setprod_reindex_nonzero ~&gt; setprod.reindex_nontrivial<br/>    setprod_Sigma ~&gt; setprod.Sigma<br/>    setprod_subset_diff ~&gt; setprod.subset_diff<br/>    setprod_timesf ~&gt; setprod.distrib<br/>    setprod_Un2 ~&gt; setprod.union_diff2<br/>    setprod_Un_disjoint ~&gt; setprod.union_disjoint<br/>    setprod_UN_disjoint ~&gt; setprod.UNION_disjoint<br/>    setprod_Un_Int ~&gt; setprod.union_inter<br/>    setprod_Union_disjoint ~&gt; setprod.Union_disjoint<br/>    setprod_Un_one ~&gt; setprod.union_inter_neutral<br/><br/>  Dropped setsum_cong2 (simple variant of setsum.cong).<br/>  Dropped setsum_inter_restrict&#39; (simple variant of setsum.inter_restrict)<br/>  Dropped setsum_reindex_id, setprod_reindex_id<br/>    (simple variants of setsum.reindex [symmetric], setprod.reindex [symmetric]).<br/><br/>INCOMPATIBILITY.<br/><br/>* Abolished slightly odd global lattice interpretation for min/max.<br/><br/>  Fact consolidations:<br/>    min_max.inf_assoc ~&gt; min.assoc<br/>    min_max.inf_commute ~&gt; min.commute<br/>    min_max.inf_left_commute ~&gt; min.left_commute<br/>    min_max.inf_idem ~&gt; min.idem<br/>    min_max.inf_left_idem ~&gt; min.left_idem<br/>    min_max.inf_right_idem ~&gt; min.right_idem<br/>    min_max.sup_assoc ~&gt; max.assoc<br/>    min_max.sup_commute ~&gt; max.commute<br/>    min_max.sup_left_commute ~&gt; max.left_commute<br/>    min_max.sup_idem ~&gt; max.idem<br/>    min_max.sup_left_idem ~&gt; max.left_idem<br/>    min_max.sup_inf_distrib1 ~&gt; max_min_distrib2<br/>    min_max.sup_inf_distrib2 ~&gt; max_min_distrib1<br/>    min_max.inf_sup_distrib1 ~&gt; min_max_distrib2<br/>    min_max.inf_sup_distrib2 ~&gt; min_max_distrib1<br/>    min_max.distrib ~&gt; min_max_distribs<br/>    min_max.inf_absorb1 ~&gt; min.absorb1<br/>    min_max.inf_absorb2 ~&gt; min.absorb2<br/>    min_max.sup_absorb1 ~&gt; max.absorb1<br/>    min_max.sup_absorb2 ~&gt; max.absorb2<br/>    min_max.le_iff_inf ~&gt; min.absorb_iff1<br/>    min_max.le_iff_sup ~&gt; max.absorb_iff2<br/>    min_max.inf_le1 ~&gt; min.cobounded1<br/>    min_max.inf_le2 ~&gt; min.cobounded2<br/>    le_maxI1, min_max.sup_ge1 ~&gt; max.cobounded1<br/>    le_maxI2, min_max.sup_ge2 ~&gt; max.cobounded2<br/>    min_max.le_infI1 ~&gt; min.coboundedI1<br/>    min_max.le_infI2 ~&gt; min.coboundedI2<br/>    min_max.le_supI1 ~&gt; max.coboundedI1<br/>    min_max.le_supI2 ~&gt; max.coboundedI2<br/>    min_max.less_infI1 ~&gt; min.strict_coboundedI1<br/>    min_max.less_infI2 ~&gt; min.strict_coboundedI2<br/>    min_max.less_supI1 ~&gt; max.strict_coboundedI1<br/>    min_max.less_supI2 ~&gt; max.strict_coboundedI2<br/>    min_max.inf_mono ~&gt; min.mono<br/>    min_max.sup_mono ~&gt; max.mono<br/>    min_max.le_infI, min_max.inf_greatest ~&gt; min.boundedI<br/>    min_max.le_supI, min_max.sup_least ~&gt; max.boundedI<br/>    min_max.le_inf_iff ~&gt; min.bounded_iff<br/>    min_max.le_sup_iff ~&gt; max.bounded_iff<br/><br/>For min_max.inf_sup_aci, prefer (one of) min.commute, min.assoc,<br/>min.left_commute, min.left_idem, max.commute, max.assoc,<br/>max.left_commute, max.left_idem directly.<br/><br/>For min_max.inf_sup_ord, prefer (one of) min.cobounded1,<br/>min.cobounded2, max.cobounded1m max.cobounded2 directly.<br/><br/>For min_ac or max_ac, prefer more general collection ac_simps.<br/><br/>INCOMPATIBILITY.<br/><br/>* Theorem disambiguation Inf_le_Sup (on finite sets) ~&gt;<br/>Inf_fin_le_Sup_fin.  INCOMPATIBILITY.<br/><br/>* Qualified constant names Wellfounded.acc, Wellfounded.accp.<br/>INCOMPATIBILITY.<br/><br/>* Fact generalization and consolidation:<br/>    neq_one_mod_two, mod_2_not_eq_zero_eq_one_int ~&gt; not_mod_2_eq_0_eq_1<br/><br/>INCOMPATIBILITY.<br/><br/>* Purely algebraic definition of even.  Fact generalization and<br/>  consolidation:<br/>    nat_even_iff_2_dvd, int_even_iff_2_dvd ~&gt; even_iff_2_dvd<br/>    even_zero_(nat|int) ~&gt; even_zero<br/><br/>INCOMPATIBILITY.<br/><br/>* Abolished neg_numeral.<br/>  - Canonical representation for minus one is &quot;- 1&quot;.<br/>  - Canonical representation for other negative numbers is &quot;- (numeral _)&quot;.<br/>  - When devising rule sets for number calculation, consider the<br/>    following canonical cases: 0, 1, numeral _, - 1, - numeral _.<br/>  - HOLogic.dest_number also recognizes numerals in non-canonical forms<br/>    like &quot;numeral One&quot;, &quot;- numeral One&quot;, &quot;- 0&quot; and even &quot;- ... - _&quot;.<br/>  - Syntax for negative numerals is mere input syntax.<br/><br/>INCOMPATIBILITY.<br/><br/>* Reduced name variants for rules on associativity and commutativity:<br/><br/>    add_assoc ~&gt; add.assoc<br/>    add_commute ~&gt; add.commute<br/>    add_left_commute ~&gt; add.left_commute<br/>    mult_assoc ~&gt; mult.assoc<br/>    mult_commute ~&gt; mult.commute<br/>    mult_left_commute ~&gt; mult.left_commute<br/>    nat_add_assoc ~&gt; add.assoc<br/>    nat_add_commute ~&gt; add.commute<br/>    nat_add_left_commute ~&gt; add.left_commute<br/>    nat_mult_assoc ~&gt; mult.assoc<br/>    nat_mult_commute ~&gt; mult.commute<br/>    eq_assoc ~&gt; iff_assoc<br/>    eq_left_commute ~&gt; iff_left_commute<br/><br/>INCOMPATIBILITY.<br/><br/>* Fact collections add_ac and mult_ac are considered old-fashioned.<br/>Prefer ac_simps instead, or specify rules<br/>(add|mult).(assoc|commute|left_commute) individually.<br/><br/>* Elimination of fact duplicates:<br/>    equals_zero_I ~&gt; minus_unique<br/>    diff_eq_0_iff_eq ~&gt; right_minus_eq<br/>    nat_infinite ~&gt; infinite_UNIV_nat<br/>    int_infinite ~&gt; infinite_UNIV_int<br/><br/>INCOMPATIBILITY.<br/><br/>* Fact name consolidation:<br/>    diff_def, diff_minus, ab_diff_minus ~&gt; diff_conv_add_uminus<br/>    minus_le_self_iff ~&gt; neg_less_eq_nonneg<br/>    le_minus_self_iff ~&gt; less_eq_neg_nonpos<br/>    neg_less_nonneg ~&gt; neg_less_pos<br/>    less_minus_self_iff ~&gt; less_neg_neg [simp]<br/><br/>INCOMPATIBILITY.<br/><br/>* More simplification rules on unary and binary minus:<br/>add_diff_cancel, add_diff_cancel_left, add_le_same_cancel1,<br/>add_le_same_cancel2, add_less_same_cancel1, add_less_same_cancel2,<br/>add_minus_cancel, diff_add_cancel, le_add_same_cancel1,<br/>le_add_same_cancel2, less_add_same_cancel1, less_add_same_cancel2,<br/>minus_add_cancel, uminus_add_conv_diff.  These correspondingly have<br/>been taken away from fact collections algebra_simps and field_simps.<br/>INCOMPATIBILITY.<br/><br/>To restore proofs, the following patterns are helpful:<br/><br/>a) Arbitrary failing proof not involving &quot;diff_def&quot;:<br/>Consider simplification with algebra_simps or field_simps.<br/><br/>b) Lifting rules from addition to subtraction:<br/>Try with &quot;using &lt;rule for addition&gt; of [... &quot;- _&quot; ...]&quot; by simp&quot;.<br/><br/>c) Simplification with &quot;diff_def&quot;: just drop &quot;diff_def&quot;.<br/>Consider simplification with algebra_simps or field_simps;<br/>or the brute way with<br/>&quot;simp add: diff_conv_add_uminus del: add_uminus_conv_diff&quot;.<br/><br/>* Introduce bdd_above and bdd_below in theory<br/>Conditionally_Complete_Lattices, use them instead of explicitly<br/>stating boundedness of sets.<br/><br/>* ccpo.admissible quantifies only over non-empty chains to allow more<br/>syntax-directed proof rules; the case of the empty chain shows up as<br/>additional case in fixpoint induction proofs.  INCOMPATIBILITY.<br/><br/>* Removed and renamed theorems in Series:<br/>  summable_le         ~&gt;  suminf_le<br/>  suminf_le           ~&gt;  suminf_le_const<br/>  series_pos_le       ~&gt;  setsum_le_suminf<br/>  series_pos_less     ~&gt;  setsum_less_suminf<br/>  suminf_ge_zero      ~&gt;  suminf_nonneg<br/>  suminf_gt_zero      ~&gt;  suminf_pos<br/>  suminf_gt_zero_iff  ~&gt;  suminf_pos_iff<br/>  summable_sumr_LIMSEQ_suminf  ~&gt;  summable_LIMSEQ<br/>  suminf_0_le         ~&gt;  suminf_nonneg [rotate]<br/>  pos_summable        ~&gt;  summableI_nonneg_bounded<br/>  ratio_test          ~&gt;  summable_ratio_test<br/><br/>  removed series_zero, replaced by sums_finite<br/><br/>  removed auxiliary lemmas:<br/><br/>    sumr_offset, sumr_offset2, sumr_offset3, sumr_offset4, sumr_group,<br/>    half, le_Suc_ex_iff, lemma_realpow_diff_sumr,<br/>    real_setsum_nat_ivl_bounded, summable_le2, ratio_test_lemma2,<br/>    sumr_minus_one_realpow_zerom, sumr_one_lb_realpow_zero,<br/>    summable_convergent_sumr_iff, sumr_diff_mult_const<br/><br/>INCOMPATIBILITY.<br/><br/>* Replace (F)DERIV syntax by has_derivative:<br/>  - &quot;(f has_derivative f&#39;) (at x within s)&quot; replaces &quot;FDERIV f x : s : f&#39;&quot;<br/><br/>  - &quot;(f has_field_derivative f&#39;) (at x within s)&quot; replaces &quot;DERIV f x : s : f&#39;&quot;<br/><br/>  - &quot;f differentiable at x within s&quot; replaces &quot;_ differentiable _ in _&quot; syntax<br/><br/>  - removed constant isDiff<br/><br/>  - &quot;DERIV f x : f&#39;&quot; and &quot;FDERIV f x : f&#39;&quot; syntax is only available as<br/>    input syntax.<br/><br/>  - &quot;DERIV f x : s : f&#39;&quot; and &quot;FDERIV f x : s : f&#39;&quot; syntax removed.<br/><br/>  - Renamed FDERIV_... lemmas to has_derivative_...<br/><br/>  - renamed deriv (the syntax constant used for &quot;DERIV _ _ :&gt; _&quot;) to DERIV<br/><br/>  - removed DERIV_intros, has_derivative_eq_intros<br/><br/>  - introduced derivative_intros and deriative_eq_intros which<br/>    includes now rules for DERIV, has_derivative and<br/>    has_vector_derivative.<br/><br/>  - Other renamings:<br/>    differentiable_def        ~&gt;  real_differentiable_def<br/>    differentiableE           ~&gt;  real_differentiableE<br/>    fderiv_def                ~&gt;  has_derivative_at<br/>    field_fderiv_def          ~&gt;  field_has_derivative_at<br/>    isDiff_der                ~&gt;  differentiable_def<br/>    deriv_fderiv              ~&gt;  has_field_derivative_def<br/>    deriv_def                 ~&gt;  DERIV_def<br/><br/>INCOMPATIBILITY.<br/><br/>* Include more theorems in continuous_intros. Remove the<br/>continuous_on_intros, isCont_intros collections, these facts are now<br/>in continuous_intros.<br/><br/>* Theorems about complex numbers are now stated only using Re and Im,<br/>the Complex constructor is not used anymore. It is possible to use<br/>primcorec to defined the behaviour of a complex-valued function.<br/><br/>Removed theorems about the Complex constructor from the simpset, they<br/>are available as the lemma collection legacy_Complex_simps. This<br/>especially removes<br/><br/>    i_complex_of_real: &quot;ii * complex_of_real r = Complex 0 r&quot;.<br/><br/>Instead the reverse direction is supported with<br/>    Complex_eq: &quot;Complex a b = a + 𝗂 * b&quot;<br/><br/>Moved csqrt from Fundamental_Algebra_Theorem to Complex.<br/><br/>  Renamings:<br/>    Re/Im                  ~&gt;  complex.sel<br/>    complex_Re/Im_zero     ~&gt;  zero_complex.sel<br/>    complex_Re/Im_add      ~&gt;  plus_complex.sel<br/>    complex_Re/Im_minus    ~&gt;  uminus_complex.sel<br/>    complex_Re/Im_diff     ~&gt;  minus_complex.sel<br/>    complex_Re/Im_one      ~&gt;  one_complex.sel<br/>    complex_Re/Im_mult     ~&gt;  times_complex.sel<br/>    complex_Re/Im_inverse  ~&gt;  inverse_complex.sel<br/>    complex_Re/Im_scaleR   ~&gt;  scaleR_complex.sel<br/>    complex_Re/Im_i        ~&gt;  ii.sel<br/>    complex_Re/Im_cnj      ~&gt;  cnj.sel<br/>    Re/Im_cis              ~&gt;  cis.sel<br/><br/>    complex_divide_def   ~&gt;  divide_complex_def<br/>    complex_norm_def     ~&gt;  norm_complex_def<br/>    cmod_def             ~&gt;  norm_complex_de<br/><br/>  Removed theorems:<br/>    complex_zero_def<br/>    complex_add_def<br/>    complex_minus_def<br/>    complex_diff_def<br/>    complex_one_def<br/>    complex_mult_def<br/>    complex_inverse_def<br/>    complex_scaleR_def<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory Lubs moved HOL image to HOL-Library. It is replaced by<br/>Conditionally_Complete_Lattices.  INCOMPATIBILITY.<br/><br/>* HOL-Library: new theory src/HOL/Library/Tree.thy.<br/><br/>* HOL-Library: removed theory src/HOL/Library/Kleene_Algebra.thy; it<br/>is subsumed by session Kleene_Algebra in AFP.<br/><br/>* HOL-Library / theory RBT: various constants and facts are hidden;<br/>lifting setup is unregistered.  INCOMPATIBILITY.<br/><br/>* HOL-Cardinals: new theory src/HOL/Cardinals/Ordinal_Arithmetic.thy.<br/><br/>* HOL-Word: bit representations prefer type bool over type bit.<br/>INCOMPATIBILITY.<br/><br/>* HOL-Word:<br/>  - Abandoned fact collection &quot;word_arith_alts&quot;, which is a duplicate<br/>    of &quot;word_arith_wis&quot;.<br/>  - Dropped first (duplicated) element in fact collections<br/>    &quot;sint_word_ariths&quot;, &quot;word_arith_alts&quot;, &quot;uint_word_ariths&quot;,<br/>    &quot;uint_word_arith_bintrs&quot;.<br/><br/>* HOL-Number_Theory:<br/>  - consolidated the proofs of the binomial theorem<br/>  - the function fib is again of type nat =&gt; nat and not overloaded<br/>  - no more references to Old_Number_Theory in the HOL libraries<br/>    (except the AFP)<br/><br/>INCOMPATIBILITY.<br/><br/>* HOL-Multivariate_Analysis:<br/>  - Type class ordered_real_vector for ordered vector spaces.<br/>  - New theory Complex_Basic_Analysis defining complex derivatives,<br/>    holomorphic functions, etc., ported from HOL Light&#39;s canal.ml.<br/>  - Changed order of ordered_euclidean_space to be compatible with<br/>    pointwise ordering on products. Therefore instance of<br/>    conditionally_complete_lattice and ordered_real_vector.<br/>    INCOMPATIBILITY: use box instead of greaterThanLessThan or<br/>    explicit set-comprehensions with eucl_less for other (half-)open<br/>    intervals.<br/>  - removed dependencies on type class ordered_euclidean_space with<br/>    introduction of &quot;cbox&quot; on euclidean_space<br/>    - renamed theorems:<br/>        interval ~&gt; box<br/>        mem_interval ~&gt; mem_box<br/>        interval_eq_empty ~&gt; box_eq_empty<br/>        interval_ne_empty ~&gt; box_ne_empty<br/>        interval_sing(1) ~&gt; cbox_sing<br/>        interval_sing(2) ~&gt; box_sing<br/>        subset_interval_imp ~&gt; subset_box_imp<br/>        subset_interval ~&gt; subset_box<br/>        open_interval ~&gt; open_box<br/>        closed_interval ~&gt; closed_cbox<br/>        interior_closed_interval ~&gt; interior_cbox<br/>        bounded_closed_interval ~&gt; bounded_cbox<br/>        compact_interval ~&gt; compact_cbox<br/>        bounded_subset_closed_interval_symmetric ~&gt; bounded_subset_cbox_symmetric<br/>        bounded_subset_closed_interval ~&gt; bounded_subset_cbox<br/>        mem_interval_componentwiseI ~&gt; mem_box_componentwiseI<br/>        convex_box ~&gt; convex_prod<br/>        rel_interior_real_interval ~&gt; rel_interior_real_box<br/>        convex_interval ~&gt; convex_box<br/>        convex_hull_eq_real_interval ~&gt; convex_hull_eq_real_cbox<br/>        frechet_derivative_within_closed_interval ~&gt; frechet_derivative_within_cbox<br/>        content_closed_interval&#39; ~&gt; content_cbox&#39;<br/>        elementary_subset_interval ~&gt; elementary_subset_box<br/>        diameter_closed_interval ~&gt; diameter_cbox<br/>        frontier_closed_interval ~&gt; frontier_cbox<br/>        frontier_open_interval ~&gt; frontier_box<br/>        bounded_subset_open_interval_symmetric ~&gt; bounded_subset_box_symmetric<br/>        closure_open_interval ~&gt; closure_box<br/>        open_closed_interval_convex ~&gt; open_cbox_convex<br/>        open_interval_midpoint ~&gt; box_midpoint<br/>        content_image_affinity_interval ~&gt; content_image_affinity_cbox<br/>        is_interval_interval ~&gt; is_interval_cbox + is_interval_box + is_interval_closed_interval<br/>        bounded_interval ~&gt; bounded_closed_interval + bounded_boxes<br/><br/>    - respective theorems for intervals over the reals:<br/>        content_closed_interval + content_cbox<br/>        has_integral + has_integral_real<br/>        fine_division_exists + fine_division_exists_real<br/>        has_integral_null + has_integral_null_real<br/>        tagged_division_union_interval + tagged_division_union_interval_real<br/>        has_integral_const + has_integral_const_real<br/>        integral_const + integral_const_real<br/>        has_integral_bound + has_integral_bound_real<br/>        integrable_continuous + integrable_continuous_real<br/>        integrable_subinterval + integrable_subinterval_real<br/>        has_integral_reflect_lemma + has_integral_reflect_lemma_real<br/>        integrable_reflect + integrable_reflect_real<br/>        integral_reflect + integral_reflect_real<br/>        image_affinity_interval + image_affinity_cbox<br/>        image_smult_interval + image_smult_cbox<br/>        integrable_const + integrable_const_ivl<br/>        integrable_on_subinterval + integrable_on_subcbox<br/><br/>  - renamed theorems:<br/>    derivative_linear         ~&gt;  has_derivative_bounded_linear<br/>    derivative_is_linear      ~&gt;  has_derivative_linear<br/>    bounded_linear_imp_linear ~&gt;  bounded_linear.linear<br/><br/>* HOL-Probability:<br/>  - Renamed positive_integral to nn_integral:<br/><br/>    . Renamed all lemmas &quot;*positive_integral*&quot; to *nn_integral*&quot;<br/>      positive_integral_positive ~&gt; nn_integral_nonneg<br/><br/>    . Renamed abbreviation integral<sup>P</sup> to integral<sup>N</sup>.<br/><br/>  - replaced the Lebesgue integral on real numbers by the more general<br/>    Bochner integral for functions into a real-normed vector space.<br/><br/>    integral_zero               ~&gt;  integral_zero / integrable_zero<br/>    integral_minus              ~&gt;  integral_minus / integrable_minus<br/>    integral_add                ~&gt;  integral_add / integrable_add<br/>    integral_diff               ~&gt;  integral_diff / integrable_diff<br/>    integral_setsum             ~&gt;  integral_setsum / integrable_setsum<br/>    integral_multc              ~&gt;  integral_mult_left / integrable_mult_left<br/>    integral_cmult              ~&gt;  integral_mult_right / integrable_mult_right<br/>    integral_triangle_inequality~&gt;  integral_norm_bound<br/>    integrable_nonneg           ~&gt;  integrableI_nonneg<br/>    integral_positive           ~&gt;  integral_nonneg_AE<br/>    integrable_abs_iff          ~&gt;  integrable_abs_cancel<br/>    positive_integral_lim_INF   ~&gt;  nn_integral_liminf<br/>    lebesgue_real_affine        ~&gt;  lborel_real_affine<br/>    borel_integral_has_integral ~&gt;  has_integral_lebesgue_integral<br/>    integral_indicator          ~&gt;<br/>         integral_real_indicator / integrable_real_indicator<br/>    positive_integral_fst       ~&gt;  nn_integral_fst&#39;<br/>    positive_integral_fst_measurable ~&gt; nn_integral_fst<br/>    positive_integral_snd_measurable ~&gt; nn_integral_snd<br/><br/>    integrable_fst_measurable   ~&gt;<br/>         integral_fst / integrable_fst / AE_integrable_fst<br/><br/>    integrable_snd_measurable   ~&gt;<br/>         integral_snd / integrable_snd / AE_integrable_snd<br/><br/>    integral_monotone_convergence  ~&gt;<br/>         integral_monotone_convergence / integrable_monotone_convergence<br/><br/>    integral_monotone_convergence_at_top  ~&gt;<br/>         integral_monotone_convergence_at_top /<br/>         integrable_monotone_convergence_at_top<br/><br/>    has_integral_iff_positive_integral_lebesgue  ~&gt;<br/>         has_integral_iff_has_bochner_integral_lebesgue_nonneg<br/><br/>    lebesgue_integral_has_integral  ~&gt;<br/>         has_integral_integrable_lebesgue_nonneg<br/><br/>    positive_integral_lebesgue_has_integral  ~&gt;<br/>         integral_has_integral_lebesgue_nonneg /<br/>         integrable_has_integral_lebesgue_nonneg<br/><br/>    lebesgue_integral_real_affine  ~&gt;<br/>         nn_integral_real_affine<br/><br/>    has_integral_iff_positive_integral_lborel  ~&gt;<br/>         integral_has_integral_nonneg / integrable_has_integral_nonneg<br/><br/>    The following theorems where removed:<br/><br/>    lebesgue_integral_nonneg<br/>    lebesgue_integral_uminus<br/>    lebesgue_integral_cmult<br/>    lebesgue_integral_multc<br/>    lebesgue_integral_cmult_nonneg<br/>    integral_cmul_indicator<br/>    integral_real<br/><br/>  - Formalized properties about exponentially, Erlang, and normal<br/>    distributed random variables.<br/><br/>* HOL-Decision_Procs: Separate command &#39;approximate&#39; for approximative<br/>computation in src/HOL/Decision_Procs/Approximation.  Minor<br/>INCOMPATIBILITY.<br/><br/><br/>*** Scala ***<br/><br/>* The signature and semantics of Document.Snapshot.cumulate_markup /<br/>select_markup have been clarified.  Markup is now traversed in the<br/>order of reports given by the prover: later markup is usually more<br/>specific and may override results accumulated so far.  The elements<br/>guard is mandatory and checked precisely.  Subtle INCOMPATIBILITY.<br/><br/>* Substantial reworking of internal PIDE protocol communication<br/>channels.  INCOMPATIBILITY.<br/><br/><br/>*** ML ***<br/><br/>* Subtle change of semantics of Thm.eq_thm: theory stamps are not<br/>compared (according to Thm.thm_ord), but assumed to be covered by the<br/>current background theory.  Thus equivalent data produced in different<br/>branches of the theory graph usually coincides (e.g. relevant for<br/>theory merge).  Note that the softer Thm.eq_thm_prop is often more<br/>appropriate than Thm.eq_thm.<br/><br/>* Proper context for basic Simplifier operations: rewrite_rule,<br/>rewrite_goals_rule, rewrite_goals_tac etc. INCOMPATIBILITY, need to<br/>pass runtime Proof.context (and ensure that the simplified entity<br/>actually belongs to it).<br/><br/>* Proper context discipline for read_instantiate and instantiate_tac:<br/>variables that are meant to become schematic need to be given as<br/>fixed, and are generalized by the explicit context of local variables.<br/>This corresponds to Isar attributes &quot;where&quot; and &quot;of&quot; with &#39;for&#39;<br/>declaration.  INCOMPATIBILITY, also due to potential change of indices<br/>of schematic variables.<br/><br/>* Moved ML_Compiler.exn_trace and other operations on exceptions to<br/>structure Runtime.  Minor INCOMPATIBILITY.<br/><br/>* Discontinued old Toplevel.debug in favour of system option<br/>&quot;ML_exception_trace&quot;, which may be also declared within the context<br/>via &quot;declare [[ML_exception_trace = true]]&quot;.  Minor INCOMPATIBILITY.<br/><br/>* Renamed configuration option &quot;ML_trace&quot; to &quot;ML_source_trace&quot;. Minor<br/>INCOMPATIBILITY.<br/><br/>* Configuration option &quot;ML_print_depth&quot; controls the pretty-printing<br/>depth of the ML compiler within the context.  The old print_depth in<br/>ML is still available as default_print_depth, but rarely used.  Minor<br/>INCOMPATIBILITY.<br/><br/>* Toplevel function &quot;use&quot; refers to raw ML bootstrap environment,<br/>without Isar context nor antiquotations.  Potential INCOMPATIBILITY.<br/>Note that &#39;ML_file&#39; is the canonical command to load ML files into the<br/>formal context.<br/><br/>* Simplified programming interface to define ML antiquotations, see<br/>structure ML_Antiquotation.  Minor INCOMPATIBILITY.<br/><br/>* ML antiquotation @{here} refers to its source position, which is<br/>occasionally useful for experimentation and diagnostic purposes.<br/><br/>* ML antiquotation @{path} produces a Path.T value, similarly to<br/>Path.explode, but with compile-time check against the file-system and<br/>some PIDE markup.  Note that unlike theory source, ML does not have a<br/>well-defined master directory, so an absolute symbolic path<br/>specification is usually required, e.g. &quot;~~/src/HOL&quot;.<br/><br/>* ML antiquotation @{print} inlines a function to print an arbitrary<br/>ML value, which is occasionally useful for diagnostic or demonstration<br/>purposes.<br/><br/><br/>*** System ***<br/><br/>* Proof General with its traditional helper scripts is now an optional<br/>Isabelle component, e.g. see ProofGeneral-4.2-2 from the Isabelle<br/>component repository http://isabelle.in.tum.de/components/.  Note that<br/>the &quot;system&quot; manual provides general explanations about add-on<br/>components, especially those that are not bundled with the release.<br/><br/>* The raw Isabelle process executable has been renamed from<br/>&quot;isabelle-process&quot; to &quot;isabelle_process&quot;, which conforms to common<br/>shell naming conventions, and allows to define a shell function within<br/>the Isabelle environment to avoid dynamic path lookup.  Rare<br/>incompatibility for old tools that do not use the ISABELLE_PROCESS<br/>settings variable.<br/><br/>* Former &quot;isabelle tty&quot; has been superseded by &quot;isabelle console&quot;,<br/>with implicit build like &quot;isabelle jedit&quot;, and without the mostly<br/>obsolete Isar TTY loop.<br/><br/>* Simplified &quot;isabelle display&quot; tool.  Settings variables DVI_VIEWER<br/>and PDF_VIEWER now refer to the actual programs, not shell<br/>command-lines.  Discontinued option -c: invocation may be asynchronous<br/>via desktop environment, without any special precautions.  Potential<br/>INCOMPATIBILITY with ambitious private settings.<br/><br/>* Removed obsolete &quot;isabelle unsymbolize&quot;.  Note that the usual format<br/>for email communication is the Unicode rendering of Isabelle symbols,<br/>as produced by Isabelle/jEdit, for example.<br/><br/>* Removed obsolete tool &quot;wwwfind&quot;. Similar functionality may be<br/>integrated into Isabelle/jEdit eventually.<br/><br/>* Improved &#39;display_drafts&#39; concerning desktop integration and<br/>repeated invocation in PIDE front-end: re-use single file<br/>$ISABELLE_HOME_USER/tmp/drafts.pdf and corresponding views.<br/><br/>* Session ROOT specifications require explicit &#39;document_files&#39; for<br/>robust dependencies on LaTeX sources.  Only these explicitly given<br/>files are copied to the document output directory, before document<br/>processing is started.<br/><br/>* Windows: support for regular TeX installation (e.g. MiKTeX) instead<br/>of TeX Live from Cygwin.<br/><br/><br/><br/>New in Isabelle2013-2 (December 2013)<br/>-------------------------------------<br/><br/>*** Prover IDE -- Isabelle/Scala/jEdit ***<br/><br/>* More robust editing of running commands with internal forks,<br/>e.g. non-terminating &#39;by&#39; steps.<br/><br/>* More relaxed Sledgehammer panel: avoid repeated application of query<br/>after edits surrounding the command location.<br/><br/>* More status information about commands that are interrupted<br/>accidentally (via physical event or Poly/ML runtime system signal,<br/>e.g. out-of-memory).<br/><br/><br/>*** System ***<br/><br/>* More robust termination of external processes managed by<br/>Isabelle/ML: support cancellation of tasks within the range of<br/>milliseconds, as required for PIDE document editing with automatically<br/>tried tools (e.g. Sledgehammer).<br/><br/>* Reactivated Isabelle/Scala kill command for external processes on<br/>Mac OS X, which was accidentally broken in Isabelle2013-1 due to a<br/>workaround for some Debian/Ubuntu Linux versions from 2013.<br/><br/><br/><br/>New in Isabelle2013-1 (November 2013)<br/>-------------------------------------<br/><br/>*** General ***<br/><br/>* Discontinued obsolete &#39;uses&#39; within theory header.  Note that<br/>commands like &#39;ML_file&#39; work without separate declaration of file<br/>dependencies.  Minor INCOMPATIBILITY.<br/><br/>* Discontinued redundant &#39;use&#39; command, which was superseded by<br/>&#39;ML_file&#39; in Isabelle2013.  Minor INCOMPATIBILITY.<br/><br/>* Simplified subscripts within identifiers, using plain ⇩<br/>instead of the second copy \&lt;^isub&gt; and \&lt;^isup&gt;.  Superscripts are<br/>only for literal tokens within notation; explicit mixfix annotations<br/>for consts or fixed variables may be used as fall-back for unusual<br/>names.  Obsolete \&lt;twosuperior&gt; has been expanded to <sup>2</sup> in<br/>Isabelle/HOL.  INCOMPATIBILITY, use &quot;isabelle update_sub_sup&quot; to<br/>standardize symbols as a starting point for further manual cleanup.<br/>The ML reference variable &quot;legacy_isub_isup&quot; may be set as temporary<br/>workaround, to make the prover accept a subset of the old identifier<br/>syntax.<br/><br/>* Document antiquotations: term style &quot;isub&quot; has been renamed to<br/>&quot;sub&quot;.  Minor INCOMPATIBILITY.<br/><br/>* Uniform management of &quot;quick_and_dirty&quot; as system option (see also<br/>&quot;isabelle options&quot;), configuration option within the context (see also<br/>Config.get in Isabelle/ML), and attribute in Isabelle/Isar.  Minor<br/>INCOMPATIBILITY, need to use more official Isabelle means to access<br/>quick_and_dirty, instead of historical poking into mutable reference.<br/><br/>* Renamed command &#39;print_configs&#39; to &#39;print_options&#39;.  Minor<br/>INCOMPATIBILITY.<br/><br/>* Proper diagnostic command &#39;print_state&#39;.  Old &#39;pr&#39; (with its<br/>implicit change of some global references) is retained for now as<br/>control command, e.g. for ProofGeneral 3.7.x.<br/><br/>* Discontinued &#39;print_drafts&#39; command with its old-fashioned PS output<br/>and Unix command-line print spooling.  Minor INCOMPATIBILITY: use<br/>&#39;display_drafts&#39; instead and print via the regular document viewer.<br/><br/>* Updated and extended &quot;isar-ref&quot; and &quot;implementation&quot; manual,<br/>eliminated old &quot;ref&quot; manual.<br/><br/><br/>*** Prover IDE -- Isabelle/Scala/jEdit ***<br/><br/>* New manual &quot;jedit&quot; for Isabelle/jEdit, see isabelle doc or<br/>Documentation panel.<br/><br/>* Dockable window &quot;Documentation&quot; provides access to Isabelle<br/>documentation.<br/><br/>* Dockable window &quot;Find&quot; provides query operations for formal entities<br/>(GUI front-end to &#39;find_theorems&#39; command).<br/><br/>* Dockable window &quot;Sledgehammer&quot; manages asynchronous / parallel<br/>sledgehammer runs over existing document sources, independently of<br/>normal editing and checking process.<br/><br/>* Dockable window &quot;Timing&quot; provides an overview of relevant command<br/>timing information, depending on option jedit_timing_threshold.  The<br/>same timing information is shown in the extended tooltip of the<br/>command keyword, when hovering the mouse over it while the CONTROL or<br/>COMMAND modifier is pressed.<br/><br/>* Improved dockable window &quot;Theories&quot;: Continuous checking of proof<br/>document (visible and required parts) may be controlled explicitly,<br/>using check box or shortcut &quot;C+e ENTER&quot;.  Individual theory nodes may<br/>be marked explicitly as required and checked in full, using check box<br/>or shortcut &quot;C+e SPACE&quot;.<br/><br/>* Improved completion mechanism, which is now managed by the<br/>Isabelle/jEdit plugin instead of SideKick.  Refined table of Isabelle<br/>symbol abbreviations (see $ISABELLE_HOME/etc/symbols).<br/><br/>* Standard jEdit keyboard shortcut C+b complete-word is remapped to<br/>isabelle.complete for explicit completion in Isabelle sources.<br/>INCOMPATIBILITY wrt. jEdit defaults, may have to invent new shortcuts<br/>to resolve conflict.<br/><br/>* Improved support of various &quot;minor modes&quot; for Isabelle NEWS,<br/>options, session ROOT etc., with completion and SideKick tree view.<br/><br/>* Strictly monotonic document update, without premature cancellation of<br/>running transactions that are still needed: avoid reset/restart of<br/>such command executions while editing.<br/><br/>* Support for asynchronous print functions, as overlay to existing<br/>document content.<br/><br/>* Support for automatic tools in HOL, which try to prove or disprove<br/>toplevel theorem statements.<br/><br/>* Action isabelle.reset-font-size resets main text area font size<br/>according to Isabelle/Scala plugin option &quot;jedit_font_reset_size&quot; (see<br/>also &quot;Plugin Options / Isabelle / General&quot;).  It can be bound to some<br/>keyboard shortcut by the user (e.g. C+0 and/or C+NUMPAD0).<br/><br/>* File specifications in jEdit (e.g. file browser) may refer to<br/>$ISABELLE_HOME and $ISABELLE_HOME_USER on all platforms.  Discontinued<br/>obsolete $ISABELLE_HOME_WINDOWS variable.<br/><br/>* Improved support for Linux look-and-feel &quot;GTK+&quot;, see also &quot;Utilities<br/>/ Global Options / Appearance&quot;.<br/><br/>* Improved support of native Mac OS X functionality via &quot;MacOSX&quot;<br/>plugin, which is now enabled by default.<br/><br/><br/>*** Pure ***<br/><br/>* Commands &#39;interpretation&#39; and &#39;sublocale&#39; are now target-sensitive.<br/>In particular, &#39;interpretation&#39; allows for non-persistent<br/>interpretation within &quot;context ... begin ... end&quot; blocks offering a<br/>light-weight alternative to &#39;sublocale&#39;.  See &quot;isar-ref&quot; manual for<br/>details.<br/><br/>* Improved locales diagnostic command &#39;print_dependencies&#39;.<br/><br/>* Discontinued obsolete &#39;axioms&#39; command, which has been marked as<br/>legacy since Isabelle2009-2.  INCOMPATIBILITY, use &#39;axiomatization&#39;<br/>instead, while observing its uniform scope for polymorphism.<br/><br/>* Discontinued empty name bindings in &#39;axiomatization&#39;.<br/>INCOMPATIBILITY.<br/><br/>* System option &quot;proofs&quot; has been discontinued.  Instead the global<br/>state of Proofterm.proofs is persistently compiled into logic images<br/>as required, notably HOL-Proofs.  Users no longer need to change<br/>Proofterm.proofs dynamically.  Minor INCOMPATIBILITY.<br/><br/>* Syntax translation functions (print_translation etc.) always depend<br/>on Proof.context.  Discontinued former &quot;(advanced)&quot; option -- this is<br/>now the default.  Minor INCOMPATIBILITY.<br/><br/>* Former global reference trace_unify_fail is now available as<br/>configuration option &quot;unify_trace_failure&quot; (global context only).<br/><br/>* SELECT_GOAL now retains the syntactic context of the overall goal<br/>state (schematic variables etc.).  Potential INCOMPATIBILITY in rare<br/>situations.<br/><br/><br/>*** HOL ***<br/><br/>* Stronger precedence of syntax for big intersection and union on<br/>sets, in accordance with corresponding lattice operations.<br/>INCOMPATIBILITY.<br/><br/>* Notation &quot;{p:A. P}&quot; now allows tuple patterns as well.<br/><br/>* Nested case expressions are now translated in a separate check phase<br/>rather than during parsing. The data for case combinators is separated<br/>from the datatype package. The declaration attribute<br/>&quot;case_translation&quot; can be used to register new case combinators:<br/><br/>  declare [[case_translation case_combinator constructor1 ... constructorN]]<br/><br/>* Code generator:<br/>  - &#39;code_printing&#39; unifies &#39;code_const&#39; / &#39;code_type&#39; / &#39;code_class&#39; /<br/>    &#39;code_instance&#39;.<br/>  - &#39;code_identifier&#39; declares name hints for arbitrary identifiers in<br/>    generated code, subsuming &#39;code_modulename&#39;.<br/><br/>See the isar-ref manual for syntax diagrams, and the HOL theories for<br/>examples.<br/><br/>* Attibute &#39;code&#39;: &#39;code&#39; now declares concrete and abstract code<br/>equations uniformly.  Use explicit &#39;code equation&#39; and &#39;code abstract&#39;<br/>to distinguish both when desired.<br/><br/>* Discontinued theories Code_Integer and Efficient_Nat by a more<br/>fine-grain stack of theories Code_Target_Int, Code_Binary_Nat,<br/>Code_Target_Nat and Code_Target_Numeral.  See the tutorial on code<br/>generation for details.  INCOMPATIBILITY.<br/><br/>* Numeric types are mapped by default to target language numerals:<br/>natural (replaces former code_numeral) and integer (replaces former<br/>code_int).  Conversions are available as integer_of_natural /<br/>natural_of_integer / integer_of_nat / nat_of_integer (in HOL) and<br/>Code_Numeral.integer_of_natural / Code_Numeral.natural_of_integer (in<br/>ML).  INCOMPATIBILITY.<br/><br/>* Function package: For mutually recursive functions f and g, separate<br/>cases rules f.cases and g.cases are generated instead of unusable<br/>f_g.cases which exposed internal sum types. Potential INCOMPATIBILITY,<br/>in the case that the unusable rule was used nevertheless.<br/><br/>* Function package: For each function f, new rules f.elims are<br/>generated, which eliminate equalities of the form &quot;f x = t&quot;.<br/><br/>* New command &#39;fun_cases&#39; derives ad-hoc elimination rules for<br/>function equations as simplified instances of f.elims, analogous to<br/>inductive_cases.  See ~~/src/HOL/ex/Fundefs.thy for some examples.<br/><br/>* Lifting:<br/>  - parametrized correspondence relations are now supported:<br/>    + parametricity theorems for the raw term can be specified in<br/>      the command lift_definition, which allow us to generate stronger<br/>      transfer rules<br/>    + setup_lifting generates stronger transfer rules if parametric<br/>      correspondence relation can be generated<br/>    + various new properties of the relator must be specified to support<br/>      parametricity<br/>    + parametricity theorem for the Quotient relation can be specified<br/>  - setup_lifting generates domain rules for the Transfer package<br/>  - stronger reflexivity prover of respectfulness theorems for type<br/>    copies<br/>  - ===&gt; and --&gt; are now local. The symbols can be introduced<br/>    by interpreting the locale lifting_syntax (typically in an<br/>    anonymous context)<br/>  - Lifting/Transfer relevant parts of Library/Quotient_* are now in<br/>    Main. Potential INCOMPATIBILITY<br/>  - new commands for restoring and deleting Lifting/Transfer context:<br/>    lifting_forget, lifting_update<br/>  - the command print_quotmaps was renamed to print_quot_maps.<br/>    INCOMPATIBILITY<br/><br/>* Transfer:<br/>  - better support for domains in Transfer: replace Domainp T<br/>    by the actual invariant in a transferred goal<br/>  - transfer rules can have as assumptions other transfer rules<br/>  - Experimental support for transferring from the raw level to the<br/>    abstract level: Transfer.transferred attribute<br/>  - Attribute version of the transfer method: untransferred attribute<br/><br/>* Reification and reflection:<br/>  - Reification is now directly available in HOL-Main in structure<br/>    &quot;Reification&quot;.<br/>  - Reflection now handles multiple lists with variables also.<br/>  - The whole reflection stack has been decomposed into conversions.<br/>INCOMPATIBILITY.<br/><br/>* Revised devices for recursive definitions over finite sets:<br/>  - Only one fundamental fold combinator on finite set remains:<br/>    Finite_Set.fold :: (&#39;a =&gt; &#39;b =&gt; &#39;b) =&gt; &#39;b =&gt; &#39;a set =&gt; &#39;b<br/>    This is now identity on infinite sets.<br/>  - Locales (&quot;mini packages&quot;) for fundamental definitions with<br/>    Finite_Set.fold: folding, folding_idem.<br/>  - Locales comm_monoid_set, semilattice_order_set and<br/>    semilattice_neutr_order_set for big operators on sets.<br/>    See theory Big_Operators for canonical examples.<br/>    Note that foundational constants comm_monoid_set.F and<br/>    semilattice_set.F correspond to former combinators fold_image<br/>    and fold1 respectively.  These are now gone.  You may use<br/>    those foundational constants as substitutes, but it is<br/>    preferable to interpret the above locales accordingly.<br/>  - Dropped class ab_semigroup_idem_mult (special case of lattice,<br/>    no longer needed in connection with Finite_Set.fold etc.)<br/>  - Fact renames:<br/>      card.union_inter ~&gt; card_Un_Int [symmetric]<br/>      card.union_disjoint ~&gt; card_Un_disjoint<br/>INCOMPATIBILITY.<br/><br/>* Locale hierarchy for abstract orderings and (semi)lattices.<br/><br/>* Complete_Partial_Order.admissible is defined outside the type class<br/>ccpo, but with mandatory prefix ccpo. Admissibility theorems lose the<br/>class predicate assumption or sort constraint when possible.<br/>INCOMPATIBILITY.<br/><br/>* Introduce type class &quot;conditionally_complete_lattice&quot;: Like a<br/>complete lattice but does not assume the existence of the top and<br/>bottom elements.  Allows to generalize some lemmas about reals and<br/>extended reals.  Removed SupInf and replaced it by the instantiation<br/>of conditionally_complete_lattice for real. Renamed lemmas about<br/>conditionally-complete lattice from Sup_... to cSup_... and from<br/>Inf_...  to cInf_... to avoid hidding of similar complete lattice<br/>lemmas.<br/><br/>* Introduce type class linear_continuum as combination of<br/>conditionally-complete lattices and inner dense linorders which have<br/>more than one element.  INCOMPATIBILITY.<br/><br/>* Introduced type classes order_top and order_bot. The old classes top<br/>and bot only contain the syntax without assumptions.  INCOMPATIBILITY:<br/>Rename bot -&gt; order_bot, top -&gt; order_top<br/><br/>* Introduce type classes &quot;no_top&quot; and &quot;no_bot&quot; for orderings without<br/>top and bottom elements.<br/><br/>* Split dense_linorder into inner_dense_order and no_top, no_bot.<br/><br/>* Complex_Main: Unify and move various concepts from<br/>HOL-Multivariate_Analysis to HOL-Complex_Main.<br/><br/> - Introduce type class (lin)order_topology and<br/>   linear_continuum_topology.  Allows to generalize theorems about<br/>   limits and order.  Instances are reals and extended reals.<br/><br/> - continuous and continuos_on from Multivariate_Analysis:<br/>   &quot;continuous&quot; is the continuity of a function at a filter.  &quot;isCont&quot;<br/>   is now an abbrevitation: &quot;isCont x f == continuous (at _) f&quot;.<br/><br/>   Generalized continuity lemmas from isCont to continuous on an<br/>   arbitrary filter.<br/><br/> - compact from Multivariate_Analysis. Use Bolzano&#39;s lemma to prove<br/>   compactness of closed intervals on reals. Continuous functions<br/>   attain infimum and supremum on compact sets. The inverse of a<br/>   continuous function is continuous, when the function is continuous<br/>   on a compact set.<br/><br/> - connected from Multivariate_Analysis. Use it to prove the<br/>   intermediate value theorem. Show connectedness of intervals on<br/>   linear_continuum_topology).<br/><br/> - first_countable_topology from Multivariate_Analysis. Is used to<br/>   show equivalence of properties on the neighbourhood filter of x and<br/>   on all sequences converging to x.<br/><br/> - FDERIV: Definition of has_derivative moved to Deriv.thy. Moved<br/>   theorems from Library/FDERIV.thy to Deriv.thy and base the<br/>   definition of DERIV on FDERIV. Add variants of DERIV and FDERIV<br/>   which are restricted to sets, i.e. to represent derivatives from<br/>   left or right.<br/><br/> - Removed the within-filter. It is replaced by the principal filter:<br/><br/>     F within X = inf F (principal X)<br/><br/> - Introduce &quot;at x within U&quot; as a single constant, &quot;at x&quot; is now an<br/>   abbreviation for &quot;at x within UNIV&quot;<br/><br/> - Introduce named theorem collections tendsto_intros,<br/>   continuous_intros, continuous_on_intros and FDERIV_intros. Theorems<br/>   in tendsto_intros (or FDERIV_intros) are also available as<br/>   tendsto_eq_intros (or FDERIV_eq_intros) where the right-hand side<br/>   is replaced by a congruence rule. This allows to apply them as<br/>   intro rules and then proving equivalence by the simplifier.<br/><br/> - Restructured theories in HOL-Complex_Main:<br/><br/>   + Moved RealDef and RComplete into Real<br/><br/>   + Introduced Topological_Spaces and moved theorems about<br/>     topological spaces, filters, limits and continuity to it<br/><br/>   + Renamed RealVector to Real_Vector_Spaces<br/><br/>   + Split Lim, SEQ, Series into Topological_Spaces,<br/>     Real_Vector_Spaces, and Limits<br/><br/>   + Moved Ln and Log to Transcendental<br/><br/>   + Moved theorems about continuity from Deriv to Topological_Spaces<br/><br/> - Remove various auxiliary lemmas.<br/><br/>INCOMPATIBILITY.<br/><br/>* Nitpick:<br/>  - Added option &quot;spy&quot;.<br/>  - Reduce incidence of &quot;too high arity&quot; errors.<br/><br/>* Sledgehammer:<br/>  - Renamed option:<br/>      isar_shrink ~&gt; isar_compress<br/>    INCOMPATIBILITY.<br/>  - Added options &quot;isar_try0&quot;, &quot;spy&quot;.<br/>  - Better support for &quot;isar_proofs&quot;.<br/>  - MaSh has been fined-tuned and now runs as a local server.<br/><br/>* Improved support for ad hoc overloading of constants (see also<br/>isar-ref manual and ~~/src/HOL/ex/Adhoc_Overloading_Examples.thy).<br/><br/>* Library/Polynomial.thy:<br/>  - Use lifting for primitive definitions.<br/>  - Explicit conversions from and to lists of coefficients, used for<br/>    generated code.<br/>  - Replaced recursion operator poly_rec by fold_coeffs.<br/>  - Prefer pre-existing gcd operation for gcd.<br/>  - Fact renames:<br/>    poly_eq_iff ~&gt; poly_eq_poly_eq_iff<br/>    poly_ext ~&gt; poly_eqI<br/>    expand_poly_eq ~&gt; poly_eq_iff<br/>IMCOMPATIBILITY.<br/><br/>* New Library/Simps_Case_Conv.thy: Provides commands simps_of_case and<br/>case_of_simps to convert function definitions between a list of<br/>equations with patterns on the lhs and a single equation with case<br/>expressions on the rhs. See also Ex/Simps_Case_Conv_Examples.thy.<br/><br/>* New Library/FSet.thy: type of finite sets defined as a subtype of<br/>sets defined by Lifting/Transfer.<br/><br/>* Discontinued theory src/HOL/Library/Eval_Witness.  INCOMPATIBILITY.<br/><br/>* Consolidation of library theories on product orders:<br/><br/>    Product_Lattice ~&gt; Product_Order -- pointwise order on products<br/>    Product_ord ~&gt; Product_Lexorder -- lexicographic order on products<br/><br/>INCOMPATIBILITY.<br/><br/>* Imperative-HOL: The MREC combinator is considered legacy and no<br/>longer included by default. INCOMPATIBILITY, use partial_function<br/>instead, or import theory Legacy_Mrec as a fallback.<br/><br/>* HOL-Algebra: Discontinued theories ~~/src/HOL/Algebra/abstract and<br/>~~/src/HOL/Algebra/poly.  Existing theories should be based on<br/>~~/src/HOL/Library/Polynomial instead.  The latter provides<br/>integration with HOL&#39;s type classes for rings.  INCOMPATIBILITY.<br/><br/>* HOL-BNF:<br/>  - Various improvements to BNF-based (co)datatype package, including<br/>    new commands &quot;primrec_new&quot;, &quot;primcorec&quot;, and<br/>    &quot;datatype_new_compat&quot;, as well as documentation. See<br/>    &quot;datatypes.pdf&quot; for details.<br/>  - New &quot;coinduction&quot; method to avoid some boilerplate (compared to<br/>    coinduct).<br/>  - Renamed keywords:<br/>    data ~&gt; datatype_new<br/>    codata ~&gt; codatatype<br/>    bnf_def ~&gt; bnf<br/>  - Renamed many generated theorems, including<br/>    discs ~&gt; disc<br/>    map_comp&#39; ~&gt; map_comp<br/>    map_id&#39; ~&gt; map_id<br/>    sels ~&gt; sel<br/>    set_map&#39; ~&gt; set_map<br/>    sets ~&gt; set<br/>IMCOMPATIBILITY.<br/><br/><br/>*** ML ***<br/><br/>* Spec_Check is a Quickcheck tool for Isabelle/ML.  The ML function<br/>&quot;check_property&quot; allows to check specifications of the form &quot;ALL x y<br/>z. prop x y z&quot;.  See also ~~/src/Tools/Spec_Check/ with its<br/>Examples.thy in particular.<br/><br/>* Improved printing of exception trace in Poly/ML 5.5.1, with regular<br/>tracing output in the command transaction context instead of physical<br/>stdout.  See also Toplevel.debug, Toplevel.debugging and<br/>ML_Compiler.exn_trace.<br/><br/>* ML type &quot;theory&quot; is now immutable, without any special treatment of<br/>drafts or linear updates (which could lead to &quot;stale theory&quot; errors in<br/>the past).  Discontinued obsolete operations like Theory.copy,<br/>Theory.checkpoint, and the auxiliary type theory_ref.  Minor<br/>INCOMPATIBILITY.<br/><br/>* More uniform naming of goal functions for skipped proofs:<br/><br/>    Skip_Proof.prove  ~&gt;  Goal.prove_sorry<br/>    Skip_Proof.prove_global  ~&gt;  Goal.prove_sorry_global<br/><br/>Minor INCOMPATIBILITY.<br/><br/>* Simplifier tactics and tools use proper Proof.context instead of<br/>historic type simpset.  Old-style declarations like addsimps,<br/>addsimprocs etc. operate directly on Proof.context.  Raw type simpset<br/>retains its use as snapshot of the main Simplifier context, using<br/>simpset_of and put_simpset on Proof.context.  INCOMPATIBILITY -- port<br/>old tools by making them depend on (ctxt : Proof.context) instead of<br/>(ss : simpset), then turn (simpset_of ctxt) into ctxt.<br/><br/>* Modifiers for classical wrappers (e.g. addWrapper, delWrapper)<br/>operate on Proof.context instead of claset, for uniformity with addIs,<br/>addEs, addDs etc. Note that claset_of and put_claset allow to manage<br/>clasets separately from the context.<br/><br/>* Discontinued obsolete ML antiquotations @{claset} and @{simpset}.<br/>INCOMPATIBILITY, use @{context} instead.<br/><br/>* Antiquotation @{theory_context A} is similar to @{theory A}, but<br/>presents the result as initial Proof.context.<br/><br/><br/>*** System ***<br/><br/>* Discontinued obsolete isabelle usedir, mkdir, make -- superseded by<br/>&quot;isabelle build&quot; in Isabelle2013.  INCOMPATIBILITY.<br/><br/>* Discontinued obsolete isabelle-process options -f and -u (former<br/>administrative aliases of option -e).  Minor INCOMPATIBILITY.<br/><br/>* Discontinued obsolete isabelle print tool, and PRINT_COMMAND<br/>settings variable.<br/><br/>* Discontinued ISABELLE_DOC_FORMAT settings variable and historic<br/>document formats: dvi.gz, ps, ps.gz -- the default document format is<br/>always pdf.<br/><br/>* Isabelle settings variable ISABELLE_BUILD_JAVA_OPTIONS allows to<br/>specify global resources of the JVM process run by isabelle build.<br/><br/>* Toplevel executable $ISABELLE_HOME/bin/isabelle_scala_script allows<br/>to run Isabelle/Scala source files as standalone programs.<br/><br/>* Improved &quot;isabelle keywords&quot; tool (for old-style ProofGeneral<br/>keyword tables): use Isabelle/Scala operations, which inspect outer<br/>syntax without requiring to build sessions first.<br/><br/>* Sessions may be organized via &#39;chapter&#39; specifications in the ROOT<br/>file, which determines a two-level hierarchy of browser info.  The old<br/>tree-like organization via implicit sub-session relation (with its<br/>tendency towards erratic fluctuation of URLs) has been discontinued.<br/>The default chapter is called &quot;Unsorted&quot;.  Potential INCOMPATIBILITY<br/>for HTML presentation of theories.<br/><br/><br/><br/>New in Isabelle2013 (February 2013)<br/>-----------------------------------<br/><br/>*** General ***<br/><br/>* Theorem status about oracles and unfinished/failed future proofs is<br/>no longer printed by default, since it is incompatible with<br/>incremental / parallel checking of the persistent document model.  ML<br/>function Thm.peek_status may be used to inspect a snapshot of the<br/>ongoing evaluation process.  Note that in batch mode --- notably<br/>isabelle build --- the system ensures that future proofs of all<br/>accessible theorems in the theory context are finished (as before).<br/><br/>* Configuration option show_markup controls direct inlining of markup<br/>into the printed representation of formal entities --- notably type<br/>and sort constraints.  This enables Prover IDE users to retrieve that<br/>information via tooltips in the output window, for example.<br/><br/>* Command &#39;ML_file&#39; evaluates ML text from a file directly within the<br/>theory, without any predeclaration via &#39;uses&#39; in the theory header.<br/><br/>* Old command &#39;use&#39; command and corresponding keyword &#39;uses&#39; in the<br/>theory header are legacy features and will be discontinued soon.<br/>Tools that load their additional source files may imitate the<br/>&#39;ML_file&#39; implementation, such that the system can take care of<br/>dependencies properly.<br/><br/>* Discontinued obsolete method fastsimp / tactic fast_simp_tac, which<br/>is called fastforce / fast_force_tac already since Isabelle2011-1.<br/><br/>* Updated and extended &quot;isar-ref&quot; and &quot;implementation&quot; manual, reduced<br/>remaining material in old &quot;ref&quot; manual.<br/><br/>* Improved support for auxiliary contexts that indicate block structure<br/>for specifications.  Nesting of &quot;context fixes ... context assumes ...&quot;<br/>and &quot;class ... context ...&quot;.<br/><br/>* Attribute &quot;consumes&quot; allows a negative value as well, which is<br/>interpreted relatively to the total number of premises of the rule in<br/>the target context.  This form of declaration is stable when exported<br/>from a nested &#39;context&#39; with additional assumptions.  It is the<br/>preferred form for definitional packages, notably cases/rules produced<br/>in HOL/inductive and HOL/function.<br/><br/>* More informative error messages for Isar proof commands involving<br/>lazy enumerations (method applications etc.).<br/><br/>* Refined &#39;help&#39; command to retrieve outer syntax commands according<br/>to name patterns (with clickable results).<br/><br/><br/>*** Prover IDE -- Isabelle/Scala/jEdit ***<br/><br/>* Parallel terminal proofs (&#39;by&#39;) are enabled by default, likewise<br/>proofs that are built into packages like &#39;datatype&#39;, &#39;function&#39;.  This<br/>allows to &quot;run ahead&quot; checking the theory specifications on the<br/>surface, while the prover is still crunching on internal<br/>justifications.  Unfinished / cancelled proofs are restarted as<br/>required to complete full proof checking eventually.<br/><br/>* Improved output panel with tooltips, hyperlinks etc. based on the<br/>same Rich_Text_Area as regular Isabelle/jEdit buffers.  Activation of<br/>tooltips leads to some window that supports the same recursively,<br/>which can lead to stacks of tooltips as the semantic document content<br/>is explored.  ESCAPE closes the whole stack, individual windows may be<br/>closed separately, or detached to become independent jEdit dockables.<br/><br/>* Improved support for commands that produce graph output: the text<br/>message contains a clickable area to open a new instance of the graph<br/>browser on demand.<br/><br/>* More robust incremental parsing of outer syntax (partial comments,<br/>malformed symbols).  Changing the balance of open/close quotes and<br/>comment delimiters works more conveniently with unfinished situations<br/>that frequently occur in user interaction.<br/><br/>* More efficient painting and improved reactivity when editing large<br/>files.  More scalable management of formal document content.<br/><br/>* Smarter handling of tracing messages: prover process pauses after<br/>certain number of messages per command transaction, with some user<br/>dialog to stop or continue.  This avoids swamping the front-end with<br/>potentially infinite message streams.<br/><br/>* More plugin options and preferences, based on Isabelle/Scala.  The<br/>jEdit plugin option panel provides access to some Isabelle/Scala<br/>options, including tuning parameters for editor reactivity and color<br/>schemes.<br/><br/>* Dockable window &quot;Symbols&quot; provides some editing support for Isabelle<br/>symbols.<br/><br/>* Dockable window &quot;Monitor&quot; shows ML runtime statistics.  Note that<br/>continuous display of the chart slows down the system.<br/><br/>* Improved editing support for control styles: subscript, superscript,<br/>bold, reset of style -- operating on single symbols or text<br/>selections.  Cf. keyboard shortcuts C+e DOWN/UP/RIGHT/LEFT.<br/><br/>* Actions isabelle.increase-font-size and isabelle.decrease-font-size<br/>adjust the main text area font size, and its derivatives for output,<br/>tooltips etc.  Cf. keyboard shortcuts C-PLUS and C-MINUS, which often<br/>need to be adapted to local keyboard layouts.<br/><br/>* More reactive completion popup by default: use \t (TAB) instead of<br/>\n (NEWLINE) to minimize intrusion into regular flow of editing.  See<br/>also &quot;Plugin Options / SideKick / General / Code Completion Options&quot;.<br/><br/>* Implicit check and build dialog of the specified logic session<br/>image.  For example, HOL, HOLCF, HOL-Nominal can be produced on<br/>demand, without bundling big platform-dependent heap images in the<br/>Isabelle distribution.<br/><br/>* Uniform Java 7 platform on Linux, Mac OS X, Windows: recent updates<br/>from Oracle provide better multi-platform experience.  This version is<br/>now bundled exclusively with Isabelle.<br/><br/><br/>*** Pure ***<br/><br/>* Code generation for Haskell: restrict unqualified imports from<br/>Haskell Prelude to a small set of fundamental operations.<br/><br/>* Command &#39;export_code&#39;: relative file names are interpreted<br/>relatively to master directory of current theory rather than the<br/>rather arbitrary current working directory.  INCOMPATIBILITY.<br/><br/>* Discontinued obsolete attribute &quot;COMP&quot;.  Potential INCOMPATIBILITY,<br/>use regular rule composition via &quot;OF&quot; / &quot;THEN&quot;, or explicit proof<br/>structure instead.  Note that Isabelle/ML provides a variety of<br/>operators like COMP, INCR_COMP, COMP_INCR, which need to be applied<br/>with some care where this is really required.<br/><br/>* Command &#39;typ&#39; supports an additional variant with explicit sort<br/>constraint, to infer and check the most general type conforming to a<br/>given sort.  Example (in HOL):<br/><br/>  typ &quot;_ * _ * bool * unit&quot; :: finite<br/><br/>* Command &#39;locale_deps&#39; visualizes all locales and their relations as<br/>a Hasse diagram.<br/><br/><br/>*** HOL ***<br/><br/>* Sledgehammer:<br/><br/>  - Added MaSh relevance filter based on machine-learning; see the<br/>    Sledgehammer manual for details.<br/>  - Polished Isar proofs generated with &quot;isar_proofs&quot; option.<br/>  - Rationalized type encodings (&quot;type_enc&quot; option).<br/>  - Renamed &quot;kill_provers&quot; subcommand to &quot;kill_all&quot;.<br/>  - Renamed options:<br/>      isar_proof ~&gt; isar_proofs<br/>      isar_shrink_factor ~&gt; isar_shrink<br/>      max_relevant ~&gt; max_facts<br/>      relevance_thresholds ~&gt; fact_thresholds<br/><br/>* Quickcheck: added an optimisation for equality premises.  It is<br/>switched on by default, and can be switched off by setting the<br/>configuration quickcheck_optimise_equality to false.<br/><br/>* Quotient: only one quotient can be defined by quotient_type<br/>INCOMPATIBILITY.<br/><br/>* Lifting:<br/>  - generation of an abstraction function equation in lift_definition<br/>  - quot_del attribute<br/>  - renamed no_abs_code -&gt; no_code (INCOMPATIBILITY.)<br/><br/>* Simproc &quot;finite_Collect&quot; rewrites set comprehensions into pointfree<br/>expressions.<br/><br/>* Preprocessing of the code generator rewrites set comprehensions into<br/>pointfree expressions.<br/><br/>* The SMT solver Z3 has now by default a restricted set of directly<br/>supported features. For the full set of features (div/mod, nonlinear<br/>arithmetic, datatypes/records) with potential proof reconstruction<br/>failures, enable the configuration option &quot;z3_with_extensions&quot;.  Minor<br/>INCOMPATIBILITY.<br/><br/>* Simplified &#39;typedef&#39; specifications: historical options for implicit<br/>set definition and alternative name have been discontinued.  The<br/>former behavior of &quot;typedef (open) t = A&quot; is now the default, but<br/>written just &quot;typedef t = A&quot;.  INCOMPATIBILITY, need to adapt theories<br/>accordingly.<br/><br/>* Removed constant &quot;chars&quot;; prefer &quot;Enum.enum&quot; on type &quot;char&quot;<br/>directly.  INCOMPATIBILITY.<br/><br/>* Moved operation product, sublists and n_lists from theory Enum to<br/>List.  INCOMPATIBILITY.<br/><br/>* Theorem UN_o generalized to SUP_comp.  INCOMPATIBILITY.<br/><br/>* Class &quot;comm_monoid_diff&quot; formalises properties of bounded<br/>subtraction, with natural numbers and multisets as typical instances.<br/><br/>* Added combinator &quot;Option.these&quot; with type &quot;&#39;a option set =&gt; &#39;a set&quot;.<br/><br/>* Theory &quot;Transitive_Closure&quot;: renamed lemmas<br/><br/>  reflcl_tranclp -&gt; reflclp_tranclp<br/>  rtranclp_reflcl -&gt; rtranclp_reflclp<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory &quot;Rings&quot;: renamed lemmas (in class semiring)<br/><br/>  left_distrib ~&gt; distrib_right<br/>  right_distrib ~&gt; distrib_left<br/><br/>INCOMPATIBILITY.<br/><br/>* Generalized the definition of limits:<br/><br/>  - Introduced the predicate filterlim (LIM x F. f x :&gt; G) which<br/>    expresses that when the input values x converge to F then the<br/>    output f x converges to G.<br/><br/>  - Added filters for convergence to positive (at_top) and negative<br/>    infinity (at_bot).<br/><br/>  - Moved infinity in the norm (at_infinity) from<br/>    Multivariate_Analysis to Complex_Main.<br/><br/>  - Removed real_tendsto_inf, it is superseded by &quot;LIM x F. f x :&gt;<br/>    at_top&quot;.<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory &quot;Library/Option_ord&quot; provides instantiation of option type to<br/>lattice type classes.<br/><br/>* Theory &quot;Library/Multiset&quot;: renamed<br/><br/>    constant fold_mset ~&gt; Multiset.fold<br/>    fact fold_mset_commute ~&gt; fold_mset_comm<br/><br/>INCOMPATIBILITY.<br/><br/>* Renamed theory Library/List_Prefix to Library/Sublist, with related<br/>changes as follows.<br/><br/>  - Renamed constants (and related lemmas)<br/><br/>      prefix ~&gt; prefixeq<br/>      strict_prefix ~&gt; prefix<br/><br/>  - Replaced constant &quot;postfix&quot; by &quot;suffixeq&quot; with swapped argument<br/>    order (i.e., &quot;postfix xs ys&quot; is now &quot;suffixeq ys xs&quot;) and dropped<br/>    old infix syntax &quot;xs &gt;&gt;= ys&quot;; use &quot;suffixeq ys xs&quot; instead.<br/>    Renamed lemmas accordingly.<br/><br/>  - Added constant &quot;list_hembeq&quot; for homeomorphic embedding on<br/>    lists. Added abbreviation &quot;sublisteq&quot; for special case<br/>    &quot;list_hembeq (op =)&quot;.<br/><br/>  - Theory Library/Sublist no longer provides &quot;order&quot; and &quot;bot&quot; type<br/>    class instances for the prefix order (merely corresponding locale<br/>    interpretations). The type class instances are now in theory<br/>    Library/Prefix_Order.<br/><br/>  - The sublist relation of theory Library/Sublist_Order is now based<br/>    on &quot;Sublist.sublisteq&quot;.  Renamed lemmas accordingly:<br/><br/>      le_list_append_le_same_iff ~&gt; Sublist.sublisteq_append_le_same_iff<br/>      le_list_append_mono ~&gt; Sublist.list_hembeq_append_mono<br/>      le_list_below_empty ~&gt; Sublist.list_hembeq_Nil, Sublist.list_hembeq_Nil2<br/>      le_list_Cons_EX ~&gt; Sublist.list_hembeq_ConsD<br/>      le_list_drop_Cons2 ~&gt; Sublist.sublisteq_Cons2&#39;<br/>      le_list_drop_Cons_neq ~&gt; Sublist.sublisteq_Cons2_neq<br/>      le_list_drop_Cons ~&gt; Sublist.sublisteq_Cons&#39;<br/>      le_list_drop_many ~&gt; Sublist.sublisteq_drop_many<br/>      le_list_filter_left ~&gt; Sublist.sublisteq_filter_left<br/>      le_list_rev_drop_many ~&gt; Sublist.sublisteq_rev_drop_many<br/>      le_list_rev_take_iff ~&gt; Sublist.sublisteq_append<br/>      le_list_same_length ~&gt; Sublist.sublisteq_same_length<br/>      le_list_take_many_iff ~&gt; Sublist.sublisteq_append&#39;<br/>      less_eq_list.drop ~&gt; less_eq_list_drop<br/>      less_eq_list.induct ~&gt; less_eq_list_induct<br/>      not_le_list_length ~&gt; Sublist.not_sublisteq_length<br/><br/>INCOMPATIBILITY.<br/><br/>* New theory Library/Countable_Set.<br/><br/>* Theory Library/Debug and Library/Parallel provide debugging and<br/>parallel execution for code generated towards Isabelle/ML.<br/><br/>* Theory Library/FuncSet: Extended support for Pi and extensional and<br/>introduce the extensional dependent function space &quot;PiE&quot;. Replaced<br/>extensional_funcset by an abbreviation, and renamed lemmas from<br/>extensional_funcset to PiE as follows:<br/><br/>  extensional_empty  ~&gt;  PiE_empty<br/>  extensional_funcset_empty_domain  ~&gt;  PiE_empty_domain<br/>  extensional_funcset_empty_range  ~&gt;  PiE_empty_range<br/>  extensional_funcset_arb  ~&gt;  PiE_arb<br/>  extensional_funcset_mem  ~&gt;  PiE_mem<br/>  extensional_funcset_extend_domainI  ~&gt;  PiE_fun_upd<br/>  extensional_funcset_restrict_domain  ~&gt;  fun_upd_in_PiE<br/>  extensional_funcset_extend_domain_eq  ~&gt;  PiE_insert_eq<br/>  card_extensional_funcset  ~&gt;  card_PiE<br/>  finite_extensional_funcset  ~&gt;  finite_PiE<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory Library/FinFun: theory of almost everywhere constant<br/>functions (supersedes the AFP entry &quot;Code Generation for Functions as<br/>Data&quot;).<br/><br/>* Theory Library/Phantom: generic phantom type to make a type<br/>parameter appear in a constant&#39;s type.  This alternative to adding<br/>TYPE(&#39;a) as another parameter avoids unnecessary closures in generated<br/>code.<br/><br/>* Theory Library/RBT_Impl: efficient construction of red-black trees<br/>from sorted associative lists. Merging two trees with rbt_union may<br/>return a structurally different tree than before.  Potential<br/>INCOMPATIBILITY.<br/><br/>* Theory Library/IArray: immutable arrays with code generation.<br/><br/>* Theory Library/Finite_Lattice: theory of finite lattices.<br/><br/>* HOL/Multivariate_Analysis: replaced<br/><br/>  &quot;basis :: &#39;a::euclidean_space =&gt; nat =&gt; real&quot;<br/>  &quot;\&lt;Chi&gt;\&lt;Chi&gt; :: (nat =&gt; real) =&gt; &#39;a::euclidean_space&quot;<br/><br/>on euclidean spaces by using the inner product &quot;_ ∙ _&quot; with<br/>vectors from the Basis set: &quot;\&lt;Chi&gt;\&lt;Chi&gt; i. f i&quot; is superseded by<br/>&quot;SUM i : Basis. f i * r i&quot;.<br/><br/>  With this change the following constants are also changed or removed:<br/><br/>    DIM(&#39;a) :: nat  ~&gt;  card (Basis :: &#39;a set)   (is an abbreviation)<br/>    a $$ i  ~&gt;  inner a i  (where i : Basis)<br/>    cart_base i  removed<br/>    π, π&#39;  removed<br/><br/>  Theorems about these constants where removed.<br/><br/>  Renamed lemmas:<br/><br/>    component_le_norm  ~&gt;  Basis_le_norm<br/>    euclidean_eq  ~&gt;  euclidean_eq_iff<br/>    differential_zero_maxmin_component  ~&gt;  differential_zero_maxmin_cart<br/>    euclidean_simps  ~&gt;  inner_simps<br/>    independent_basis  ~&gt;  independent_Basis<br/>    span_basis  ~&gt;  span_Basis<br/>    in_span_basis  ~&gt;  in_span_Basis<br/>    norm_bound_component_le  ~&gt;  norm_boound_Basis_le<br/>    norm_bound_component_lt  ~&gt;  norm_boound_Basis_lt<br/>    component_le_infnorm  ~&gt;  Basis_le_infnorm<br/><br/>INCOMPATIBILITY.<br/><br/>* HOL/Probability:<br/><br/>  - Added simproc &quot;measurable&quot; to automatically prove measurability.<br/><br/>  - Added induction rules for sigma sets with disjoint union<br/>    (sigma_sets_induct_disjoint) and for Borel-measurable functions<br/>    (borel_measurable_induct).<br/><br/>  - Added the Daniell-Kolmogorov theorem (the existence the limit of a<br/>    projective family).<br/><br/>* HOL/Cardinals: Theories of ordinals and cardinals (supersedes the<br/>AFP entry &quot;Ordinals_and_Cardinals&quot;).<br/><br/>* HOL/BNF: New (co)datatype package based on bounded natural functors<br/>with support for mixed, nested recursion and interesting non-free<br/>datatypes.<br/><br/>* HOL/Finite_Set and Relation: added new set and relation operations<br/>expressed by Finite_Set.fold.<br/><br/>* New theory HOL/Library/RBT_Set: implementation of sets by red-black<br/>trees for the code generator.<br/><br/>* HOL/Library/RBT and HOL/Library/Mapping have been converted to<br/>Lifting/Transfer.<br/>possible INCOMPATIBILITY.<br/><br/>* HOL/Set: renamed Set.project -&gt; Set.filter<br/>INCOMPATIBILITY.<br/><br/><br/>*** Document preparation ***<br/><br/>* Dropped legacy antiquotations &quot;term_style&quot; and &quot;thm_style&quot;, since<br/>styles may be given as arguments to &quot;term&quot; and &quot;thm&quot; already.<br/>Discontinued legacy styles &quot;prem1&quot; .. &quot;prem19&quot;.<br/><br/>* Default LaTeX rendering for € is now based on eurosym package,<br/>instead of slightly exotic babel/greek.<br/><br/>* Document variant NAME may use different LaTeX entry point<br/>document/root_NAME.tex if that file exists, instead of the common<br/>document/root.tex.<br/><br/>* Simplified custom document/build script, instead of old-style<br/>document/IsaMakefile.  Minor INCOMPATIBILITY.<br/><br/><br/>*** ML ***<br/><br/>* The default limit for maximum number of worker threads is now 8,<br/>instead of 4, in correspondence to capabilities of contemporary<br/>hardware and Poly/ML runtime system.<br/><br/>* Type Seq.results and related operations support embedded error<br/>messages within lazy enumerations, and thus allow to provide<br/>informative errors in the absence of any usable results.<br/><br/>* Renamed Position.str_of to Position.here to emphasize that this is a<br/>formal device to inline positions into message text, but not<br/>necessarily printing visible text.<br/><br/><br/>*** System ***<br/><br/>* Advanced support for Isabelle sessions and build management, see<br/>&quot;system&quot; manual for the chapter of that name, especially the &quot;isabelle<br/>build&quot; tool and its examples.  The &quot;isabelle mkroot&quot; tool prepares<br/>session root directories for use with &quot;isabelle build&quot;, similar to<br/>former &quot;isabelle mkdir&quot; for &quot;isabelle usedir&quot;.  Note that this affects<br/>document preparation as well.  INCOMPATIBILITY, isabelle usedir /<br/>mkdir / make are rendered obsolete.<br/><br/>* Discontinued obsolete Isabelle/build script, it is superseded by the<br/>regular isabelle build tool.  For example:<br/><br/>  isabelle build -s -b HOL<br/><br/>* Discontinued obsolete &quot;isabelle makeall&quot;.<br/><br/>* Discontinued obsolete IsaMakefile and ROOT.ML files from the<br/>Isabelle distribution, except for rudimentary src/HOL/IsaMakefile that<br/>provides some traditional targets that invoke &quot;isabelle build&quot;.  Note<br/>that this is inefficient!  Applications of Isabelle/HOL involving<br/>&quot;isabelle make&quot; should be upgraded to use &quot;isabelle build&quot; directly.<br/><br/>* The &quot;isabelle options&quot; tool prints Isabelle system options, as<br/>required for &quot;isabelle build&quot;, for example.<br/><br/>* The &quot;isabelle logo&quot; tool produces EPS and PDF format simultaneously.<br/>Minor INCOMPATIBILITY in command-line options.<br/><br/>* The &quot;isabelle install&quot; tool has now a simpler command-line.  Minor<br/>INCOMPATIBILITY.<br/><br/>* The &quot;isabelle components&quot; tool helps to resolve add-on components<br/>that are not bundled, or referenced from a bare-bones repository<br/>version of Isabelle.<br/><br/>* Settings variable ISABELLE_PLATFORM_FAMILY refers to the general<br/>platform family: &quot;linux&quot;, &quot;macos&quot;, &quot;windows&quot;.<br/><br/>* The ML system is configured as regular component, and no longer<br/>picked up from some surrounding directory.  Potential INCOMPATIBILITY<br/>for home-made settings.<br/><br/>* Improved ML runtime statistics (heap, threads, future tasks etc.).<br/><br/>* Discontinued support for Poly/ML 5.2.1, which was the last version<br/>without exception positions and advanced ML compiler/toplevel<br/>configuration.<br/><br/>* Discontinued special treatment of Proof General -- no longer guess<br/>PROOFGENERAL_HOME based on accidental file-system layout.  Minor<br/>INCOMPATIBILITY: provide PROOFGENERAL_HOME and PROOFGENERAL_OPTIONS<br/>settings manually, or use a Proof General version that has been<br/>bundled as Isabelle component.<br/><br/><br/><br/>New in Isabelle2012 (May 2012)<br/>------------------------------<br/><br/>*** General ***<br/><br/>* Prover IDE (PIDE) improvements:<br/><br/>  - more robust Sledgehammer integration (as before the sledgehammer<br/>    command-line needs to be typed into the source buffer)<br/>  - markup for bound variables<br/>  - markup for types of term variables (displayed as tooltips)<br/>  - support for user-defined Isar commands within the running session<br/>  - improved support for Unicode outside original 16bit range<br/>    e.g. glyph for 𝒜 (thanks to jEdit 4.5.1)<br/><br/>* Forward declaration of outer syntax keywords within the theory<br/>header -- minor INCOMPATIBILITY for user-defined commands.  Allow new<br/>commands to be used in the same theory where defined.<br/><br/>* Auxiliary contexts indicate block structure for specifications with<br/>additional parameters and assumptions.  Such unnamed contexts may be<br/>nested within other targets, like &#39;theory&#39;, &#39;locale&#39;, &#39;class&#39;,<br/>&#39;instantiation&#39; etc.  Results from the local context are generalized<br/>accordingly and applied to the enclosing target context.  Example:<br/><br/>  context<br/>    fixes x y z :: &#39;a<br/>    assumes xy: &quot;x = y&quot; and yz: &quot;y = z&quot;<br/>  begin<br/><br/>  lemma my_trans: &quot;x = z&quot; using xy yz by simp<br/><br/>  end<br/><br/>  thm my_trans<br/><br/>The most basic application is to factor-out context elements of<br/>several fixes/assumes/shows theorem statements, e.g. see<br/>~~/src/HOL/Isar_Examples/Group_Context.thy<br/><br/>Any other local theory specification element works within the &quot;context<br/>... begin ... end&quot; block as well.<br/><br/>* Bundled declarations associate attributed fact expressions with a<br/>given name in the context.  These may be later included in other<br/>contexts.  This allows to manage context extensions casually, without<br/>the logical dependencies of locales and locale interpretation.  See<br/>commands &#39;bundle&#39;, &#39;include&#39;, &#39;including&#39; etc. in the isar-ref manual.<br/><br/>* Commands &#39;lemmas&#39; and &#39;theorems&#39; allow local variables using &#39;for&#39;<br/>declaration, and results are standardized before being stored.  Thus<br/>old-style &quot;standard&quot; after instantiation or composition of facts<br/>becomes obsolete.  Minor INCOMPATIBILITY, due to potential change of<br/>indices of schematic variables.<br/><br/>* Rule attributes in local theory declarations (e.g. locale or class)<br/>are now statically evaluated: the resulting theorem is stored instead<br/>of the original expression.  INCOMPATIBILITY in rare situations, where<br/>the historic accident of dynamic re-evaluation in interpretations<br/>etc. was exploited.<br/><br/>* New tutorial &quot;Programming and Proving in Isabelle/HOL&quot;<br/>(&quot;prog-prove&quot;).  It completely supersedes &quot;A Tutorial Introduction to<br/>Structured Isar Proofs&quot; (&quot;isar-overview&quot;), which has been removed.  It<br/>also supersedes &quot;Isabelle/HOL, A Proof Assistant for Higher-Order<br/>Logic&quot; as the recommended beginners tutorial, but does not cover all<br/>of the material of that old tutorial.<br/><br/>* Updated and extended reference manuals: &quot;isar-ref&quot;,<br/>&quot;implementation&quot;, &quot;system&quot;; reduced remaining material in old &quot;ref&quot;<br/>manual.<br/><br/><br/>*** Pure ***<br/><br/>* Command &#39;definition&#39; no longer exports the foundational &quot;raw_def&quot;<br/>into the user context.  Minor INCOMPATIBILITY, may use the regular<br/>&quot;def&quot; result with attribute &quot;abs_def&quot; to imitate the old version.<br/><br/>* Attribute &quot;abs_def&quot; turns an equation of the form &quot;f x y == t&quot; into<br/>&quot;f == %x y. t&quot;, which ensures that &quot;simp&quot; or &quot;unfold&quot; steps always<br/>expand it.  This also works for object-logic equality.  (Formerly<br/>undocumented feature.)<br/><br/>* Sort constraints are now propagated in simultaneous statements, just<br/>like type constraints.  INCOMPATIBILITY in rare situations, where<br/>distinct sorts used to be assigned accidentally.  For example:<br/><br/>  lemma &quot;P (x::&#39;a::foo)&quot; and &quot;Q (y::&#39;a::bar)&quot;  -- &quot;now illegal&quot;<br/><br/>  lemma &quot;P (x::&#39;a)&quot; and &quot;Q (y::&#39;a::bar)&quot;<br/>    -- &quot;now uniform &#39;a::bar instead of default sort for first occurrence (!)&quot;<br/><br/>* Rule composition via attribute &quot;OF&quot; (or ML functions OF/MRS) is more<br/>tolerant against multiple unifiers, as long as the final result is<br/>unique.  (As before, rules are composed in canonical right-to-left<br/>order to accommodate newly introduced premises.)<br/><br/>* Renamed some inner syntax categories:<br/><br/>    num ~&gt; num_token<br/>    xnum ~&gt; xnum_token<br/>    xstr ~&gt; str_token<br/><br/>Minor INCOMPATIBILITY.  Note that in practice &quot;num_const&quot; or<br/>&quot;num_position&quot; etc. are mainly used instead (which also include<br/>position information via constraints).<br/><br/>* Simplified configuration options for syntax ambiguity: see<br/>&quot;syntax_ambiguity_warning&quot; and &quot;syntax_ambiguity_limit&quot; in isar-ref<br/>manual.  Minor INCOMPATIBILITY.<br/><br/>* Discontinued configuration option &quot;syntax_positions&quot;: atomic terms<br/>in parse trees are always annotated by position constraints.<br/><br/>* Old code generator for SML and its commands &#39;code_module&#39;,<br/>&#39;code_library&#39;, &#39;consts_code&#39;, &#39;types_code&#39; have been discontinued.<br/>Use commands of the generic code generator instead.  INCOMPATIBILITY.<br/><br/>* Redundant attribute &quot;code_inline&quot; has been discontinued. Use<br/>&quot;code_unfold&quot; instead.  INCOMPATIBILITY.<br/><br/>* Dropped attribute &quot;code_unfold_post&quot; in favor of the its dual<br/>&quot;code_abbrev&quot;, which yields a common pattern in definitions like<br/><br/>  definition [code_abbrev]: &quot;f = t&quot;<br/><br/>INCOMPATIBILITY.<br/><br/>* Obsolete &#39;types&#39; command has been discontinued.  Use &#39;type_synonym&#39;<br/>instead.  INCOMPATIBILITY.<br/><br/>* Discontinued old &quot;prems&quot; fact, which used to refer to the accidental<br/>collection of foundational premises in the context (already marked as<br/>legacy since Isabelle2011).<br/><br/><br/>*** HOL ***<br/><br/>* Type &#39;a set is now a proper type constructor (just as before<br/>Isabelle2008).  Definitions mem_def and Collect_def have disappeared.<br/>Non-trivial INCOMPATIBILITY.  For developments keeping predicates and<br/>sets separate, it is often sufficient to rephrase some set S that has<br/>been accidentally used as predicates by &quot;%x. x : S&quot;, and some<br/>predicate P that has been accidentally used as set by &quot;{x. P x}&quot;.<br/>Corresponding proofs in a first step should be pruned from any<br/>tinkering with former theorems mem_def and Collect_def as far as<br/>possible.<br/><br/>For developments which deliberately mix predicates and sets, a<br/>planning step is necessary to determine what should become a predicate<br/>and what a set.  It can be helpful to carry out that step in<br/>Isabelle2011-1 before jumping right into the current release.<br/><br/>* Code generation by default implements sets as container type rather<br/>than predicates.  INCOMPATIBILITY.<br/><br/>* New type synonym &#39;a rel = (&#39;a * &#39;a) set<br/><br/>* The representation of numerals has changed.  Datatype &quot;num&quot;<br/>represents strictly positive binary numerals, along with functions<br/>&quot;numeral :: num =&gt; &#39;a&quot; and &quot;neg_numeral :: num =&gt; &#39;a&quot; to represent<br/>positive and negated numeric literals, respectively.  See also<br/>definitions in ~~/src/HOL/Num.thy.  Potential INCOMPATIBILITY, some<br/>user theories may require adaptations as follows:<br/><br/>  - Theorems with number_ring or number_semiring constraints: These<br/>    classes are gone; use comm_ring_1 or comm_semiring_1 instead.<br/><br/>  - Theories defining numeric types: Remove number, number_semiring,<br/>    and number_ring instances. Defer all theorems about numerals until<br/>    after classes one and semigroup_add have been instantiated.<br/><br/>  - Numeral-only simp rules: Replace each rule having a &quot;number_of v&quot;<br/>    pattern with two copies, one for numeral and one for neg_numeral.<br/><br/>  - Theorems about subclasses of semiring_1 or ring_1: These classes<br/>    automatically support numerals now, so more simp rules and<br/>    simprocs may now apply within the proof.<br/><br/>  - Definitions and theorems using old constructors Pls/Min/Bit0/Bit1:<br/>    Redefine using other integer operations.<br/><br/>* Transfer: New package intended to generalize the existing<br/>&quot;descending&quot; method and related theorem attributes from the Quotient<br/>package.  (Not all functionality is implemented yet, but future<br/>development will focus on Transfer as an eventual replacement for the<br/>corresponding parts of the Quotient package.)<br/><br/>  - transfer_rule attribute: Maintains a collection of transfer rules,<br/>    which relate constants at two different types. Transfer rules may<br/>    relate different type instances of the same polymorphic constant,<br/>    or they may relate an operation on a raw type to a corresponding<br/>    operation on an abstract type (quotient or subtype). For example:<br/><br/>    ((A ===&gt; B) ===&gt; list_all2 A ===&gt; list_all2 B) map map<br/>    (cr_int ===&gt; cr_int ===&gt; cr_int) (%(x,y) (u,v). (x+u, y+v)) plus_int<br/><br/>  - transfer method: Replaces a subgoal on abstract types with an<br/>    equivalent subgoal on the corresponding raw types. Constants are<br/>    replaced with corresponding ones according to the transfer rules.<br/>    Goals are generalized over all free variables by default; this is<br/>    necessary for variables whose types change, but can be overridden<br/>    for specific variables with e.g. &quot;transfer fixing: x y z&quot;.  The<br/>    variant transfer&#39; method allows replacing a subgoal with one that<br/>    is logically stronger (rather than equivalent).<br/><br/>  - relator_eq attribute: Collects identity laws for relators of<br/>    various type constructors, e.g. &quot;list_all2 (op =) = (op =)&quot;.  The<br/>    transfer method uses these lemmas to infer transfer rules for<br/>    non-polymorphic constants on the fly.<br/><br/>  - transfer_prover method: Assists with proving a transfer rule for a<br/>    new constant, provided the constant is defined in terms of other<br/>    constants that already have transfer rules. It should be applied<br/>    after unfolding the constant definitions.<br/><br/>  - HOL/ex/Transfer_Int_Nat.thy: Example theory demonstrating transfer<br/>    from type nat to type int.<br/><br/>* Lifting: New package intended to generalize the quotient_definition<br/>facility of the Quotient package; designed to work with Transfer.<br/><br/>  - lift_definition command: Defines operations on an abstract type in<br/>    terms of a corresponding operation on a representation<br/>    type.  Example syntax:<br/><br/>    lift_definition dlist_insert :: &quot;&#39;a =&gt; &#39;a dlist =&gt; &#39;a dlist&quot;<br/>      is List.insert<br/><br/>    Users must discharge a respectfulness proof obligation when each<br/>    constant is defined. (For a type copy, i.e. a typedef with UNIV,<br/>    the proof is discharged automatically.) The obligation is<br/>    presented in a user-friendly, readable form; a respectfulness<br/>    theorem in the standard format and a transfer rule are generated<br/>    by the package.<br/><br/>  - Integration with code_abstype: For typedefs (e.g. subtypes<br/>    corresponding to a datatype invariant, such as dlist),<br/>    lift_definition generates a code certificate theorem and sets up<br/>    code generation for each constant.<br/><br/>  - setup_lifting command: Sets up the Lifting package to work with a<br/>    user-defined type. The user must provide either a quotient theorem<br/>    or a type_definition theorem.  The package configures transfer<br/>    rules for equality and quantifiers on the type, and sets up the<br/>    lift_definition command to work with the type.<br/><br/>  - Usage examples: See Quotient_Examples/Lift_DList.thy,<br/>    Quotient_Examples/Lift_RBT.thy, Quotient_Examples/Lift_FSet.thy,<br/>    Word/Word.thy and Library/Float.thy.<br/><br/>* Quotient package:<br/><br/>  - The &#39;quotient_type&#39; command now supports a &#39;morphisms&#39; option with<br/>    rep and abs functions, similar to typedef.<br/><br/>  - &#39;quotient_type&#39; sets up new types to work with the Lifting and<br/>    Transfer packages, as with &#39;setup_lifting&#39;.<br/><br/>  - The &#39;quotient_definition&#39; command now requires the user to prove a<br/>    respectfulness property at the point where the constant is<br/>    defined, similar to lift_definition; INCOMPATIBILITY.<br/><br/>  - Renamed predicate &#39;Quotient&#39; to &#39;Quotient3&#39;, and renamed theorems<br/>    accordingly, INCOMPATIBILITY.<br/><br/>* New diagnostic command &#39;find_unused_assms&#39; to find potentially<br/>superfluous assumptions in theorems using Quickcheck.<br/><br/>* Quickcheck:<br/><br/>  - Quickcheck returns variable assignments as counterexamples, which<br/>    allows to reveal the underspecification of functions under test.<br/>    For example, refuting &quot;hd xs = x&quot;, it presents the variable<br/>    assignment xs = [] and x = a1 as a counterexample, assuming that<br/>    any property is false whenever &quot;hd []&quot; occurs in it.<br/><br/>    These counterexample are marked as potentially spurious, as<br/>    Quickcheck also returns &quot;xs = []&quot; as a counterexample to the<br/>    obvious theorem &quot;hd xs = hd xs&quot;.<br/><br/>    After finding a potentially spurious counterexample, Quickcheck<br/>    continues searching for genuine ones.<br/><br/>    By default, Quickcheck shows potentially spurious and genuine<br/>    counterexamples. The option &quot;genuine_only&quot; sets quickcheck to only<br/>    show genuine counterexamples.<br/><br/>  - The command &#39;quickcheck_generator&#39; creates random and exhaustive<br/>    value generators for a given type and operations.<br/><br/>    It generates values by using the operations as if they were<br/>    constructors of that type.<br/><br/>  - Support for multisets.<br/><br/>  - Added &quot;use_subtype&quot; options.<br/><br/>  - Added &quot;quickcheck_locale&quot; configuration to specify how to process<br/>    conjectures in a locale context.<br/><br/>* Nitpick: Fixed infinite loop caused by the &#39;peephole_optim&#39; option<br/>and affecting &#39;rat&#39; and &#39;real&#39;.<br/><br/>* Sledgehammer:<br/>  - Integrated more tightly with SPASS, as described in the ITP 2012<br/>    paper &quot;More SPASS with Isabelle&quot;.<br/>  - Made it try &quot;smt&quot; as a fallback if &quot;metis&quot; fails or times out.<br/>  - Added support for the following provers: Alt-Ergo (via Why3 and<br/>    TFF1), iProver, iProver-Eq.<br/>  - Sped up the minimizer.<br/>  - Added &quot;lam_trans&quot;, &quot;uncurry_aliases&quot;, and &quot;minimize&quot; options.<br/>  - Renamed &quot;slicing&quot; (&quot;no_slicing&quot;) option to &quot;slice&quot; (&quot;dont_slice&quot;).<br/>  - Renamed &quot;sound&quot; option to &quot;strict&quot;.<br/><br/>* Metis: Added possibility to specify lambda translations scheme as a<br/>parenthesized argument (e.g., &quot;by (metis (lifting) ...)&quot;).<br/><br/>* SMT: Renamed &quot;smt_fixed&quot; option to &quot;smt_read_only_certificates&quot;.<br/><br/>* Command &#39;try0&#39;: Renamed from &#39;try_methods&#39;. INCOMPATIBILITY.<br/><br/>* New &quot;case_product&quot; attribute to generate a case rule doing multiple<br/>case distinctions at the same time.  E.g.<br/><br/>  list.exhaust [case_product nat.exhaust]<br/><br/>produces a rule which can be used to perform case distinction on both<br/>a list and a nat.<br/><br/>* New &quot;eventually_elim&quot; method as a generalized variant of the<br/>eventually_elim* rules.  Supports structured proofs.<br/><br/>* Typedef with implicit set definition is considered legacy.  Use<br/>&quot;typedef (open)&quot; form instead, which will eventually become the<br/>default.<br/><br/>* Record: code generation can be switched off manually with<br/><br/>  declare [[record_coden = false]]  -- &quot;default true&quot;<br/><br/>* Datatype: type parameters allow explicit sort constraints.<br/><br/>* Concrete syntax for case expressions includes constraints for source<br/>positions, and thus produces Prover IDE markup for its bindings.<br/>INCOMPATIBILITY for old-style syntax translations that augment the<br/>pattern notation; e.g. see src/HOL/HOLCF/One.thy for translations of<br/>one_case.<br/><br/>* Clarified attribute &quot;mono_set&quot;: pure declaration without modifying<br/>the result of the fact expression.<br/><br/>* More default pred/set conversions on a couple of relation operations<br/>and predicates.  Added powers of predicate relations.  Consolidation<br/>of some relation theorems:<br/><br/>  converse_def ~&gt; converse_unfold<br/>  rel_comp_def ~&gt; relcomp_unfold<br/>  symp_def ~&gt; (modified, use symp_def and sym_def instead)<br/>  transp_def ~&gt; transp_trans<br/>  Domain_def ~&gt; Domain_unfold<br/>  Range_def ~&gt; Domain_converse [symmetric]<br/><br/>Generalized theorems INF_INT_eq, INF_INT_eq2, SUP_UN_eq, SUP_UN_eq2.<br/><br/>See theory &quot;Relation&quot; for examples for making use of pred/set<br/>conversions by means of attributes &quot;to_set&quot; and &quot;to_pred&quot;.<br/><br/>INCOMPATIBILITY.<br/><br/>* Renamed facts about the power operation on relations, i.e., relpow<br/>to match the constant&#39;s name:<br/><br/>  rel_pow_1 ~&gt; relpow_1<br/>  rel_pow_0_I ~&gt; relpow_0_I<br/>  rel_pow_Suc_I ~&gt; relpow_Suc_I<br/>  rel_pow_Suc_I2 ~&gt; relpow_Suc_I2<br/>  rel_pow_0_E ~&gt; relpow_0_E<br/>  rel_pow_Suc_E ~&gt; relpow_Suc_E<br/>  rel_pow_E ~&gt; relpow_E<br/>  rel_pow_Suc_D2 ~&gt; relpow_Suc_D2<br/>  rel_pow_Suc_E2 ~&gt; relpow_Suc_E2<br/>  rel_pow_Suc_D2&#39; ~&gt; relpow_Suc_D2&#39;<br/>  rel_pow_E2 ~&gt; relpow_E2<br/>  rel_pow_add ~&gt; relpow_add<br/>  rel_pow_commute ~&gt; relpow<br/>  rel_pow_empty ~&gt; relpow_empty:<br/>  rtrancl_imp_UN_rel_pow ~&gt; rtrancl_imp_UN_relpow<br/>  rel_pow_imp_rtrancl ~&gt; relpow_imp_rtrancl<br/>  rtrancl_is_UN_rel_pow ~&gt; rtrancl_is_UN_relpow<br/>  rtrancl_imp_rel_pow ~&gt; rtrancl_imp_relpow<br/>  rel_pow_fun_conv ~&gt; relpow_fun_conv<br/>  rel_pow_finite_bounded1 ~&gt; relpow_finite_bounded1<br/>  rel_pow_finite_bounded ~&gt; relpow_finite_bounded<br/>  rtrancl_finite_eq_rel_pow ~&gt; rtrancl_finite_eq_relpow<br/>  trancl_finite_eq_rel_pow ~&gt; trancl_finite_eq_relpow<br/>  single_valued_rel_pow ~&gt; single_valued_relpow<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory Relation: Consolidated constant name for relation composition<br/>and corresponding theorem names:<br/><br/>  - Renamed constant rel_comp to relcomp.<br/><br/>  - Dropped abbreviation pred_comp. Use relcompp instead.<br/><br/>  - Renamed theorems:<br/><br/>    rel_compI ~&gt; relcompI<br/>    rel_compEpair ~&gt; relcompEpair<br/>    rel_compE ~&gt; relcompE<br/>    pred_comp_rel_comp_eq ~&gt; relcompp_relcomp_eq<br/>    rel_comp_empty1 ~&gt; relcomp_empty1<br/>    rel_comp_mono ~&gt; relcomp_mono<br/>    rel_comp_subset_Sigma ~&gt; relcomp_subset_Sigma<br/>    rel_comp_distrib ~&gt; relcomp_distrib<br/>    rel_comp_distrib2 ~&gt; relcomp_distrib2<br/>    rel_comp_UNION_distrib ~&gt; relcomp_UNION_distrib<br/>    rel_comp_UNION_distrib2 ~&gt; relcomp_UNION_distrib2<br/>    single_valued_rel_comp ~&gt; single_valued_relcomp<br/>    rel_comp_def ~&gt; relcomp_unfold<br/>    converse_rel_comp ~&gt; converse_relcomp<br/>    pred_compI ~&gt; relcomppI<br/>    pred_compE ~&gt; relcomppE<br/>    pred_comp_bot1 ~&gt; relcompp_bot1<br/>    pred_comp_bot2 ~&gt; relcompp_bot2<br/>    transp_pred_comp_less_eq ~&gt; transp_relcompp_less_eq<br/>    pred_comp_mono ~&gt; relcompp_mono<br/>    pred_comp_distrib ~&gt; relcompp_distrib<br/>    pred_comp_distrib2 ~&gt; relcompp_distrib2<br/>    converse_pred_comp ~&gt; converse_relcompp<br/><br/>    finite_rel_comp ~&gt; finite_relcomp<br/><br/>    set_rel_comp ~&gt; set_relcomp<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory Divides: Discontinued redundant theorems about div and mod.<br/>INCOMPATIBILITY, use the corresponding generic theorems instead.<br/><br/>  DIVISION_BY_ZERO ~&gt; div_by_0, mod_by_0<br/>  zdiv_self ~&gt; div_self<br/>  zmod_self ~&gt; mod_self<br/>  zdiv_zero ~&gt; div_0<br/>  zmod_zero ~&gt; mod_0<br/>  zdiv_zmod_equality ~&gt; div_mod_equality2<br/>  zdiv_zmod_equality2 ~&gt; div_mod_equality<br/>  zmod_zdiv_trivial ~&gt; mod_div_trivial<br/>  zdiv_zminus_zminus ~&gt; div_minus_minus<br/>  zmod_zminus_zminus ~&gt; mod_minus_minus<br/>  zdiv_zminus2 ~&gt; div_minus_right<br/>  zmod_zminus2 ~&gt; mod_minus_right<br/>  zdiv_minus1_right ~&gt; div_minus1_right<br/>  zmod_minus1_right ~&gt; mod_minus1_right<br/>  zdvd_mult_div_cancel ~&gt; dvd_mult_div_cancel<br/>  zmod_zmult1_eq ~&gt; mod_mult_right_eq<br/>  zpower_zmod ~&gt; power_mod<br/>  zdvd_zmod ~&gt; dvd_mod<br/>  zdvd_zmod_imp_zdvd ~&gt; dvd_mod_imp_dvd<br/>  mod_mult_distrib ~&gt; mult_mod_left<br/>  mod_mult_distrib2 ~&gt; mult_mod_right<br/><br/>* Removed redundant theorems nat_mult_2 and nat_mult_2_right; use<br/>generic mult_2 and mult_2_right instead. INCOMPATIBILITY.<br/><br/>* Finite_Set.fold now qualified.  INCOMPATIBILITY.<br/><br/>* Consolidated theorem names concerning fold combinators:<br/><br/>  inf_INFI_fold_inf ~&gt; inf_INF_fold_inf<br/>  sup_SUPR_fold_sup ~&gt; sup_SUP_fold_sup<br/>  INFI_fold_inf ~&gt; INF_fold_inf<br/>  SUPR_fold_sup ~&gt; SUP_fold_sup<br/>  union_set ~&gt; union_set_fold<br/>  minus_set ~&gt; minus_set_fold<br/>  INFI_set_fold ~&gt; INF_set_fold<br/>  SUPR_set_fold ~&gt; SUP_set_fold<br/>  INF_code ~&gt; INF_set_foldr<br/>  SUP_code ~&gt; SUP_set_foldr<br/>  foldr.simps ~&gt; foldr.simps (in point-free formulation)<br/>  foldr_fold_rev ~&gt; foldr_conv_fold<br/>  foldl_fold ~&gt; foldl_conv_fold<br/>  foldr_foldr ~&gt; foldr_conv_foldl<br/>  foldl_foldr ~&gt; foldl_conv_foldr<br/>  fold_set_remdups ~&gt; fold_set_fold_remdups<br/>  fold_set ~&gt; fold_set_fold<br/>  fold1_set ~&gt; fold1_set_fold<br/><br/>INCOMPATIBILITY.<br/><br/>* Dropped rarely useful theorems concerning fold combinators:<br/>foldl_apply, foldl_fun_comm, foldl_rev, fold_weak_invariant,<br/>rev_foldl_cons, fold_set_remdups, fold_set, fold_set1,<br/>concat_conv_foldl, foldl_weak_invariant, foldl_invariant,<br/>foldr_invariant, foldl_absorb0, foldl_foldr1_lemma, foldl_foldr1,<br/>listsum_conv_fold, listsum_foldl, sort_foldl_insort, foldl_assoc,<br/>foldr_conv_foldl, start_le_sum, elem_le_sum, sum_eq_0_conv.<br/>INCOMPATIBILITY.  For the common phrases &quot;%xs. List.foldr plus xs 0&quot;<br/>and &quot;List.foldl plus 0&quot;, prefer &quot;List.listsum&quot;.  Otherwise it can be<br/>useful to boil down &quot;List.foldr&quot; and &quot;List.foldl&quot; to &quot;List.fold&quot; by<br/>unfolding &quot;foldr_conv_fold&quot; and &quot;foldl_conv_fold&quot;.<br/><br/>* Dropped lemmas minus_set_foldr, union_set_foldr, union_coset_foldr,<br/>inter_coset_foldr, Inf_fin_set_foldr, Sup_fin_set_foldr,<br/>Min_fin_set_foldr, Max_fin_set_foldr, Inf_set_foldr, Sup_set_foldr,<br/>INF_set_foldr, SUP_set_foldr.  INCOMPATIBILITY.  Prefer corresponding<br/>lemmas over fold rather than foldr, or make use of lemmas<br/>fold_conv_foldr and fold_rev.<br/><br/>* Congruence rules Option.map_cong and Option.bind_cong for recursion<br/>through option types.<br/><br/>* &quot;Transitive_Closure.ntrancl&quot;: bounded transitive closure on<br/>relations.<br/><br/>* Constant &quot;Set.not_member&quot; now qualified.  INCOMPATIBILITY.<br/><br/>* Theory Int: Discontinued many legacy theorems specific to type int.<br/>INCOMPATIBILITY, use the corresponding generic theorems instead.<br/><br/>  zminus_zminus ~&gt; minus_minus<br/>  zminus_0 ~&gt; minus_zero<br/>  zminus_zadd_distrib ~&gt; minus_add_distrib<br/>  zadd_commute ~&gt; add_commute<br/>  zadd_assoc ~&gt; add_assoc<br/>  zadd_left_commute ~&gt; add_left_commute<br/>  zadd_ac ~&gt; add_ac<br/>  zmult_ac ~&gt; mult_ac<br/>  zadd_0 ~&gt; add_0_left<br/>  zadd_0_right ~&gt; add_0_right<br/>  zadd_zminus_inverse2 ~&gt; left_minus<br/>  zmult_zminus ~&gt; mult_minus_left<br/>  zmult_commute ~&gt; mult_commute<br/>  zmult_assoc ~&gt; mult_assoc<br/>  zadd_zmult_distrib ~&gt; left_distrib<br/>  zadd_zmult_distrib2 ~&gt; right_distrib<br/>  zdiff_zmult_distrib ~&gt; left_diff_distrib<br/>  zdiff_zmult_distrib2 ~&gt; right_diff_distrib<br/>  zmult_1 ~&gt; mult_1_left<br/>  zmult_1_right ~&gt; mult_1_right<br/>  zle_refl ~&gt; order_refl<br/>  zle_trans ~&gt; order_trans<br/>  zle_antisym ~&gt; order_antisym<br/>  zle_linear ~&gt; linorder_linear<br/>  zless_linear ~&gt; linorder_less_linear<br/>  zadd_left_mono ~&gt; add_left_mono<br/>  zadd_strict_right_mono ~&gt; add_strict_right_mono<br/>  zadd_zless_mono ~&gt; add_less_le_mono<br/>  int_0_less_1 ~&gt; zero_less_one<br/>  int_0_neq_1 ~&gt; zero_neq_one<br/>  zless_le ~&gt; less_le<br/>  zpower_zadd_distrib ~&gt; power_add<br/>  zero_less_zpower_abs_iff ~&gt; zero_less_power_abs_iff<br/>  zero_le_zpower_abs ~&gt; zero_le_power_abs<br/><br/>* Theory Deriv: Renamed<br/><br/>  DERIV_nonneg_imp_nonincreasing ~&gt; DERIV_nonneg_imp_nondecreasing<br/><br/>* Theory Library/Multiset: Improved code generation of multisets.<br/><br/>* Theory HOL/Library/Set_Algebras: Addition and multiplication on sets<br/>are expressed via type classes again. The special syntax<br/>⊕/⊗ has been replaced by plain +/*. Removed constant<br/>setsum_set, which is now subsumed by Big_Operators.setsum.<br/>INCOMPATIBILITY.<br/><br/>* Theory HOL/Library/Diagonalize has been removed. INCOMPATIBILITY,<br/>use theory HOL/Library/Nat_Bijection instead.<br/><br/>* Theory HOL/Library/RBT_Impl: Backing implementation of red-black<br/>trees is now inside a type class context.  Names of affected<br/>operations and lemmas have been prefixed by rbt_.  INCOMPATIBILITY for<br/>theories working directly with raw red-black trees, adapt the names as<br/>follows:<br/><br/>  Operations:<br/>  bulkload -&gt; rbt_bulkload<br/>  del_from_left -&gt; rbt_del_from_left<br/>  del_from_right -&gt; rbt_del_from_right<br/>  del -&gt; rbt_del<br/>  delete -&gt; rbt_delete<br/>  ins -&gt; rbt_ins<br/>  insert -&gt; rbt_insert<br/>  insertw -&gt; rbt_insert_with<br/>  insert_with_key -&gt; rbt_insert_with_key<br/>  map_entry -&gt; rbt_map_entry<br/>  lookup -&gt; rbt_lookup<br/>  sorted -&gt; rbt_sorted<br/>  tree_greater -&gt; rbt_greater<br/>  tree_less -&gt; rbt_less<br/>  tree_less_symbol -&gt; rbt_less_symbol<br/>  union -&gt; rbt_union<br/>  union_with -&gt; rbt_union_with<br/>  union_with_key -&gt; rbt_union_with_key<br/><br/>  Lemmas:<br/>  balance_left_sorted -&gt; balance_left_rbt_sorted<br/>  balance_left_tree_greater -&gt; balance_left_rbt_greater<br/>  balance_left_tree_less -&gt; balance_left_rbt_less<br/>  balance_right_sorted -&gt; balance_right_rbt_sorted<br/>  balance_right_tree_greater -&gt; balance_right_rbt_greater<br/>  balance_right_tree_less -&gt; balance_right_rbt_less<br/>  balance_sorted -&gt; balance_rbt_sorted<br/>  balance_tree_greater -&gt; balance_rbt_greater<br/>  balance_tree_less -&gt; balance_rbt_less<br/>  bulkload_is_rbt -&gt; rbt_bulkload_is_rbt<br/>  combine_sorted -&gt; combine_rbt_sorted<br/>  combine_tree_greater -&gt; combine_rbt_greater<br/>  combine_tree_less -&gt; combine_rbt_less<br/>  delete_in_tree -&gt; rbt_delete_in_tree<br/>  delete_is_rbt -&gt; rbt_delete_is_rbt<br/>  del_from_left_tree_greater -&gt; rbt_del_from_left_rbt_greater<br/>  del_from_left_tree_less -&gt; rbt_del_from_left_rbt_less<br/>  del_from_right_tree_greater -&gt; rbt_del_from_right_rbt_greater<br/>  del_from_right_tree_less -&gt; rbt_del_from_right_rbt_less<br/>  del_in_tree -&gt; rbt_del_in_tree<br/>  del_inv1_inv2 -&gt; rbt_del_inv1_inv2<br/>  del_sorted -&gt; rbt_del_rbt_sorted<br/>  del_tree_greater -&gt; rbt_del_rbt_greater<br/>  del_tree_less -&gt; rbt_del_rbt_less<br/>  dom_lookup_Branch -&gt; dom_rbt_lookup_Branch<br/>  entries_lookup -&gt; entries_rbt_lookup<br/>  finite_dom_lookup -&gt; finite_dom_rbt_lookup<br/>  insert_sorted -&gt; rbt_insert_rbt_sorted<br/>  insertw_is_rbt -&gt; rbt_insertw_is_rbt<br/>  insertwk_is_rbt -&gt; rbt_insertwk_is_rbt<br/>  insertwk_sorted -&gt; rbt_insertwk_rbt_sorted<br/>  insertw_sorted -&gt; rbt_insertw_rbt_sorted<br/>  ins_sorted -&gt; ins_rbt_sorted<br/>  ins_tree_greater -&gt; ins_rbt_greater<br/>  ins_tree_less -&gt; ins_rbt_less<br/>  is_rbt_sorted -&gt; is_rbt_rbt_sorted<br/>  lookup_balance -&gt; rbt_lookup_balance<br/>  lookup_bulkload -&gt; rbt_lookup_rbt_bulkload<br/>  lookup_delete -&gt; rbt_lookup_rbt_delete<br/>  lookup_Empty -&gt; rbt_lookup_Empty<br/>  lookup_from_in_tree -&gt; rbt_lookup_from_in_tree<br/>  lookup_in_tree -&gt; rbt_lookup_in_tree<br/>  lookup_ins -&gt; rbt_lookup_ins<br/>  lookup_insert -&gt; rbt_lookup_rbt_insert<br/>  lookup_insertw -&gt; rbt_lookup_rbt_insertw<br/>  lookup_insertwk -&gt; rbt_lookup_rbt_insertwk<br/>  lookup_keys -&gt; rbt_lookup_keys<br/>  lookup_map -&gt; rbt_lookup_map<br/>  lookup_map_entry -&gt; rbt_lookup_rbt_map_entry<br/>  lookup_tree_greater -&gt; rbt_lookup_rbt_greater<br/>  lookup_tree_less -&gt; rbt_lookup_rbt_less<br/>  lookup_union -&gt; rbt_lookup_rbt_union<br/>  map_entry_color_of -&gt; rbt_map_entry_color_of<br/>  map_entry_inv1 -&gt; rbt_map_entry_inv1<br/>  map_entry_inv2 -&gt; rbt_map_entry_inv2<br/>  map_entry_is_rbt -&gt; rbt_map_entry_is_rbt<br/>  map_entry_sorted -&gt; rbt_map_entry_rbt_sorted<br/>  map_entry_tree_greater -&gt; rbt_map_entry_rbt_greater<br/>  map_entry_tree_less -&gt; rbt_map_entry_rbt_less<br/>  map_tree_greater -&gt; map_rbt_greater<br/>  map_tree_less -&gt; map_rbt_less<br/>  map_sorted -&gt; map_rbt_sorted<br/>  paint_sorted -&gt; paint_rbt_sorted<br/>  paint_lookup -&gt; paint_rbt_lookup<br/>  paint_tree_greater -&gt; paint_rbt_greater<br/>  paint_tree_less -&gt; paint_rbt_less<br/>  sorted_entries -&gt; rbt_sorted_entries<br/>  tree_greater_eq_trans -&gt; rbt_greater_eq_trans<br/>  tree_greater_nit -&gt; rbt_greater_nit<br/>  tree_greater_prop -&gt; rbt_greater_prop<br/>  tree_greater_simps -&gt; rbt_greater_simps<br/>  tree_greater_trans -&gt; rbt_greater_trans<br/>  tree_less_eq_trans -&gt; rbt_less_eq_trans<br/>  tree_less_nit -&gt; rbt_less_nit<br/>  tree_less_prop -&gt; rbt_less_prop<br/>  tree_less_simps -&gt; rbt_less_simps<br/>  tree_less_trans -&gt; rbt_less_trans<br/>  tree_ord_props -&gt; rbt_ord_props<br/>  union_Branch -&gt; rbt_union_Branch<br/>  union_is_rbt -&gt; rbt_union_is_rbt<br/>  unionw_is_rbt -&gt; rbt_unionw_is_rbt<br/>  unionwk_is_rbt -&gt; rbt_unionwk_is_rbt<br/>  unionwk_sorted -&gt; rbt_unionwk_rbt_sorted<br/><br/>* Theory HOL/Library/Float: Floating point numbers are now defined as<br/>a subset of the real numbers.  All operations are defined using the<br/>lifing-framework and proofs use the transfer method.  INCOMPATIBILITY.<br/><br/>  Changed Operations:<br/>  float_abs -&gt; abs<br/>  float_nprt -&gt; nprt<br/>  float_pprt -&gt; pprt<br/>  pow2 -&gt; use powr<br/>  round_down -&gt; float_round_down<br/>  round_up -&gt; float_round_up<br/>  scale -&gt; exponent<br/><br/>  Removed Operations:<br/>  ceiling_fl, lb_mult, lb_mod, ub_mult, ub_mod<br/><br/>  Renamed Lemmas:<br/>  abs_float_def -&gt; Float.compute_float_abs<br/>  bitlen_ge0 -&gt; bitlen_nonneg<br/>  bitlen.simps -&gt; Float.compute_bitlen<br/>  float_components -&gt; Float_mantissa_exponent<br/>  float_divl.simps -&gt; Float.compute_float_divl<br/>  float_divr.simps -&gt; Float.compute_float_divr<br/>  float_eq_odd -&gt; mult_powr_eq_mult_powr_iff<br/>  float_power -&gt; real_of_float_power<br/>  lapprox_posrat_def -&gt; Float.compute_lapprox_posrat<br/>  lapprox_rat.simps -&gt; Float.compute_lapprox_rat<br/>  le_float_def&#39; -&gt; Float.compute_float_le<br/>  le_float_def -&gt; less_eq_float.rep_eq<br/>  less_float_def&#39; -&gt; Float.compute_float_less<br/>  less_float_def -&gt; less_float.rep_eq<br/>  normfloat_def -&gt; Float.compute_normfloat<br/>  normfloat_imp_odd_or_zero -&gt; mantissa_not_dvd and mantissa_noteq_0<br/>  normfloat -&gt; normfloat_def<br/>  normfloat_unique -&gt; use normfloat_def<br/>  number_of_float_Float -&gt; Float.compute_float_numeral, Float.compute_float_neg_numeral<br/>  one_float_def -&gt; Float.compute_float_one<br/>  plus_float_def -&gt; Float.compute_float_plus<br/>  rapprox_posrat_def -&gt; Float.compute_rapprox_posrat<br/>  rapprox_rat.simps -&gt; Float.compute_rapprox_rat<br/>  real_of_float_0 -&gt; zero_float.rep_eq<br/>  real_of_float_1 -&gt; one_float.rep_eq<br/>  real_of_float_abs -&gt; abs_float.rep_eq<br/>  real_of_float_add -&gt; plus_float.rep_eq<br/>  real_of_float_minus -&gt; uminus_float.rep_eq<br/>  real_of_float_mult -&gt; times_float.rep_eq<br/>  real_of_float_simp -&gt; Float.rep_eq<br/>  real_of_float_sub -&gt; minus_float.rep_eq<br/>  round_down.simps -&gt; Float.compute_float_round_down<br/>  round_up.simps -&gt; Float.compute_float_round_up<br/>  times_float_def -&gt; Float.compute_float_times<br/>  uminus_float_def -&gt; Float.compute_float_uminus<br/>  zero_float_def -&gt; Float.compute_float_zero<br/><br/>  Lemmas not necessary anymore, use the transfer method:<br/>  bitlen_B0, bitlen_B1, bitlen_ge1, bitlen_Min, bitlen_Pls, float_divl,<br/>  float_divr, float_le_simp, float_less1_mantissa_bound,<br/>  float_less_simp, float_less_zero, float_le_zero,<br/>  float_pos_less1_e_neg, float_pos_m_pos, float_split, float_split2,<br/>  floor_pos_exp, lapprox_posrat, lapprox_posrat_bottom, lapprox_rat,<br/>  lapprox_rat_bottom, normalized_float, rapprox_posrat,<br/>  rapprox_posrat_le1, rapprox_rat, real_of_float_ge0_exp,<br/>  real_of_float_neg_exp, real_of_float_nge0_exp, round_down floor_fl,<br/>  round_up, zero_le_float, zero_less_float<br/><br/>* New theory HOL/Library/DAList provides an abstract type for<br/>association lists with distinct keys.<br/><br/>* Session HOL/IMP: Added new theory of abstract interpretation of<br/>annotated commands.<br/><br/>* Session HOL-Import: Re-implementation from scratch is faster,<br/>simpler, and more scalable.  Requires a proof bundle, which is<br/>available as an external component.  Discontinued old (and mostly<br/>dead) Importer for HOL4 and HOL Light.  INCOMPATIBILITY.<br/><br/>* Session HOL-Word: Discontinued many redundant theorems specific to<br/>type &#39;a word. INCOMPATIBILITY, use the corresponding generic theorems<br/>instead.<br/><br/>  word_sub_alt ~&gt; word_sub_wi<br/>  word_add_alt ~&gt; word_add_def<br/>  word_mult_alt ~&gt; word_mult_def<br/>  word_minus_alt ~&gt; word_minus_def<br/>  word_0_alt ~&gt; word_0_wi<br/>  word_1_alt ~&gt; word_1_wi<br/>  word_add_0 ~&gt; add_0_left<br/>  word_add_0_right ~&gt; add_0_right<br/>  word_mult_1 ~&gt; mult_1_left<br/>  word_mult_1_right ~&gt; mult_1_right<br/>  word_add_commute ~&gt; add_commute<br/>  word_add_assoc ~&gt; add_assoc<br/>  word_add_left_commute ~&gt; add_left_commute<br/>  word_mult_commute ~&gt; mult_commute<br/>  word_mult_assoc ~&gt; mult_assoc<br/>  word_mult_left_commute ~&gt; mult_left_commute<br/>  word_left_distrib ~&gt; left_distrib<br/>  word_right_distrib ~&gt; right_distrib<br/>  word_left_minus ~&gt; left_minus<br/>  word_diff_0_right ~&gt; diff_0_right<br/>  word_diff_self ~&gt; diff_self<br/>  word_sub_def ~&gt; diff_minus<br/>  word_diff_minus ~&gt; diff_minus<br/>  word_add_ac ~&gt; add_ac<br/>  word_mult_ac ~&gt; mult_ac<br/>  word_plus_ac0 ~&gt; add_0_left add_0_right add_ac<br/>  word_times_ac1 ~&gt; mult_1_left mult_1_right mult_ac<br/>  word_order_trans ~&gt; order_trans<br/>  word_order_refl ~&gt; order_refl<br/>  word_order_antisym ~&gt; order_antisym<br/>  word_order_linear ~&gt; linorder_linear<br/>  lenw1_zero_neq_one ~&gt; zero_neq_one<br/>  word_number_of_eq ~&gt; number_of_eq<br/>  word_of_int_add_hom ~&gt; wi_hom_add<br/>  word_of_int_sub_hom ~&gt; wi_hom_sub<br/>  word_of_int_mult_hom ~&gt; wi_hom_mult<br/>  word_of_int_minus_hom ~&gt; wi_hom_neg<br/>  word_of_int_succ_hom ~&gt; wi_hom_succ<br/>  word_of_int_pred_hom ~&gt; wi_hom_pred<br/>  word_of_int_0_hom ~&gt; word_0_wi<br/>  word_of_int_1_hom ~&gt; word_1_wi<br/><br/>* Session HOL-Word: New proof method &quot;word_bitwise&quot; for splitting<br/>machine word equalities and inequalities into logical circuits,<br/>defined in HOL/Word/WordBitwise.thy.  Supports addition, subtraction,<br/>multiplication, shifting by constants, bitwise operators and numeric<br/>constants.  Requires fixed-length word types, not &#39;a word.  Solves<br/>many standard word identities outright and converts more into first<br/>order problems amenable to blast or similar.  See also examples in<br/>HOL/Word/Examples/WordExamples.thy.<br/><br/>* Session HOL-Probability: Introduced the type &quot;&#39;a measure&quot; to<br/>represent measures, this replaces the records &#39;a algebra and &#39;a<br/>measure_space.  The locales based on subset_class now have two<br/>locale-parameters the space Ω and the set of measurable sets M.<br/>The product of probability spaces uses now the same constant as the<br/>finite product of sigma-finite measure spaces &quot;PiM :: (&#39;i =&gt; &#39;a)<br/>measure&quot;.  Most constants are defined now outside of locales and gain<br/>an additional parameter, like null_sets, almost_eventually or μ&#39;.<br/>Measure space constructions for distributions and densities now got<br/>their own constants distr and density.  Instead of using locales to<br/>describe measure spaces with a finite space, the measure count_space<br/>and point_measure is introduced.  INCOMPATIBILITY.<br/><br/>  Renamed constants:<br/>  measure -&gt; emeasure<br/>  finite_measure.μ&#39; -&gt; measure<br/>  product_algebra_generator -&gt; prod_algebra<br/>  product_prob_space.emb -&gt; prod_emb<br/>  product_prob_space.infprod_algebra -&gt; PiM<br/><br/>  Removed locales:<br/>  completeable_measure_space<br/>  finite_measure_space<br/>  finite_prob_space<br/>  finite_product_finite_prob_space<br/>  finite_product_sigma_algebra<br/>  finite_sigma_algebra<br/>  measure_space<br/>  pair_finite_prob_space<br/>  pair_finite_sigma_algebra<br/>  pair_finite_space<br/>  pair_sigma_algebra<br/>  product_sigma_algebra<br/><br/>  Removed constants:<br/>  conditional_space<br/>  distribution -&gt; use distr measure, or distributed predicate<br/>  image_space<br/>  joint_distribution -&gt; use distr measure, or distributed predicate<br/>  pair_measure_generator<br/>  product_prob_space.infprod_algebra -&gt; use PiM<br/>  subvimage<br/><br/>  Replacement theorems:<br/>  finite_additivity_sufficient -&gt; ring_of_sets.countably_additiveI_finite<br/>  finite_measure.empty_measure -&gt; measure_empty<br/>  finite_measure.finite_continuity_from_above -&gt; finite_measure.finite_Lim_measure_decseq<br/>  finite_measure.finite_continuity_from_below -&gt; finite_measure.finite_Lim_measure_incseq<br/>  finite_measure.finite_measure_countably_subadditive -&gt; finite_measure.finite_measure_subadditive_countably<br/>  finite_measure.finite_measure_eq -&gt; finite_measure.emeasure_eq_measure<br/>  finite_measure.finite_measure -&gt; finite_measure.emeasure_finite<br/>  finite_measure.finite_measure_finite_singleton -&gt; finite_measure.finite_measure_eq_setsum_singleton<br/>  finite_measure.positive_measure&#39; -&gt; measure_nonneg<br/>  finite_measure.real_measure -&gt; finite_measure.emeasure_real<br/>  finite_product_prob_space.finite_measure_times -&gt; finite_product_prob_space.finite_measure_PiM_emb<br/>  finite_product_sigma_algebra.in_P -&gt; sets_PiM_I_finite<br/>  finite_product_sigma_algebra.P_empty -&gt; space_PiM_empty, sets_PiM_empty<br/>  information_space.conditional_entropy_eq -&gt; information_space.conditional_entropy_simple_distributed<br/>  information_space.conditional_entropy_positive -&gt; information_space.conditional_entropy_nonneg_simple<br/>  information_space.conditional_mutual_information_eq_mutual_information -&gt; information_space.conditional_mutual_information_eq_mutual_information_simple<br/>  information_space.conditional_mutual_information_generic_positive -&gt; information_space.conditional_mutual_information_nonneg_simple<br/>  information_space.conditional_mutual_information_positive -&gt; information_space.conditional_mutual_information_nonneg_simple<br/>  information_space.entropy_commute -&gt; information_space.entropy_commute_simple<br/>  information_space.entropy_eq -&gt; information_space.entropy_simple_distributed<br/>  information_space.entropy_generic_eq -&gt; information_space.entropy_simple_distributed<br/>  information_space.entropy_positive -&gt; information_space.entropy_nonneg_simple<br/>  information_space.entropy_uniform_max -&gt; information_space.entropy_uniform<br/>  information_space.KL_eq_0_imp -&gt; information_space.KL_eq_0_iff_eq<br/>  information_space.KL_eq_0 -&gt; information_space.KL_same_eq_0<br/>  information_space.KL_ge_0 -&gt; information_space.KL_nonneg<br/>  information_space.mutual_information_eq -&gt; information_space.mutual_information_simple_distributed<br/>  information_space.mutual_information_positive -&gt; information_space.mutual_information_nonneg_simple<br/>  Int_stable_cuboids -&gt; Int_stable_atLeastAtMost<br/>  Int_stable_product_algebra_generator -&gt; positive_integral<br/>  measure_preserving -&gt; equality &quot;distr M N f = N&quot; &quot;f : measurable M N&quot;<br/>  measure_space.additive -&gt; emeasure_additive<br/>  measure_space.AE_iff_null_set -&gt; AE_iff_null<br/>  measure_space.almost_everywhere_def -&gt; eventually_ae_filter<br/>  measure_space.almost_everywhere_vimage -&gt; AE_distrD<br/>  measure_space.continuity_from_above -&gt; INF_emeasure_decseq<br/>  measure_space.continuity_from_above_Lim -&gt; Lim_emeasure_decseq<br/>  measure_space.continuity_from_below_Lim -&gt; Lim_emeasure_incseq<br/>  measure_space.continuity_from_below -&gt; SUP_emeasure_incseq<br/>  measure_space_density -&gt; emeasure_density<br/>  measure_space.density_is_absolutely_continuous -&gt; absolutely_continuousI_density<br/>  measure_space.integrable_vimage -&gt; integrable_distr<br/>  measure_space.integral_translated_density -&gt; integral_density<br/>  measure_space.integral_vimage -&gt; integral_distr<br/>  measure_space.measure_additive -&gt; plus_emeasure<br/>  measure_space.measure_compl -&gt; emeasure_compl<br/>  measure_space.measure_countable_increasing -&gt; emeasure_countable_increasing<br/>  measure_space.measure_countably_subadditive -&gt; emeasure_subadditive_countably<br/>  measure_space.measure_decseq -&gt; decseq_emeasure<br/>  measure_space.measure_Diff -&gt; emeasure_Diff<br/>  measure_space.measure_Diff_null_set -&gt; emeasure_Diff_null_set<br/>  measure_space.measure_eq_0 -&gt; emeasure_eq_0<br/>  measure_space.measure_finitely_subadditive -&gt; emeasure_subadditive_finite<br/>  measure_space.measure_finite_singleton -&gt; emeasure_eq_setsum_singleton<br/>  measure_space.measure_incseq -&gt; incseq_emeasure<br/>  measure_space.measure_insert -&gt; emeasure_insert<br/>  measure_space.measure_mono -&gt; emeasure_mono<br/>  measure_space.measure_not_negative -&gt; emeasure_not_MInf<br/>  measure_space.measure_preserving_Int_stable -&gt; measure_eqI_generator_eq<br/>  measure_space.measure_setsum -&gt; setsum_emeasure<br/>  measure_space.measure_setsum_split -&gt; setsum_emeasure_cover<br/>  measure_space.measure_space_vimage -&gt; emeasure_distr<br/>  measure_space.measure_subadditive_finite -&gt; emeasure_subadditive_finite<br/>  measure_space.measure_subadditive -&gt; subadditive<br/>  measure_space.measure_top -&gt; emeasure_space<br/>  measure_space.measure_UN_eq_0 -&gt; emeasure_UN_eq_0<br/>  measure_space.measure_Un_null_set -&gt; emeasure_Un_null_set<br/>  measure_space.positive_integral_translated_density -&gt; positive_integral_density<br/>  measure_space.positive_integral_vimage -&gt; positive_integral_distr<br/>  measure_space.real_continuity_from_above -&gt; Lim_measure_decseq<br/>  measure_space.real_continuity_from_below -&gt; Lim_measure_incseq<br/>  measure_space.real_measure_countably_subadditive -&gt; measure_subadditive_countably<br/>  measure_space.real_measure_Diff -&gt; measure_Diff<br/>  measure_space.real_measure_finite_Union -&gt; measure_finite_Union<br/>  measure_space.real_measure_setsum_singleton -&gt; measure_eq_setsum_singleton<br/>  measure_space.real_measure_subadditive -&gt; measure_subadditive<br/>  measure_space.real_measure_Union -&gt; measure_Union<br/>  measure_space.real_measure_UNION -&gt; measure_UNION<br/>  measure_space.simple_function_vimage -&gt; simple_function_comp<br/>  measure_space.simple_integral_vimage -&gt; simple_integral_distr<br/>  measure_space.simple_integral_vimage -&gt; simple_integral_distr<br/>  measure_unique_Int_stable -&gt; measure_eqI_generator_eq<br/>  measure_unique_Int_stable_vimage -&gt; measure_eqI_generator_eq<br/>  pair_sigma_algebra.measurable_cut_fst -&gt; sets_Pair1<br/>  pair_sigma_algebra.measurable_cut_snd -&gt; sets_Pair2<br/>  pair_sigma_algebra.measurable_pair_image_fst -&gt; measurable_Pair1<br/>  pair_sigma_algebra.measurable_pair_image_snd -&gt; measurable_Pair2<br/>  pair_sigma_algebra.measurable_product_swap -&gt; measurable_pair_swap_iff<br/>  pair_sigma_algebra.pair_sigma_algebra_measurable -&gt; measurable_pair_swap<br/>  pair_sigma_algebra.pair_sigma_algebra_swap_measurable -&gt; measurable_pair_swap&#39;<br/>  pair_sigma_algebra.sets_swap -&gt; sets_pair_swap<br/>  pair_sigma_finite.measure_cut_measurable_fst -&gt; pair_sigma_finite.measurable_emeasure_Pair1<br/>  pair_sigma_finite.measure_cut_measurable_snd -&gt; pair_sigma_finite.measurable_emeasure_Pair2<br/>  pair_sigma_finite.measure_preserving_swap -&gt; pair_sigma_finite.distr_pair_swap<br/>  pair_sigma_finite.pair_measure_alt2 -&gt; pair_sigma_finite.emeasure_pair_measure_alt2<br/>  pair_sigma_finite.pair_measure_alt -&gt; pair_sigma_finite.emeasure_pair_measure_alt<br/>  pair_sigma_finite.pair_measure_times -&gt; pair_sigma_finite.emeasure_pair_measure_Times<br/>  prob_space.indep_distribution_eq_measure -&gt; prob_space.indep_vars_iff_distr_eq_PiM<br/>  prob_space.indep_var_distributionD -&gt; prob_space.indep_var_distribution_eq<br/>  prob_space.measure_space_1 -&gt; prob_space.emeasure_space_1<br/>  prob_space.prob_space_vimage -&gt; prob_space_distr<br/>  prob_space.random_variable_restrict -&gt; measurable_restrict<br/>  prob_space_unique_Int_stable -&gt; measure_eqI_prob_space<br/>  product_algebraE -&gt; prod_algebraE_all<br/>  product_algebra_generator_der -&gt; prod_algebra_eq_finite<br/>  product_algebra_generator_into_space -&gt; prod_algebra_sets_into_space<br/>  product_algebraI -&gt; sets_PiM_I_finite<br/>  product_measure_exists -&gt; product_sigma_finite.sigma_finite<br/>  product_prob_space.finite_index_eq_finite_product -&gt; product_prob_space.sets_PiM_generator<br/>  product_prob_space.finite_measure_infprod_emb_Pi -&gt; product_prob_space.measure_PiM_emb<br/>  product_prob_space.infprod_spec -&gt; product_prob_space.emeasure_PiM_emb_not_empty<br/>  product_prob_space.measurable_component -&gt; measurable_component_singleton<br/>  product_prob_space.measurable_emb -&gt; measurable_prod_emb<br/>  product_prob_space.measurable_into_infprod_algebra -&gt; measurable_PiM_single<br/>  product_prob_space.measurable_singleton_infprod -&gt; measurable_component_singleton<br/>  product_prob_space.measure_emb -&gt; emeasure_prod_emb<br/>  product_prob_space.measure_preserving_restrict -&gt; product_prob_space.distr_restrict<br/>  product_sigma_algebra.product_algebra_into_space -&gt; space_closed<br/>  product_sigma_finite.measure_fold -&gt; product_sigma_finite.distr_merge<br/>  product_sigma_finite.measure_preserving_component_singelton -&gt; product_sigma_finite.distr_singleton<br/>  product_sigma_finite.measure_preserving_merge -&gt; product_sigma_finite.distr_merge<br/>  sequence_space.measure_infprod -&gt; sequence_space.measure_PiM_countable<br/>  sets_product_algebra -&gt; sets_PiM<br/>  sigma_algebra.measurable_sigma -&gt; measurable_measure_of<br/>  sigma_finite_measure.disjoint_sigma_finite -&gt; sigma_finite_disjoint<br/>  sigma_finite_measure.RN_deriv_vimage -&gt; sigma_finite_measure.RN_deriv_distr<br/>  sigma_product_algebra_sigma_eq -&gt; sigma_prod_algebra_sigma_eq<br/>  space_product_algebra -&gt; space_PiM<br/><br/>* Session HOL-TPTP: support to parse and import TPTP problems (all<br/>languages) into Isabelle/HOL.<br/><br/><br/>*** FOL ***<br/><br/>* New &quot;case_product&quot; attribute (see HOL).<br/><br/><br/>*** ZF ***<br/><br/>* Greater support for structured proofs involving induction or case<br/>analysis.<br/><br/>* Much greater use of mathematical symbols.<br/><br/>* Removal of many ML theorem bindings.  INCOMPATIBILITY.<br/><br/><br/>*** ML ***<br/><br/>* Antiquotation @{keyword &quot;name&quot;} produces a parser for outer syntax<br/>from a minor keyword introduced via theory header declaration.<br/><br/>* Antiquotation @{command_spec &quot;name&quot;} produces the<br/>Outer_Syntax.command_spec from a major keyword introduced via theory<br/>header declaration; it can be passed to Outer_Syntax.command etc.<br/><br/>* Local_Theory.define no longer hard-wires default theorem name<br/>&quot;foo_def&quot;, but retains the binding as given.  If that is Binding.empty<br/>/ Attrib.empty_binding, the result is not registered as user-level<br/>fact.  The Local_Theory.define_internal variant allows to specify a<br/>non-empty name (used for the foundation in the background theory),<br/>while omitting the fact binding in the user-context.  Potential<br/>INCOMPATIBILITY for derived definitional packages: need to specify<br/>naming policy for primitive definitions more explicitly.<br/><br/>* Renamed Thm.capply to Thm.apply, and Thm.cabs to Thm.lambda in<br/>conformance with similar operations in structure Term and Logic.<br/><br/>* Antiquotation @{attributes [...]} embeds attribute source<br/>representation into the ML text, which is particularly useful with<br/>declarations like Local_Theory.note.<br/><br/>* Structure Proof_Context follows standard naming scheme.  Old<br/>ProofContext has been discontinued.  INCOMPATIBILITY.<br/><br/>* Refined Local_Theory.declaration {syntax, pervasive}, with subtle<br/>change of semantics: update is applied to auxiliary local theory<br/>context as well.<br/><br/>* Modernized some old-style infix operations:<br/><br/>  addeqcongs    ~&gt; Simplifier.add_eqcong<br/>  deleqcongs    ~&gt; Simplifier.del_eqcong<br/>  addcongs      ~&gt; Simplifier.add_cong<br/>  delcongs      ~&gt; Simplifier.del_cong<br/>  setmksimps    ~&gt; Simplifier.set_mksimps<br/>  setmkcong     ~&gt; Simplifier.set_mkcong<br/>  setmksym      ~&gt; Simplifier.set_mksym<br/>  setmkeqTrue   ~&gt; Simplifier.set_mkeqTrue<br/>  settermless   ~&gt; Simplifier.set_termless<br/>  setsubgoaler  ~&gt; Simplifier.set_subgoaler<br/>  addsplits     ~&gt; Splitter.add_split<br/>  delsplits     ~&gt; Splitter.del_split<br/><br/><br/>*** System ***<br/><br/>* USER_HOME settings variable points to cross-platform user home<br/>directory, which coincides with HOME on POSIX systems only.  Likewise,<br/>the Isabelle path specification &quot;~&quot; now expands to $USER_HOME, instead<br/>of former $HOME.  A different default for USER_HOME may be set<br/>explicitly in shell environment, before Isabelle settings are<br/>evaluated.  Minor INCOMPATIBILITY: need to adapt Isabelle path where<br/>the generic user home was intended.<br/><br/>* ISABELLE_HOME_WINDOWS refers to ISABELLE_HOME in windows file name<br/>notation, which is useful for the jEdit file browser, for example.<br/><br/>* ISABELLE_JDK_HOME settings variable points to JDK with javac and jar<br/>(not just JRE).<br/><br/><br/><br/>New in Isabelle2011-1 (October 2011)<br/>------------------------------------<br/><br/>*** General ***<br/><br/>* Improved Isabelle/jEdit Prover IDE (PIDE), which can be invoked as<br/>&quot;isabelle jedit&quot; or &quot;ISABELLE_HOME/Isabelle&quot; on the command line.<br/><br/>  - Management of multiple theory files directly from the editor<br/>    buffer store -- bypassing the file-system (no requirement to save<br/>    files for checking).<br/><br/>  - Markup of formal entities within the text buffer, with semantic<br/>    highlighting, tooltips and hyperlinks to jump to defining source<br/>    positions.<br/><br/>  - Improved text rendering, with sub/superscripts in the source<br/>    buffer (including support for copy/paste wrt. output panel, HTML<br/>    theory output and other non-Isabelle text boxes).<br/><br/>  - Refined scheduling of proof checking and printing of results,<br/>    based on interactive editor view.  (Note: jEdit folding and<br/>    narrowing allows to restrict buffer perspectives explicitly.)<br/><br/>  - Reduced CPU performance requirements, usable on machines with few<br/>    cores.<br/><br/>  - Reduced memory requirements due to pruning of unused document<br/>    versions (garbage collection).<br/><br/>See also ~~/src/Tools/jEdit/README.html for further information,<br/>including some remaining limitations.<br/><br/>* Theory loader: source files are exclusively located via the master<br/>directory of each theory node (where the .thy file itself resides).<br/>The global load path (such as src/HOL/Library) has been discontinued.<br/>Note that the path element ~~ may be used to reference theories in the<br/>Isabelle home folder -- for instance, &quot;~~/src/HOL/Library/FuncSet&quot;.<br/>INCOMPATIBILITY.<br/><br/>* Theory loader: source files are identified by content via SHA1<br/>digests.  Discontinued former path/modtime identification and optional<br/>ISABELLE_FILE_IDENT plugin scripts.<br/><br/>* Parallelization of nested Isar proofs is subject to<br/>Goal.parallel_proofs_threshold (default 100).  See also isabelle<br/>usedir option -Q.<br/><br/>* Name space: former unsynchronized references are now proper<br/>configuration options, with more conventional names:<br/><br/>  long_names   ~&gt; names_long<br/>  short_names  ~&gt; names_short<br/>  unique_names ~&gt; names_unique<br/><br/>Minor INCOMPATIBILITY, need to declare options in context like this:<br/><br/>  declare [[names_unique = false]]<br/><br/>* Literal facts `prop` may contain dummy patterns, e.g. `_ = _`.  Note<br/>that the result needs to be unique, which means fact specifications<br/>may have to be refined after enriching a proof context.<br/><br/>* Attribute &quot;case_names&quot; has been refined: the assumptions in each case<br/>can be named now by following the case name with [name1 name2 ...].<br/><br/>* Isabelle/Isar reference manual has been updated and extended:<br/>  - &quot;Synopsis&quot; provides a catalog of main Isar language concepts.<br/>  - Formal references in syntax diagrams, via @{rail} antiquotation.<br/>  - Updated material from classic &quot;ref&quot; manual, notably about<br/>    &quot;Classical Reasoner&quot;.<br/><br/><br/>*** HOL ***<br/><br/>* Class bot and top require underlying partial order rather than<br/>preorder: uniqueness of bot and top is guaranteed.  INCOMPATIBILITY.<br/><br/>* Class complete_lattice: generalized a couple of lemmas from sets;<br/>generalized theorems INF_cong and SUP_cong.  New type classes for<br/>complete boolean algebras and complete linear orders.  Lemmas<br/>Inf_less_iff, less_Sup_iff, INF_less_iff, less_SUP_iff now reside in<br/>class complete_linorder.<br/><br/>Changed proposition of lemmas Inf_bool_def, Sup_bool_def, Inf_fun_def,<br/>Sup_fun_def, Inf_apply, Sup_apply.<br/><br/>Removed redundant lemmas (the right hand side gives hints how to<br/>replace them for (metis ...), or (simp only: ...) proofs):<br/><br/>  Inf_singleton ~&gt; Inf_insert [where A=&quot;{}&quot;, unfolded Inf_empty inf_top_right]<br/>  Sup_singleton ~&gt; Sup_insert [where A=&quot;{}&quot;, unfolded Sup_empty sup_bot_right]<br/>  Inf_binary ~&gt; Inf_insert, Inf_empty, and inf_top_right<br/>  Sup_binary ~&gt; Sup_insert, Sup_empty, and sup_bot_right<br/>  Int_eq_Inter ~&gt; Inf_insert, Inf_empty, and inf_top_right<br/>  Un_eq_Union ~&gt; Sup_insert, Sup_empty, and sup_bot_right<br/>  Inter_def ~&gt; INF_def, image_def<br/>  Union_def ~&gt; SUP_def, image_def<br/>  INT_eq ~&gt; INF_def, and image_def<br/>  UN_eq ~&gt; SUP_def, and image_def<br/>  INF_subset ~&gt; INF_superset_mono [OF _ order_refl]<br/><br/>More consistent and comprehensive names:<br/><br/>  INTER_eq_Inter_image ~&gt; INF_def<br/>  UNION_eq_Union_image ~&gt; SUP_def<br/>  INFI_def ~&gt; INF_def<br/>  SUPR_def ~&gt; SUP_def<br/>  INF_leI ~&gt; INF_lower<br/>  INF_leI2 ~&gt; INF_lower2<br/>  le_INFI ~&gt; INF_greatest<br/>  le_SUPI ~&gt; SUP_upper<br/>  le_SUPI2 ~&gt; SUP_upper2<br/>  SUP_leI ~&gt; SUP_least<br/>  INFI_bool_eq ~&gt; INF_bool_eq<br/>  SUPR_bool_eq ~&gt; SUP_bool_eq<br/>  INFI_apply ~&gt; INF_apply<br/>  SUPR_apply ~&gt; SUP_apply<br/>  INTER_def ~&gt; INTER_eq<br/>  UNION_def ~&gt; UNION_eq<br/><br/>INCOMPATIBILITY.<br/><br/>* Renamed theory Complete_Lattice to Complete_Lattices.<br/>INCOMPATIBILITY.<br/><br/>* Theory Complete_Lattices: lemmas Inf_eq_top_iff, INF_eq_top_iff,<br/>INF_image, Inf_insert, INF_top, Inf_top_conv, INF_top_conv, SUP_bot,<br/>Sup_bot_conv, SUP_bot_conv, Sup_eq_top_iff, SUP_eq_top_iff, SUP_image,<br/>Sup_insert are now declared as [simp].  INCOMPATIBILITY.<br/><br/>* Theory Lattice: lemmas compl_inf_bot, compl_le_comp_iff,<br/>compl_sup_top, inf_idem, inf_left_idem, inf_sup_absorb, sup_idem,<br/>sup_inf_absob, sup_left_idem are now declared as [simp].  Minor<br/>INCOMPATIBILITY.<br/><br/>* Added syntactic classes &quot;inf&quot; and &quot;sup&quot; for the respective<br/>constants.  INCOMPATIBILITY: Changes in the argument order of the<br/>(mostly internal) locale predicates for some derived classes.<br/><br/>* Theorem collections ball_simps and bex_simps do not contain theorems<br/>referring to UNION any longer; these have been moved to collection<br/>UN_ball_bex_simps.  INCOMPATIBILITY.<br/><br/>* Theory Archimedean_Field: floor now is defined as parameter of a<br/>separate type class floor_ceiling.<br/><br/>* Theory Finite_Set: more coherent development of fold_set locales:<br/><br/>    locale fun_left_comm ~&gt; locale comp_fun_commute<br/>    locale fun_left_comm_idem ~&gt; locale comp_fun_idem<br/><br/>Both use point-free characterization; interpretation proofs may need<br/>adjustment.  INCOMPATIBILITY.<br/><br/>* Theory Limits: Type &quot;&#39;a net&quot; has been renamed to &quot;&#39;a filter&quot;, in<br/>accordance with standard mathematical terminology. INCOMPATIBILITY.<br/><br/>* Theory Complex_Main: The locale interpretations for the<br/>bounded_linear and bounded_bilinear locales have been removed, in<br/>order to reduce the number of duplicate lemmas. Users must use the<br/>original names for distributivity theorems, potential INCOMPATIBILITY.<br/><br/>  divide.add ~&gt; add_divide_distrib<br/>  divide.diff ~&gt; diff_divide_distrib<br/>  divide.setsum ~&gt; setsum_divide_distrib<br/>  mult.add_right ~&gt; right_distrib<br/>  mult.diff_right ~&gt; right_diff_distrib<br/>  mult_right.setsum ~&gt; setsum_right_distrib<br/>  mult_left.diff ~&gt; left_diff_distrib<br/><br/>* Theory Complex_Main: Several redundant theorems have been removed or<br/>replaced by more general versions. INCOMPATIBILITY.<br/><br/>  real_diff_def ~&gt; minus_real_def<br/>  real_divide_def ~&gt; divide_real_def<br/>  real_less_def ~&gt; less_le<br/>  real_abs_def ~&gt; abs_real_def<br/>  real_sgn_def ~&gt; sgn_real_def<br/>  real_mult_commute ~&gt; mult_commute<br/>  real_mult_assoc ~&gt; mult_assoc<br/>  real_mult_1 ~&gt; mult_1_left<br/>  real_add_mult_distrib ~&gt; left_distrib<br/>  real_zero_not_eq_one ~&gt; zero_neq_one<br/>  real_mult_inverse_left ~&gt; left_inverse<br/>  INVERSE_ZERO ~&gt; inverse_zero<br/>  real_le_refl ~&gt; order_refl<br/>  real_le_antisym ~&gt; order_antisym<br/>  real_le_trans ~&gt; order_trans<br/>  real_le_linear ~&gt; linear<br/>  real_le_eq_diff ~&gt; le_iff_diff_le_0<br/>  real_add_left_mono ~&gt; add_left_mono<br/>  real_mult_order ~&gt; mult_pos_pos<br/>  real_mult_less_mono2 ~&gt; mult_strict_left_mono<br/>  real_of_int_real_of_nat ~&gt; real_of_int_of_nat_eq<br/>  real_0_le_divide_iff ~&gt; zero_le_divide_iff<br/>  realpow_two_disj ~&gt; power2_eq_iff<br/>  real_squared_diff_one_factored ~&gt; square_diff_one_factored<br/>  realpow_two_diff ~&gt; square_diff_square_factored<br/>  reals_complete2 ~&gt; complete_real<br/>  real_sum_squared_expand ~&gt; power2_sum<br/>  exp_ln_eq ~&gt; ln_unique<br/>  expi_add ~&gt; exp_add<br/>  expi_zero ~&gt; exp_zero<br/>  lemma_DERIV_subst ~&gt; DERIV_cong<br/>  LIMSEQ_Zfun_iff ~&gt; tendsto_Zfun_iff<br/>  LIMSEQ_const ~&gt; tendsto_const<br/>  LIMSEQ_norm ~&gt; tendsto_norm<br/>  LIMSEQ_add ~&gt; tendsto_add<br/>  LIMSEQ_minus ~&gt; tendsto_minus<br/>  LIMSEQ_minus_cancel ~&gt; tendsto_minus_cancel<br/>  LIMSEQ_diff ~&gt; tendsto_diff<br/>  bounded_linear.LIMSEQ ~&gt; bounded_linear.tendsto<br/>  bounded_bilinear.LIMSEQ ~&gt; bounded_bilinear.tendsto<br/>  LIMSEQ_mult ~&gt; tendsto_mult<br/>  LIMSEQ_inverse ~&gt; tendsto_inverse<br/>  LIMSEQ_divide ~&gt; tendsto_divide<br/>  LIMSEQ_pow ~&gt; tendsto_power<br/>  LIMSEQ_setsum ~&gt; tendsto_setsum<br/>  LIMSEQ_setprod ~&gt; tendsto_setprod<br/>  LIMSEQ_norm_zero ~&gt; tendsto_norm_zero_iff<br/>  LIMSEQ_rabs_zero ~&gt; tendsto_rabs_zero_iff<br/>  LIMSEQ_imp_rabs ~&gt; tendsto_rabs<br/>  LIMSEQ_add_minus ~&gt; tendsto_add [OF _ tendsto_minus]<br/>  LIMSEQ_add_const ~&gt; tendsto_add [OF _ tendsto_const]<br/>  LIMSEQ_diff_const ~&gt; tendsto_diff [OF _ tendsto_const]<br/>  LIMSEQ_Complex ~&gt; tendsto_Complex<br/>  LIM_ident ~&gt; tendsto_ident_at<br/>  LIM_const ~&gt; tendsto_const<br/>  LIM_add ~&gt; tendsto_add<br/>  LIM_add_zero ~&gt; tendsto_add_zero<br/>  LIM_minus ~&gt; tendsto_minus<br/>  LIM_diff ~&gt; tendsto_diff<br/>  LIM_norm ~&gt; tendsto_norm<br/>  LIM_norm_zero ~&gt; tendsto_norm_zero<br/>  LIM_norm_zero_cancel ~&gt; tendsto_norm_zero_cancel<br/>  LIM_norm_zero_iff ~&gt; tendsto_norm_zero_iff<br/>  LIM_rabs ~&gt; tendsto_rabs<br/>  LIM_rabs_zero ~&gt; tendsto_rabs_zero<br/>  LIM_rabs_zero_cancel ~&gt; tendsto_rabs_zero_cancel<br/>  LIM_rabs_zero_iff ~&gt; tendsto_rabs_zero_iff<br/>  LIM_compose ~&gt; tendsto_compose<br/>  LIM_mult ~&gt; tendsto_mult<br/>  LIM_scaleR ~&gt; tendsto_scaleR<br/>  LIM_of_real ~&gt; tendsto_of_real<br/>  LIM_power ~&gt; tendsto_power<br/>  LIM_inverse ~&gt; tendsto_inverse<br/>  LIM_sgn ~&gt; tendsto_sgn<br/>  isCont_LIM_compose ~&gt; isCont_tendsto_compose<br/>  bounded_linear.LIM ~&gt; bounded_linear.tendsto<br/>  bounded_linear.LIM_zero ~&gt; bounded_linear.tendsto_zero<br/>  bounded_bilinear.LIM ~&gt; bounded_bilinear.tendsto<br/>  bounded_bilinear.LIM_prod_zero ~&gt; bounded_bilinear.tendsto_zero<br/>  bounded_bilinear.LIM_left_zero ~&gt; bounded_bilinear.tendsto_left_zero<br/>  bounded_bilinear.LIM_right_zero ~&gt; bounded_bilinear.tendsto_right_zero<br/>  LIM_inverse_fun ~&gt; tendsto_inverse [OF tendsto_ident_at]<br/><br/>* Theory Complex_Main: The definition of infinite series was<br/>generalized.  Now it is defined on the type class {topological_space,<br/>comm_monoid_add}.  Hence it is useable also for extended real numbers.<br/><br/>* Theory Complex_Main: The complex exponential function &quot;expi&quot; is now<br/>a type-constrained abbreviation for &quot;exp :: complex =&gt; complex&quot;; thus<br/>several polymorphic lemmas about &quot;exp&quot; are now applicable to &quot;expi&quot;.<br/><br/>* Code generation:<br/><br/>  - Theory Library/Code_Char_ord provides native ordering of<br/>    characters in the target language.<br/><br/>  - Commands code_module and code_library are legacy, use export_code<br/>    instead.<br/><br/>  - Method &quot;evaluation&quot; is legacy, use method &quot;eval&quot; instead.<br/><br/>  - Legacy evaluator &quot;SML&quot; is deactivated by default.  May be<br/>    reactivated by the following theory command:<br/><br/>      setup {* Value.add_evaluator (&quot;SML&quot;, Codegen.eval_term) *}<br/><br/>* Declare ext [intro] by default.  Rare INCOMPATIBILITY.<br/><br/>* New proof method &quot;induction&quot; that gives induction hypotheses the<br/>name &quot;IH&quot;, thus distinguishing them from further hypotheses that come<br/>from rule induction.  The latter are still called &quot;hyps&quot;.  Method<br/>&quot;induction&quot; is a thin wrapper around &quot;induct&quot; and follows the same<br/>syntax.<br/><br/>* Method &quot;fastsimp&quot; has been renamed to &quot;fastforce&quot;, but &quot;fastsimp&quot; is<br/>still available as a legacy feature for some time.<br/><br/>* Nitpick:<br/>  - Added &quot;need&quot; and &quot;total_consts&quot; options.<br/>  - Reintroduced &quot;show_skolems&quot; option by popular demand.<br/>  - Renamed attribute: nitpick_def ~&gt; nitpick_unfold.<br/>    INCOMPATIBILITY.<br/><br/>* Sledgehammer:<br/>  - Use quasi-sound (and efficient) translations by default.<br/>  - Added support for the following provers: E-ToFoF, LEO-II,<br/>    Satallax, SNARK, Waldmeister, and Z3 with TPTP syntax.<br/>  - Automatically preplay and minimize proofs before showing them if<br/>    this can be done within reasonable time.<br/>  - sledgehammer available_provers ~&gt; sledgehammer supported_provers.<br/>    INCOMPATIBILITY.<br/>  - Added &quot;preplay_timeout&quot;, &quot;slicing&quot;, &quot;type_enc&quot;, &quot;sound&quot;,<br/>    &quot;max_mono_iters&quot;, and &quot;max_new_mono_instances&quot; options.<br/>  - Removed &quot;explicit_apply&quot; and &quot;full_types&quot; options as well as &quot;Full<br/>    Types&quot; Proof General menu item. INCOMPATIBILITY.<br/><br/>* Metis:<br/>  - Removed &quot;metisF&quot; -- use &quot;metis&quot; instead. INCOMPATIBILITY.<br/>  - Obsoleted &quot;metisFT&quot; -- use &quot;metis (full_types)&quot; instead.<br/>    INCOMPATIBILITY.<br/><br/>* Command &#39;try&#39;:<br/>  - Renamed &#39;try_methods&#39; and added &quot;simp:&quot;, &quot;intro:&quot;, &quot;dest:&quot;, and<br/>    &quot;elim:&quot; options. INCOMPATIBILITY.<br/>  - Introduced &#39;try&#39; that not only runs &#39;try_methods&#39; but also<br/>    &#39;solve_direct&#39;, &#39;sledgehammer&#39;, &#39;quickcheck&#39;, and &#39;nitpick&#39;.<br/><br/>* Quickcheck:<br/>  - Added &quot;eval&quot; option to evaluate terms for the found counterexample<br/>    (currently only supported by the default (exhaustive) tester).<br/>  - Added post-processing of terms to obtain readable counterexamples<br/>    (currently only supported by the default (exhaustive) tester).<br/>  - New counterexample generator quickcheck[narrowing] enables<br/>    narrowing-based testing.  Requires the Glasgow Haskell compiler<br/>    with its installation location defined in the Isabelle settings<br/>    environment as ISABELLE_GHC.<br/>  - Removed quickcheck tester &quot;SML&quot; based on the SML code generator<br/>    (formly in HOL/Library).<br/><br/>* Function package: discontinued option &quot;tailrec&quot;.  INCOMPATIBILITY,<br/>use &#39;partial_function&#39; instead.<br/><br/>* Theory Library/Extended_Reals replaces now the positive extended<br/>reals found in probability theory. This file is extended by<br/>Multivariate_Analysis/Extended_Real_Limits.<br/><br/>* Theory Library/Old_Recdef: old &#39;recdef&#39; package has been moved here,<br/>from where it must be imported explicitly if it is really required.<br/>INCOMPATIBILITY.<br/><br/>* Theory Library/Wfrec: well-founded recursion combinator &quot;wfrec&quot; has<br/>been moved here.  INCOMPATIBILITY.<br/><br/>* Theory Library/Saturated provides type of numbers with saturated<br/>arithmetic.<br/><br/>* Theory Library/Product_Lattice defines a pointwise ordering for the<br/>product type &#39;a * &#39;b, and provides instance proofs for various order<br/>and lattice type classes.<br/><br/>* Theory Library/Countable now provides the &quot;countable_datatype&quot; proof<br/>method for proving &quot;countable&quot; class instances for datatypes.<br/><br/>* Theory Library/Cset_Monad allows do notation for computable sets<br/>(cset) via the generic monad ad-hoc overloading facility.<br/><br/>* Library: Theories of common data structures are split into theories<br/>for implementation, an invariant-ensuring type, and connection to an<br/>abstract type. INCOMPATIBILITY.<br/><br/>  - RBT is split into RBT and RBT_Mapping.<br/>  - AssocList is split and renamed into AList and AList_Mapping.<br/>  - DList is split into DList_Impl, DList, and DList_Cset.<br/>  - Cset is split into Cset and List_Cset.<br/><br/>* Theory Library/Nat_Infinity has been renamed to<br/>Library/Extended_Nat, with name changes of the following types and<br/>constants:<br/><br/>  type inat   ~&gt; type enat<br/>  Fin         ~&gt; enat<br/>  Infty       ~&gt; infinity (overloaded)<br/>  iSuc        ~&gt; eSuc<br/>  the_Fin     ~&gt; the_enat<br/><br/>Every theorem name containing &quot;inat&quot;, &quot;Fin&quot;, &quot;Infty&quot;, or &quot;iSuc&quot; has<br/>been renamed accordingly. INCOMPATIBILITY.<br/><br/>* Session Multivariate_Analysis: The euclidean_space type class now<br/>fixes a constant &quot;Basis :: &#39;a set&quot; consisting of the standard<br/>orthonormal basis for the type. Users now have the option of<br/>quantifying over this set instead of using the &quot;basis&quot; function, e.g.<br/>&quot;ALL x:Basis. P x&quot; vs &quot;ALL i&lt;DIM(&#39;a). P (basis i)&quot;.<br/><br/>* Session Multivariate_Analysis: Type &quot;(&#39;a, &#39;b) cart&quot; has been renamed<br/>to &quot;(&#39;a, &#39;b) vec&quot; (the syntax &quot;&#39;a ^ &#39;b&quot; remains unaffected). Constants<br/>&quot;Cart_nth&quot; and &quot;Cart_lambda&quot; have been respectively renamed to<br/>&quot;vec_nth&quot; and &quot;vec_lambda&quot;; theorems mentioning those names have<br/>changed to match. Definition theorems for overloaded constants now use<br/>the standard &quot;foo_vec_def&quot; naming scheme. A few other theorems have<br/>been renamed as follows (INCOMPATIBILITY):<br/><br/>  Cart_eq          ~&gt; vec_eq_iff<br/>  dist_nth_le_cart ~&gt; dist_vec_nth_le<br/>  tendsto_vector   ~&gt; vec_tendstoI<br/>  Cauchy_vector    ~&gt; vec_CauchyI<br/><br/>* Session Multivariate_Analysis: Several duplicate theorems have been<br/>removed, and other theorems have been renamed or replaced with more<br/>general versions. INCOMPATIBILITY.<br/><br/>  finite_choice ~&gt; finite_set_choice<br/>  eventually_conjI ~&gt; eventually_conj<br/>  eventually_and ~&gt; eventually_conj_iff<br/>  eventually_false ~&gt; eventually_False<br/>  setsum_norm ~&gt; norm_setsum<br/>  Lim_sequentially ~&gt; LIMSEQ_def<br/>  Lim_ident_at ~&gt; LIM_ident<br/>  Lim_const ~&gt; tendsto_const<br/>  Lim_cmul ~&gt; tendsto_scaleR [OF tendsto_const]<br/>  Lim_neg ~&gt; tendsto_minus<br/>  Lim_add ~&gt; tendsto_add<br/>  Lim_sub ~&gt; tendsto_diff<br/>  Lim_mul ~&gt; tendsto_scaleR<br/>  Lim_vmul ~&gt; tendsto_scaleR [OF _ tendsto_const]<br/>  Lim_null_norm ~&gt; tendsto_norm_zero_iff [symmetric]<br/>  Lim_linear ~&gt; bounded_linear.tendsto<br/>  Lim_component ~&gt; tendsto_euclidean_component<br/>  Lim_component_cart ~&gt; tendsto_vec_nth<br/>  Lim_inner ~&gt; tendsto_inner [OF tendsto_const]<br/>  dot_lsum ~&gt; inner_setsum_left<br/>  dot_rsum ~&gt; inner_setsum_right<br/>  continuous_cmul ~&gt; continuous_scaleR [OF continuous_const]<br/>  continuous_neg ~&gt; continuous_minus<br/>  continuous_sub ~&gt; continuous_diff<br/>  continuous_vmul ~&gt; continuous_scaleR [OF _ continuous_const]<br/>  continuous_mul ~&gt; continuous_scaleR<br/>  continuous_inv ~&gt; continuous_inverse<br/>  continuous_at_within_inv ~&gt; continuous_at_within_inverse<br/>  continuous_at_inv ~&gt; continuous_at_inverse<br/>  continuous_at_norm ~&gt; continuous_norm [OF continuous_at_id]<br/>  continuous_at_infnorm ~&gt; continuous_infnorm [OF continuous_at_id]<br/>  continuous_at_component ~&gt; continuous_component [OF continuous_at_id]<br/>  continuous_on_neg ~&gt; continuous_on_minus<br/>  continuous_on_sub ~&gt; continuous_on_diff<br/>  continuous_on_cmul ~&gt; continuous_on_scaleR [OF continuous_on_const]<br/>  continuous_on_vmul ~&gt; continuous_on_scaleR [OF _ continuous_on_const]<br/>  continuous_on_mul ~&gt; continuous_on_scaleR<br/>  continuous_on_mul_real ~&gt; continuous_on_mult<br/>  continuous_on_inner ~&gt; continuous_on_inner [OF continuous_on_const]<br/>  continuous_on_norm ~&gt; continuous_on_norm [OF continuous_on_id]<br/>  continuous_on_inverse ~&gt; continuous_on_inv<br/>  uniformly_continuous_on_neg ~&gt; uniformly_continuous_on_minus<br/>  uniformly_continuous_on_sub ~&gt; uniformly_continuous_on_diff<br/>  subset_interior ~&gt; interior_mono<br/>  subset_closure ~&gt; closure_mono<br/>  closure_univ ~&gt; closure_UNIV<br/>  real_arch_lt ~&gt; reals_Archimedean2<br/>  real_arch ~&gt; reals_Archimedean3<br/>  real_abs_norm ~&gt; abs_norm_cancel<br/>  real_abs_sub_norm ~&gt; norm_triangle_ineq3<br/>  norm_cauchy_schwarz_abs ~&gt; Cauchy_Schwarz_ineq2<br/><br/>* Session HOL-Probability:<br/>  - Caratheodory&#39;s extension lemma is now proved for ring_of_sets.<br/>  - Infinite products of probability measures are now available.<br/>  - Sigma closure is independent, if the generator is independent<br/>  - Use extended reals instead of positive extended<br/>    reals. INCOMPATIBILITY.<br/><br/>* Session HOLCF: Discontinued legacy theorem names, INCOMPATIBILITY.<br/><br/>  expand_fun_below ~&gt; fun_below_iff<br/>  below_fun_ext ~&gt; fun_belowI<br/>  expand_cfun_eq ~&gt; cfun_eq_iff<br/>  ext_cfun ~&gt; cfun_eqI<br/>  expand_cfun_below ~&gt; cfun_below_iff<br/>  below_cfun_ext ~&gt; cfun_belowI<br/>  monofun_fun_fun ~&gt; fun_belowD<br/>  monofun_fun_arg ~&gt; monofunE<br/>  monofun_lub_fun ~&gt; adm_monofun [THEN admD]<br/>  cont_lub_fun ~&gt; adm_cont [THEN admD]<br/>  cont2cont_Rep_CFun ~&gt; cont2cont_APP<br/>  cont_Rep_CFun_app ~&gt; cont_APP_app<br/>  cont_Rep_CFun_app_app ~&gt; cont_APP_app_app<br/>  cont_cfun_fun ~&gt; cont_Rep_cfun1 [THEN contE]<br/>  cont_cfun_arg ~&gt; cont_Rep_cfun2 [THEN contE]<br/>  contlub_cfun ~&gt; lub_APP [symmetric]<br/>  contlub_LAM ~&gt; lub_LAM [symmetric]<br/>  thelubI ~&gt; lub_eqI<br/>  UU_I ~&gt; bottomI<br/>  lift_distinct1 ~&gt; lift.distinct(1)<br/>  lift_distinct2 ~&gt; lift.distinct(2)<br/>  Def_not_UU ~&gt; lift.distinct(2)<br/>  Def_inject ~&gt; lift.inject<br/>  below_UU_iff ~&gt; below_bottom_iff<br/>  eq_UU_iff ~&gt; eq_bottom_iff<br/><br/><br/>*** Document preparation ***<br/><br/>* Antiquotation @{rail} layouts railroad syntax diagrams, see also<br/>isar-ref manual, both for description and actual application of the<br/>same.<br/><br/>* Antiquotation @{value} evaluates the given term and presents its<br/>result.<br/><br/>* Antiquotations: term style &quot;isub&quot; provides ad-hoc conversion of<br/>variables x1, y23 into subscripted form x\&lt;^isub&gt;1,<br/>y\&lt;^isub&gt;2\&lt;^isub&gt;3.<br/><br/>* Predefined LaTeX macros for Isabelle symbols ⤜ and ⪢<br/>(e.g. see ~~/src/HOL/Library/Monad_Syntax.thy).<br/><br/>* Localized \isabellestyle switch can be used within blocks or groups<br/>like this:<br/><br/>  \isabellestyle{it}  %preferred default<br/>  {\isabellestylett @{text &quot;typewriter stuff&quot;}}<br/><br/>* Discontinued special treatment of hard tabulators.  Implicit<br/>tab-width is now defined as 1.  Potential INCOMPATIBILITY for visual<br/>layouts.<br/><br/><br/>*** ML ***<br/><br/>* The inner syntax of sort/type/term/prop supports inlined YXML<br/>representations within quoted string tokens.  By encoding logical<br/>entities via Term_XML (in ML or Scala) concrete syntax can be<br/>bypassed, which is particularly useful for producing bits of text<br/>under external program control.<br/><br/>* Antiquotations for ML and document preparation are managed as theory<br/>data, which requires explicit setup.<br/><br/>* Isabelle_Process.is_active allows tools to check if the official<br/>process wrapper is running (Isabelle/Scala/jEdit) or the old TTY loop<br/>(better known as Proof General).<br/><br/>* Structure Proof_Context follows standard naming scheme.  Old<br/>ProofContext is still available for some time as legacy alias.<br/><br/>* Structure Timing provides various operations for timing; supersedes<br/>former start_timing/end_timing etc.<br/><br/>* Path.print is the official way to show file-system paths to users<br/>(including quotes etc.).<br/><br/>* Inner syntax: identifiers in parse trees of generic categories<br/>&quot;logic&quot;, &quot;aprop&quot;, &quot;idt&quot; etc. carry position information (disguised as<br/>type constraints).  Occasional INCOMPATIBILITY with non-compliant<br/>translations that choke on unexpected type constraints.  Positions can<br/>be stripped in ML translations via Syntax.strip_positions /<br/>Syntax.strip_positions_ast, or via the syntax constant<br/>&quot;_strip_positions&quot; within parse trees.  As last resort, positions can<br/>be disabled via the configuration option Syntax.positions, which is<br/>called &quot;syntax_positions&quot; in Isar attribute syntax.<br/><br/>* Discontinued special status of various ML structures that contribute<br/>to structure Syntax (Ast, Lexicon, Mixfix, Parser, Printer etc.): less<br/>pervasive content, no inclusion in structure Syntax.  INCOMPATIBILITY,<br/>refer directly to Ast.Constant, Lexicon.is_identifier,<br/>Syntax_Trans.mk_binder_tr etc.<br/><br/>* Typed print translation: discontinued show_sorts argument, which is<br/>already available via context of &quot;advanced&quot; translation.<br/><br/>* Refined PARALLEL_GOALS tactical: degrades gracefully for schematic<br/>goal states; body tactic needs to address all subgoals uniformly.<br/><br/>* Slightly more special eq_list/eq_set, with shortcut involving<br/>pointer equality (assumes that eq relation is reflexive).<br/><br/>* Classical tactics use proper Proof.context instead of historic types<br/>claset/clasimpset.  Old-style declarations like addIs, addEs, addDs<br/>operate directly on Proof.context.  Raw type claset retains its use as<br/>snapshot of the classical context, which can be recovered via<br/>(put_claset HOL_cs) etc.  Type clasimpset has been discontinued.<br/>INCOMPATIBILITY, classical tactics and derived proof methods require<br/>proper Proof.context.<br/><br/><br/>*** System ***<br/><br/>* Discontinued support for Poly/ML 5.2, which was the last version<br/>without proper multithreading and TimeLimit implementation.<br/><br/>* Discontinued old lib/scripts/polyml-platform, which has been<br/>obsolete since Isabelle2009-2.<br/><br/>* Various optional external tools are referenced more robustly and<br/>uniformly by explicit Isabelle settings as follows:<br/><br/>  ISABELLE_CSDP   (formerly CSDP_EXE)<br/>  ISABELLE_GHC    (formerly EXEC_GHC or GHC_PATH)<br/>  ISABELLE_OCAML  (formerly EXEC_OCAML)<br/>  ISABELLE_SWIPL  (formerly EXEC_SWIPL)<br/>  ISABELLE_YAP    (formerly EXEC_YAP)<br/><br/>Note that automated detection from the file-system or search path has<br/>been discontinued.  INCOMPATIBILITY.<br/><br/>* Scala layer provides JVM method invocation service for static<br/>methods of type (String)String, see Invoke_Scala.method in ML.  For<br/>example:<br/><br/>  Invoke_Scala.method &quot;java.lang.System.getProperty&quot; &quot;java.home&quot;<br/><br/>Together with YXML.string_of_body/parse_body and XML.Encode/Decode<br/>this allows to pass structured values between ML and Scala.<br/><br/>* The IsabelleText fonts includes some further glyphs to support the<br/>Prover IDE.  Potential INCOMPATIBILITY: users who happen to have<br/>installed a local copy (which is normally *not* required) need to<br/>delete or update it from ~~/lib/fonts/.<br/><br/><br/><br/>New in Isabelle2011 (January 2011)<br/>----------------------------------<br/><br/>*** General ***<br/><br/>* Experimental Prover IDE based on Isabelle/Scala and jEdit (see<br/>src/Tools/jEdit).  This also serves as IDE for Isabelle/ML, with<br/>useful tooltips and hyperlinks produced from its static analysis.  The<br/>bundled component provides an executable Isabelle tool that can be run<br/>like this:<br/><br/>  Isabelle2011/bin/isabelle jedit<br/><br/>* Significantly improved Isabelle/Isar implementation manual.<br/><br/>* System settings: ISABELLE_HOME_USER now includes ISABELLE_IDENTIFIER<br/>(and thus refers to something like $HOME/.isabelle/Isabelle2011),<br/>while the default heap location within that directory lacks that extra<br/>suffix.  This isolates multiple Isabelle installations from each<br/>other, avoiding problems with old settings in new versions.<br/>INCOMPATIBILITY, need to copy/upgrade old user settings manually.<br/><br/>* Source files are always encoded as UTF-8, instead of old-fashioned<br/>ISO-Latin-1.  INCOMPATIBILITY.  Isabelle LaTeX documents might require<br/>the following package declarations:<br/><br/>  \usepackage[utf8]{inputenc}<br/>  \usepackage{textcomp}<br/><br/>* Explicit treatment of UTF-8 sequences as Isabelle symbols, such that<br/>a Unicode character is treated as a single symbol, not a sequence of<br/>non-ASCII bytes as before.  Since Isabelle/ML string literals may<br/>contain symbols without further backslash escapes, Unicode can now be<br/>used here as well.  Recall that Symbol.explode in ML provides a<br/>consistent view on symbols, while raw explode (or String.explode)<br/>merely give a byte-oriented representation.<br/><br/>* Theory loader: source files are primarily located via the master<br/>directory of each theory node (where the .thy file itself resides).<br/>The global load path is still partially available as legacy feature.<br/>Minor INCOMPATIBILITY due to subtle change in file lookup: use<br/>explicit paths, relatively to the theory.<br/><br/>* Special treatment of ML file names has been discontinued.<br/>Historically, optional extensions .ML or .sml were added on demand --<br/>at the cost of clarity of file dependencies.  Recall that Isabelle/ML<br/>files exclusively use the .ML extension.  Minor INCOMPATIBILITY.<br/><br/>* Various options that affect pretty printing etc. are now properly<br/>handled within the context via configuration options, instead of<br/>unsynchronized references or print modes.  There are both ML Config.T<br/>entities and Isar declaration attributes to access these.<br/><br/>  ML (Config.T)                 Isar (attribute)<br/><br/>  eta_contract                  eta_contract<br/>  show_brackets                 show_brackets<br/>  show_sorts                    show_sorts<br/>  show_types                    show_types<br/>  show_question_marks           show_question_marks<br/>  show_consts                   show_consts<br/>  show_abbrevs                  show_abbrevs<br/><br/>  Syntax.ast_trace              syntax_ast_trace<br/>  Syntax.ast_stat               syntax_ast_stat<br/>  Syntax.ambiguity_level        syntax_ambiguity_level<br/><br/>  Goal_Display.goals_limit      goals_limit<br/>  Goal_Display.show_main_goal   show_main_goal<br/><br/>  Method.rule_trace             rule_trace<br/><br/>  Thy_Output.display            thy_output_display<br/>  Thy_Output.quotes             thy_output_quotes<br/>  Thy_Output.indent             thy_output_indent<br/>  Thy_Output.source             thy_output_source<br/>  Thy_Output.break              thy_output_break<br/><br/>Note that corresponding &quot;..._default&quot; references in ML may only be<br/>changed globally at the ROOT session setup, but *not* within a theory.<br/>The option &quot;show_abbrevs&quot; supersedes the former print mode<br/>&quot;no_abbrevs&quot; with inverted meaning.<br/><br/>* More systematic naming of some configuration options.<br/>INCOMPATIBILITY.<br/><br/>  trace_simp  ~&gt;  simp_trace<br/>  debug_simp  ~&gt;  simp_debug<br/><br/>* Support for real valued configuration options, using simplistic<br/>floating-point notation that coincides with the inner syntax for<br/>float_token.<br/><br/>* Support for real valued preferences (with approximative PGIP type):<br/>front-ends need to accept &quot;pgint&quot; values in float notation.<br/>INCOMPATIBILITY.<br/><br/>* The IsabelleText font now includes Cyrillic, Hebrew, Arabic from<br/>DejaVu Sans.<br/><br/>* Discontinued support for Poly/ML 5.0 and 5.1 versions.<br/><br/><br/>*** Pure ***<br/><br/>* Command &#39;type_synonym&#39; (with single argument) replaces somewhat<br/>outdated &#39;types&#39;, which is still available as legacy feature for some<br/>time.<br/><br/>* Command &#39;nonterminal&#39; (with &#39;and&#39; separated list of arguments)<br/>replaces somewhat outdated &#39;nonterminals&#39;.  INCOMPATIBILITY.<br/><br/>* Command &#39;notepad&#39; replaces former &#39;example_proof&#39; for<br/>experimentation in Isar without any result.  INCOMPATIBILITY.<br/><br/>* Locale interpretation commands &#39;interpret&#39; and &#39;sublocale&#39; accept<br/>lists of equations to map definitions in a locale to appropriate<br/>entities in the context of the interpretation.  The &#39;interpretation&#39;<br/>command already provided this functionality.<br/><br/>* Diagnostic command &#39;print_dependencies&#39; prints the locale instances<br/>that would be activated if the specified expression was interpreted in<br/>the current context.  Variant &quot;print_dependencies!&quot; assumes a context<br/>without interpretations.<br/><br/>* Diagnostic command &#39;print_interps&#39; prints interpretations in proofs<br/>in addition to interpretations in theories.<br/><br/>* Discontinued obsolete &#39;global&#39; and &#39;local&#39; commands to manipulate<br/>the theory name space.  Rare INCOMPATIBILITY.  The ML functions<br/>Sign.root_path and Sign.local_path may be applied directly where this<br/>feature is still required for historical reasons.<br/><br/>* Discontinued obsolete &#39;constdefs&#39; command.  INCOMPATIBILITY, use<br/>&#39;definition&#39; instead.<br/><br/>* The &quot;prems&quot; fact, which refers to the accidental collection of<br/>foundational premises in the context, is now explicitly marked as<br/>legacy feature and will be discontinued soon.  Consider using &quot;assms&quot;<br/>of the head statement or reference facts by explicit names.<br/><br/>* Document antiquotations @{class} and @{type} print classes and type<br/>constructors.<br/><br/>* Document antiquotation @{file} checks file/directory entries within<br/>the local file system.<br/><br/><br/>*** HOL ***<br/><br/>* Coercive subtyping: functions can be declared as coercions and type<br/>inference will add them as necessary upon input of a term.  Theory<br/>Complex_Main declares real :: nat =&gt; real and real :: int =&gt; real as<br/>coercions. A coercion function f is declared like this:<br/><br/>  declare [[coercion f]]<br/><br/>To lift coercions through type constructors (e.g. from nat =&gt; real to<br/>nat list =&gt; real list), map functions can be declared, e.g.<br/><br/>  declare [[coercion_map map]]<br/><br/>Currently coercion inference is activated only in theories including<br/>real numbers, i.e. descendants of Complex_Main.  This is controlled by<br/>the configuration option &quot;coercion_enabled&quot;, e.g. it can be enabled in<br/>other theories like this:<br/><br/>  declare [[coercion_enabled]]<br/><br/>* Command &#39;partial_function&#39; provides basic support for recursive<br/>function definitions over complete partial orders.  Concrete instances<br/>are provided for i) the option type, ii) tail recursion on arbitrary<br/>types, and iii) the heap monad of Imperative_HOL.  See<br/>src/HOL/ex/Fundefs.thy and src/HOL/Imperative_HOL/ex/Linked_Lists.thy<br/>for examples.<br/><br/>* Function package: f.psimps rules are no longer implicitly declared<br/>as [simp].  INCOMPATIBILITY.<br/><br/>* Datatype package: theorems generated for executable equality (class<br/>&quot;eq&quot;) carry proper names and are treated as default code equations.<br/><br/>* Inductive package: now offers command &#39;inductive_simps&#39; to<br/>automatically derive instantiated and simplified equations for<br/>inductive predicates, similar to &#39;inductive_cases&#39;.<br/><br/>* Command &#39;enriched_type&#39; allows to register properties of the<br/>functorial structure of types.<br/><br/>* Improved infrastructure for term evaluation using code generator<br/>techniques, in particular static evaluation conversions.<br/><br/>* Code generator: Scala (2.8 or higher) has been added to the target<br/>languages.<br/><br/>* Code generator: globbing constant expressions &quot;*&quot; and &quot;Theory.*&quot;<br/>have been replaced by the more idiomatic &quot;_&quot; and &quot;Theory._&quot;.<br/>INCOMPATIBILITY.<br/><br/>* Code generator: export_code without explicit file declaration prints<br/>to standard output.  INCOMPATIBILITY.<br/><br/>* Code generator: do not print function definitions for case<br/>combinators any longer.<br/><br/>* Code generator: simplification with rules determined with<br/>src/Tools/Code/code_simp.ML and method &quot;code_simp&quot;.<br/><br/>* Code generator for records: more idiomatic representation of record<br/>types.  Warning: records are not covered by ancient SML code<br/>generation any longer.  INCOMPATIBILITY.  In cases of need, a suitable<br/>rep_datatype declaration helps to succeed then:<br/><br/>  record &#39;a foo = ...<br/>  ...<br/>  rep_datatype foo_ext ...<br/><br/>* Records: logical foundation type for records does not carry a<br/>&#39;_type&#39; suffix any longer (obsolete due to authentic syntax).<br/>INCOMPATIBILITY.<br/><br/>* Quickcheck now by default uses exhaustive testing instead of random<br/>testing.  Random testing can be invoked by &quot;quickcheck [random]&quot;,<br/>exhaustive testing by &quot;quickcheck [exhaustive]&quot;.<br/><br/>* Quickcheck instantiates polymorphic types with small finite<br/>datatypes by default. This enables a simple execution mechanism to<br/>handle quantifiers and function equality over the finite datatypes.<br/><br/>* Quickcheck random generator has been renamed from &quot;code&quot; to<br/>&quot;random&quot;.  INCOMPATIBILITY.<br/><br/>* Quickcheck now has a configurable time limit which is set to 30<br/>seconds by default. This can be changed by adding [timeout = n] to the<br/>quickcheck command. The time limit for Auto Quickcheck is still set<br/>independently.<br/><br/>* Quickcheck in locales considers interpretations of that locale for<br/>counter example search.<br/><br/>* Sledgehammer:<br/>  - Added &quot;smt&quot; and &quot;remote_smt&quot; provers based on the &quot;smt&quot; proof<br/>    method. See the Sledgehammer manual for details (&quot;isabelle doc<br/>    sledgehammer&quot;).<br/>  - Renamed commands:<br/>    sledgehammer atp_info ~&gt; sledgehammer running_provers<br/>    sledgehammer atp_kill ~&gt; sledgehammer kill_provers<br/>    sledgehammer available_atps ~&gt; sledgehammer available_provers<br/>    INCOMPATIBILITY.<br/>  - Renamed options:<br/>    sledgehammer [atps = ...] ~&gt; sledgehammer [provers = ...]<br/>    sledgehammer [atp = ...] ~&gt; sledgehammer [prover = ...]<br/>    sledgehammer [timeout = 77 s] ~&gt; sledgehammer [timeout = 77]<br/>    (and &quot;ms&quot; and &quot;min&quot; are no longer supported)<br/>    INCOMPATIBILITY.<br/><br/>* Nitpick:<br/>  - Renamed options:<br/>    nitpick [timeout = 77 s] ~&gt; nitpick [timeout = 77]<br/>    nitpick [tac_timeout = 777 ms] ~&gt; nitpick [tac_timeout = 0.777]<br/>    INCOMPATIBILITY.<br/>  - Added support for partial quotient types.<br/>  - Added local versions of the &quot;Nitpick.register_xxx&quot; functions.<br/>  - Added &quot;whack&quot; option.<br/>  - Allow registration of quotient types as codatatypes.<br/>  - Improved &quot;merge_type_vars&quot; option to merge more types.<br/>  - Removed unsound &quot;fast_descrs&quot; option.<br/>  - Added custom symmetry breaking for datatypes, making it possible to reach<br/>    higher cardinalities.<br/>  - Prevent the expansion of too large definitions.<br/><br/>* Proof methods &quot;metis&quot; and &quot;meson&quot; now have configuration options<br/>&quot;meson_trace&quot;, &quot;metis_trace&quot;, and &quot;metis_verbose&quot; that can be enabled<br/>to diagnose these tools. E.g.<br/><br/>    using [[metis_trace = true]]<br/><br/>* Auto Solve: Renamed &quot;Auto Solve Direct&quot;.  The tool is now available<br/>manually as command &#39;solve_direct&#39;.<br/><br/>* The default SMT solver Z3 must be enabled explicitly (due to<br/>licensing issues) by setting the environment variable<br/>Z3_NON_COMMERCIAL in etc/settings of the component, for example.  For<br/>commercial applications, the SMT solver CVC3 is provided as fall-back;<br/>changing the SMT solver is done via the configuration option<br/>&quot;smt_solver&quot;.<br/><br/>* Remote SMT solvers need to be referred to by the &quot;remote_&quot; prefix,<br/>i.e. &quot;remote_cvc3&quot; and &quot;remote_z3&quot;.<br/><br/>* Added basic SMT support for datatypes, records, and typedefs using<br/>the oracle mode (no proofs).  Direct support of pairs has been dropped<br/>in exchange (pass theorems fst_conv snd_conv pair_collapse to the SMT<br/>support for a similar behavior).  Minor INCOMPATIBILITY.<br/><br/>* Changed SMT configuration options:<br/>  - Renamed:<br/>    z3_proofs ~&gt; smt_oracle (with inverted meaning)<br/>    z3_trace_assms ~&gt; smt_trace_used_facts<br/>    INCOMPATIBILITY.<br/>  - Added:<br/>    smt_verbose<br/>    smt_random_seed<br/>    smt_datatypes<br/>    smt_infer_triggers<br/>    smt_monomorph_limit<br/>    cvc3_options<br/>    remote_cvc3_options<br/>    remote_z3_options<br/>    yices_options<br/><br/>* Boogie output files (.b2i files) need to be declared in the theory<br/>header.<br/><br/>* Simplification procedure &quot;list_to_set_comprehension&quot; rewrites list<br/>comprehensions applied to List.set to set comprehensions.  Occasional<br/>INCOMPATIBILITY, may be deactivated like this:<br/><br/>  declare [[simproc del: list_to_set_comprehension]]<br/><br/>* Removed old version of primrec package.  INCOMPATIBILITY.<br/><br/>* Removed simplifier congruence rule of &quot;prod_case&quot;, as has for long<br/>been the case with &quot;split&quot;.  INCOMPATIBILITY.<br/><br/>* String.literal is a type, but not a datatype.  INCOMPATIBILITY.<br/><br/>* Removed [split_format ... and ... and ...] version of<br/>[split_format].  Potential INCOMPATIBILITY.<br/><br/>* Predicate &quot;sorted&quot; now defined inductively, with nice induction<br/>rules.  INCOMPATIBILITY: former sorted.simps now named sorted_simps.<br/><br/>* Constant &quot;contents&quot; renamed to &quot;the_elem&quot;, to free the generic name<br/>contents for other uses.  INCOMPATIBILITY.<br/><br/>* Renamed class eq and constant eq (for code generation) to class<br/>equal and constant equal, plus renaming of related facts and various<br/>tuning.  INCOMPATIBILITY.<br/><br/>* Dropped type classes mult_mono and mult_mono1.  INCOMPATIBILITY.<br/><br/>* Removed output syntax &quot;&#39;a ~=&gt; &#39;b&quot; for &quot;&#39;a =&gt; &#39;b option&quot;.<br/>INCOMPATIBILITY.<br/><br/>* Renamed theory Fset to Cset, type Fset.fset to Cset.set, in order to<br/>avoid confusion with finite sets.  INCOMPATIBILITY.<br/><br/>* Abandoned locales equiv, congruent and congruent2 for equivalence<br/>relations.  INCOMPATIBILITY: use equivI rather than equiv_intro (same<br/>for congruent(2)).<br/><br/>* Some previously unqualified names have been qualified:<br/><br/>  types<br/>    bool ~&gt; HOL.bool<br/>    nat ~&gt; Nat.nat<br/><br/>  constants<br/>    Trueprop ~&gt; HOL.Trueprop<br/>    True ~&gt; HOL.True<br/>    False ~&gt; HOL.False<br/>    op &amp; ~&gt; HOL.conj<br/>    op | ~&gt; HOL.disj<br/>    op --&gt; ~&gt; HOL.implies<br/>    op = ~&gt; HOL.eq<br/>    Not ~&gt; HOL.Not<br/>    The ~&gt; HOL.The<br/>    All ~&gt; HOL.All<br/>    Ex ~&gt; HOL.Ex<br/>    Ex1 ~&gt; HOL.Ex1<br/>    Let ~&gt; HOL.Let<br/>    If ~&gt; HOL.If<br/>    Ball ~&gt; Set.Ball<br/>    Bex ~&gt; Set.Bex<br/>    Suc ~&gt; Nat.Suc<br/>    Pair ~&gt; Product_Type.Pair<br/>    fst ~&gt; Product_Type.fst<br/>    snd ~&gt; Product_Type.snd<br/>    curry ~&gt; Product_Type.curry<br/>    op : ~&gt; Set.member<br/>    Collect ~&gt; Set.Collect<br/><br/>INCOMPATIBILITY.<br/><br/>* More canonical naming convention for some fundamental definitions:<br/><br/>    bot_bool_eq ~&gt; bot_bool_def<br/>    top_bool_eq ~&gt; top_bool_def<br/>    inf_bool_eq ~&gt; inf_bool_def<br/>    sup_bool_eq ~&gt; sup_bool_def<br/>    bot_fun_eq  ~&gt; bot_fun_def<br/>    top_fun_eq  ~&gt; top_fun_def<br/>    inf_fun_eq  ~&gt; inf_fun_def<br/>    sup_fun_eq  ~&gt; sup_fun_def<br/><br/>INCOMPATIBILITY.<br/><br/>* More stylized fact names:<br/><br/>  expand_fun_eq ~&gt; fun_eq_iff<br/>  expand_set_eq ~&gt; set_eq_iff<br/>  set_ext       ~&gt; set_eqI<br/>  nat_number    ~&gt; eval_nat_numeral<br/><br/>INCOMPATIBILITY.<br/><br/>* Refactoring of code-generation specific operations in theory List:<br/><br/>  constants<br/>    null ~&gt; List.null<br/><br/>  facts<br/>    mem_iff ~&gt; member_def<br/>    null_empty ~&gt; null_def<br/><br/>INCOMPATIBILITY.  Note that these were not supposed to be used<br/>regularly unless for striking reasons; their main purpose was code<br/>generation.<br/><br/>Various operations from the Haskell prelude are used for generating<br/>Haskell code.<br/><br/>* Term &quot;bij f&quot; is now an abbreviation of &quot;bij_betw f UNIV UNIV&quot;.  Term<br/>&quot;surj f&quot; is now an abbreviation of &quot;range f = UNIV&quot;.  The theorems<br/>bij_def and surj_def are unchanged.  INCOMPATIBILITY.<br/><br/>* Abolished some non-alphabetic type names: &quot;prod&quot; and &quot;sum&quot; replace<br/>&quot;*&quot; and &quot;+&quot; respectively.  INCOMPATIBILITY.<br/><br/>* Name &quot;Plus&quot; of disjoint sum operator &quot;&lt;+&gt;&quot; is now hidden.  Write<br/>&quot;Sum_Type.Plus&quot; instead.<br/><br/>* Constant &quot;split&quot; has been merged with constant &quot;prod_case&quot;; names of<br/>ML functions, facts etc. involving split have been retained so far,<br/>though.  INCOMPATIBILITY.<br/><br/>* Dropped old infix syntax &quot;_ mem _&quot; for List.member; use &quot;_ : set _&quot;<br/>instead.  INCOMPATIBILITY.<br/><br/>* Removed lemma &quot;Option.is_none_none&quot; which duplicates &quot;is_none_def&quot;.<br/>INCOMPATIBILITY.<br/><br/>* Former theory Library/Enum is now part of the HOL-Main image.<br/>INCOMPATIBILITY: all constants of the Enum theory now have to be<br/>referred to by its qualified name.<br/><br/>  enum    ~&gt;  Enum.enum<br/>  nlists  ~&gt;  Enum.nlists<br/>  product ~&gt;  Enum.product<br/><br/>* Theory Library/Monad_Syntax provides do-syntax for monad types.<br/>Syntax in Library/State_Monad has been changed to avoid ambiguities.<br/>INCOMPATIBILITY.<br/><br/>* Theory Library/SetsAndFunctions has been split into<br/>Library/Function_Algebras and Library/Set_Algebras; canonical names<br/>for instance definitions for functions; various improvements.<br/>INCOMPATIBILITY.<br/><br/>* Theory Library/Multiset provides stable quicksort implementation of<br/>sort_key.<br/><br/>* Theory Library/Multiset: renamed empty_idemp ~&gt; empty_neutral.<br/>INCOMPATIBILITY.<br/><br/>* Session Multivariate_Analysis: introduced a type class for euclidean<br/>space.  Most theorems are now stated in terms of euclidean spaces<br/>instead of finite cartesian products.<br/><br/>  types<br/>    real ^ &#39;n ~&gt;  &#39;a::real_vector<br/>              ~&gt;  &#39;a::euclidean_space<br/>              ~&gt;  &#39;a::ordered_euclidean_space<br/>        (depends on your needs)<br/><br/>  constants<br/>     _ $ _        ~&gt; _ $$ _<br/>     χ x. _  ~&gt; χχ x. _<br/>     CARD(&#39;n)     ~&gt; DIM(&#39;a)<br/><br/>Also note that the indices are now natural numbers and not from some<br/>finite type. Finite cartesian products of euclidean spaces, products<br/>of euclidean spaces the real and complex numbers are instantiated to<br/>be euclidean_spaces.  INCOMPATIBILITY.<br/><br/>* Session Probability: introduced pextreal as positive extended real<br/>numbers.  Use pextreal as value for measures.  Introduce the<br/>Radon-Nikodym derivative, product spaces and Fubini&#39;s theorem for<br/>arbitrary sigma finite measures.  Introduces Lebesgue measure based on<br/>the integral in Multivariate Analysis.  INCOMPATIBILITY.<br/><br/>* Session Imperative_HOL: revamped, corrected dozens of inadequacies.<br/>INCOMPATIBILITY.<br/><br/>* Session SPARK (with image HOL-SPARK) provides commands to load and<br/>prove verification conditions generated by the SPARK Ada program<br/>verifier.  See also src/HOL/SPARK and src/HOL/SPARK/Examples.<br/><br/><br/>*** HOL-Algebra ***<br/><br/>* Theorems for additive ring operations (locale abelian_monoid and<br/>descendants) are generated by interpretation from their multiplicative<br/>counterparts.  Names (in particular theorem names) have the mandatory<br/>qualifier &#39;add&#39;.  Previous theorem names are redeclared for<br/>compatibility.<br/><br/>* Structure &quot;int_ring&quot; is now an abbreviation (previously a<br/>definition).  This fits more natural with advanced interpretations.<br/><br/><br/>*** HOLCF ***<br/><br/>* The domain package now runs in definitional mode by default: The<br/>former command &#39;new_domain&#39; is now called &#39;domain&#39;.  To use the domain<br/>package in its original axiomatic mode, use &#39;domain (unsafe)&#39;.<br/>INCOMPATIBILITY.<br/><br/>* The new class &quot;domain&quot; is now the default sort.  Class &quot;predomain&quot;<br/>is an unpointed version of &quot;domain&quot;. Theories can be updated by<br/>replacing sort annotations as shown below.  INCOMPATIBILITY.<br/><br/>  &#39;a::type ~&gt; &#39;a::countable<br/>  &#39;a::cpo  ~&gt; &#39;a::predomain<br/>  &#39;a::pcpo ~&gt; &#39;a::domain<br/><br/>* The old type class &quot;rep&quot; has been superseded by class &quot;domain&quot;.<br/>Accordingly, users of the definitional package must remove any<br/>&quot;default_sort rep&quot; declarations.  INCOMPATIBILITY.<br/><br/>* The domain package (definitional mode) now supports unpointed<br/>predomain argument types, as long as they are marked &#39;lazy&#39;. (Strict<br/>arguments must be in class &quot;domain&quot;.) For example, the following<br/>domain definition now works:<br/><br/>  domain natlist = nil | cons (lazy &quot;nat discr&quot;) (lazy &quot;natlist&quot;)<br/><br/>* Theory HOLCF/Library/HOL_Cpo provides cpo and predomain class<br/>instances for types from main HOL: bool, nat, int, char, &#39;a + &#39;b,<br/>&#39;a option, and &#39;a list.  Additionally, it configures fixrec and the<br/>domain package to work with these types.  For example:<br/><br/>  fixrec isInl :: &quot;(&#39;a + &#39;b) u -&gt; tr&quot;<br/>    where &quot;isInl$(up$(Inl x)) = TT&quot; | &quot;isInl$(up$(Inr y)) = FF&quot;<br/><br/>  domain V = VFun (lazy &quot;V -&gt; V&quot;) | VCon (lazy &quot;nat&quot;) (lazy &quot;V list&quot;)<br/><br/>* The &quot;(permissive)&quot; option of fixrec has been replaced with a<br/>per-equation &quot;(unchecked)&quot; option. See<br/>src/HOL/HOLCF/Tutorial/Fixrec_ex.thy for examples. INCOMPATIBILITY.<br/><br/>* The &quot;bifinite&quot; class no longer fixes a constant &quot;approx&quot;; the class<br/>now just asserts that such a function exists.  INCOMPATIBILITY.<br/><br/>* Former type &quot;alg_defl&quot; has been renamed to &quot;defl&quot;.  HOLCF no longer<br/>defines an embedding of type &#39;a defl into udom by default; instances<br/>of &quot;bifinite&quot; and &quot;domain&quot; classes are available in<br/>src/HOL/HOLCF/Library/Defl_Bifinite.thy.<br/><br/>* The syntax &quot;REP(&#39;a)&quot; has been replaced with &quot;DEFL(&#39;a)&quot;.<br/><br/>* The predicate &quot;directed&quot; has been removed.  INCOMPATIBILITY.<br/><br/>* The type class &quot;finite_po&quot; has been removed.  INCOMPATIBILITY.<br/><br/>* The function &quot;cprod_map&quot; has been renamed to &quot;prod_map&quot;.<br/>INCOMPATIBILITY.<br/><br/>* The monadic bind operator on each powerdomain has new binder syntax<br/>similar to sets, e.g. &quot;⋃♯x∈xs. t&quot; represents<br/>&quot;upper_bind⋅xs⋅(Λ x. t)&quot;.<br/><br/>* The infix syntax for binary union on each powerdomain has changed<br/>from e.g. &quot;+♯&quot; to &quot;∪♯&quot;, for consistency with set<br/>syntax.  INCOMPATIBILITY.<br/><br/>* The constant &quot;UU&quot; has been renamed to &quot;bottom&quot;.  The syntax &quot;UU&quot; is<br/>still supported as an input translation.<br/><br/>* Renamed some theorems (the original names are also still available).<br/><br/>  expand_fun_below   ~&gt; fun_below_iff<br/>  below_fun_ext      ~&gt; fun_belowI<br/>  expand_cfun_eq     ~&gt; cfun_eq_iff<br/>  ext_cfun           ~&gt; cfun_eqI<br/>  expand_cfun_below  ~&gt; cfun_below_iff<br/>  below_cfun_ext     ~&gt; cfun_belowI<br/>  cont2cont_Rep_CFun ~&gt; cont2cont_APP<br/><br/>* The Abs and Rep functions for various types have changed names.<br/>Related theorem names have also changed to match. INCOMPATIBILITY.<br/><br/>  Rep_CFun  ~&gt; Rep_cfun<br/>  Abs_CFun  ~&gt; Abs_cfun<br/>  Rep_Sprod ~&gt; Rep_sprod<br/>  Abs_Sprod ~&gt; Abs_sprod<br/>  Rep_Ssum  ~&gt; Rep_ssum<br/>  Abs_Ssum  ~&gt; Abs_ssum<br/><br/>* Lemmas with names of the form *_defined_iff or *_strict_iff have<br/>been renamed to *_bottom_iff.  INCOMPATIBILITY.<br/><br/>* Various changes to bisimulation/coinduction with domain package:<br/><br/>  - Definitions of &quot;bisim&quot; constants no longer mention definedness.<br/>  - With mutual recursion, &quot;bisim&quot; predicate is now curried.<br/>  - With mutual recursion, each type gets a separate coind theorem.<br/>  - Variable names in bisim_def and coinduct rules have changed.<br/><br/>INCOMPATIBILITY.<br/><br/>* Case combinators generated by the domain package for type &quot;foo&quot; are<br/>now named &quot;foo_case&quot; instead of &quot;foo_when&quot;.  INCOMPATIBILITY.<br/><br/>* Several theorems have been renamed to more accurately reflect the<br/>names of constants and types involved.  INCOMPATIBILITY.<br/><br/>  thelub_const    ~&gt; lub_const<br/>  lub_const       ~&gt; is_lub_const<br/>  thelubI         ~&gt; lub_eqI<br/>  is_lub_lub      ~&gt; is_lubD2<br/>  lubI            ~&gt; is_lub_lub<br/>  unique_lub      ~&gt; is_lub_unique<br/>  is_ub_lub       ~&gt; is_lub_rangeD1<br/>  lub_bin_chain   ~&gt; is_lub_bin_chain<br/>  lub_fun         ~&gt; is_lub_fun<br/>  thelub_fun      ~&gt; lub_fun<br/>  thelub_cfun     ~&gt; lub_cfun<br/>  thelub_Pair     ~&gt; lub_Pair<br/>  lub_cprod       ~&gt; is_lub_prod<br/>  thelub_cprod    ~&gt; lub_prod<br/>  minimal_cprod   ~&gt; minimal_prod<br/>  inst_cprod_pcpo ~&gt; inst_prod_pcpo<br/>  UU_I            ~&gt; bottomI<br/>  compact_UU      ~&gt; compact_bottom<br/>  deflation_UU    ~&gt; deflation_bottom<br/>  finite_deflation_UU ~&gt; finite_deflation_bottom<br/><br/>* Many legacy theorem names have been discontinued.  INCOMPATIBILITY.<br/><br/>  sq_ord_less_eq_trans ~&gt; below_eq_trans<br/>  sq_ord_eq_less_trans ~&gt; eq_below_trans<br/>  refl_less            ~&gt; below_refl<br/>  trans_less           ~&gt; below_trans<br/>  antisym_less         ~&gt; below_antisym<br/>  antisym_less_inverse ~&gt; po_eq_conv [THEN iffD1]<br/>  box_less             ~&gt; box_below<br/>  rev_trans_less       ~&gt; rev_below_trans<br/>  not_less2not_eq      ~&gt; not_below2not_eq<br/>  less_UU_iff          ~&gt; below_UU_iff<br/>  flat_less_iff        ~&gt; flat_below_iff<br/>  adm_less             ~&gt; adm_below<br/>  adm_not_less         ~&gt; adm_not_below<br/>  adm_compact_not_less ~&gt; adm_compact_not_below<br/>  less_fun_def         ~&gt; below_fun_def<br/>  expand_fun_less      ~&gt; fun_below_iff<br/>  less_fun_ext         ~&gt; fun_belowI<br/>  less_discr_def       ~&gt; below_discr_def<br/>  discr_less_eq        ~&gt; discr_below_eq<br/>  less_unit_def        ~&gt; below_unit_def<br/>  less_cprod_def       ~&gt; below_prod_def<br/>  prod_lessI           ~&gt; prod_belowI<br/>  Pair_less_iff        ~&gt; Pair_below_iff<br/>  fst_less_iff         ~&gt; fst_below_iff<br/>  snd_less_iff         ~&gt; snd_below_iff<br/>  expand_cfun_less     ~&gt; cfun_below_iff<br/>  less_cfun_ext        ~&gt; cfun_belowI<br/>  injection_less       ~&gt; injection_below<br/>  less_up_def          ~&gt; below_up_def<br/>  not_Iup_less         ~&gt; not_Iup_below<br/>  Iup_less             ~&gt; Iup_below<br/>  up_less              ~&gt; up_below<br/>  Def_inject_less_eq   ~&gt; Def_below_Def<br/>  Def_less_is_eq       ~&gt; Def_below_iff<br/>  spair_less_iff       ~&gt; spair_below_iff<br/>  less_sprod           ~&gt; below_sprod<br/>  spair_less           ~&gt; spair_below<br/>  sfst_less_iff        ~&gt; sfst_below_iff<br/>  ssnd_less_iff        ~&gt; ssnd_below_iff<br/>  fix_least_less       ~&gt; fix_least_below<br/>  dist_less_one        ~&gt; dist_below_one<br/>  less_ONE             ~&gt; below_ONE<br/>  ONE_less_iff         ~&gt; ONE_below_iff<br/>  less_sinlD           ~&gt; below_sinlD<br/>  less_sinrD           ~&gt; below_sinrD<br/><br/><br/>*** FOL and ZF ***<br/><br/>* All constant names are now qualified internally and use proper<br/>identifiers, e.g. &quot;IFOL.eq&quot; instead of &quot;op =&quot;.  INCOMPATIBILITY.<br/><br/><br/>*** ML ***<br/><br/>* Antiquotation @{assert} inlines a function bool -&gt; unit that raises<br/>Fail if the argument is false.  Due to inlining the source position of<br/>failed assertions is included in the error output.<br/><br/>* Discontinued antiquotation @{theory_ref}, which is obsolete since ML<br/>text is in practice always evaluated with a stable theory checkpoint.<br/>Minor INCOMPATIBILITY, use (Theory.check_thy @{theory}) instead.<br/><br/>* Antiquotation @{theory A} refers to theory A from the ancestry of<br/>the current context, not any accidental theory loader state as before.<br/>Potential INCOMPATIBILITY, subtle change in semantics.<br/><br/>* Syntax.pretty_priority (default 0) configures the required priority<br/>of pretty-printed output and thus affects insertion of parentheses.<br/><br/>* Syntax.default_root (default &quot;any&quot;) configures the inner syntax<br/>category (nonterminal symbol) for parsing of terms.<br/><br/>* Former exception Library.UnequalLengths now coincides with<br/>ListPair.UnequalLengths.<br/><br/>* Renamed structure MetaSimplifier to Raw_Simplifier.  Note that the<br/>main functionality is provided by structure Simplifier.<br/><br/>* Renamed raw &quot;explode&quot; function to &quot;raw_explode&quot; to emphasize its<br/>meaning.  Note that internally to Isabelle, Symbol.explode is used in<br/>almost all situations.<br/><br/>* Discontinued obsolete function sys_error and exception SYS_ERROR.<br/>See implementation manual for further details on exceptions in<br/>Isabelle/ML.<br/><br/>* Renamed setmp_noncritical to Unsynchronized.setmp to emphasize its<br/>meaning.<br/><br/>* Renamed structure PureThy to Pure_Thy and moved most of its<br/>operations to structure Global_Theory, to emphasize that this is<br/>rarely-used global-only stuff.<br/><br/>* Discontinued Output.debug.  Minor INCOMPATIBILITY, use plain writeln<br/>instead (or tracing for high-volume output).<br/><br/>* Configuration option show_question_marks only affects regular pretty<br/>printing of types and terms, not raw Term.string_of_vname.<br/><br/>* ML_Context.thm and ML_Context.thms are no longer pervasive.  Rare<br/>INCOMPATIBILITY, superseded by static antiquotations @{thm} and<br/>@{thms} for most purposes.<br/><br/>* ML structure Unsynchronized is never opened, not even in Isar<br/>interaction mode as before.  Old Unsynchronized.set etc. have been<br/>discontinued -- use plain := instead.  This should be *rare* anyway,<br/>since modern tools always work via official context data, notably<br/>configuration options.<br/><br/>* Parallel and asynchronous execution requires special care concerning<br/>interrupts.  Structure Exn provides some convenience functions that<br/>avoid working directly with raw Interrupt.  User code must not absorb<br/>interrupts -- intermediate handling (for cleanup etc.) needs to be<br/>followed by re-raising of the original exception.  Another common<br/>source of mistakes are &quot;handle _&quot; patterns, which make the meaning of<br/>the program subject to physical effects of the environment.<br/><br/><br/><br/>New in Isabelle2009-2 (June 2010)<br/>---------------------------------<br/><br/>*** General ***<br/><br/>* Authentic syntax for *all* logical entities (type classes, type<br/>constructors, term constants): provides simple and robust<br/>correspondence between formal entities and concrete syntax.  Within<br/>the parse tree / AST representations, &quot;constants&quot; are decorated by<br/>their category (class, type, const) and spelled out explicitly with<br/>their full internal name.<br/><br/>Substantial INCOMPATIBILITY concerning low-level syntax declarations<br/>and translations (translation rules and translation functions in ML).<br/>Some hints on upgrading:<br/><br/>  - Many existing uses of &#39;syntax&#39; and &#39;translations&#39; can be replaced<br/>    by more modern &#39;type_notation&#39;, &#39;notation&#39; and &#39;abbreviation&#39;,<br/>    which are independent of this issue.<br/><br/>  - &#39;translations&#39; require markup within the AST; the term syntax<br/>    provides the following special forms:<br/><br/>      CONST c   -- produces syntax version of constant c from context<br/>      XCONST c  -- literally c, checked as constant from context<br/>      c         -- literally c, if declared by &#39;syntax&#39;<br/><br/>    Plain identifiers are treated as AST variables -- occasionally the<br/>    system indicates accidental variables via the error &quot;rhs contains<br/>    extra variables&quot;.<br/><br/>    Type classes and type constructors are marked according to their<br/>    concrete syntax.  Some old translations rules need to be written<br/>    for the &quot;type&quot; category, using type constructor application<br/>    instead of pseudo-term application of the default category<br/>    &quot;logic&quot;.<br/><br/>  - &#39;parse_translation&#39; etc. in ML may use the following<br/>    antiquotations:<br/><br/>      @{class_syntax c}   -- type class c within parse tree / AST<br/>      @{term_syntax c}    -- type constructor c within parse tree / AST<br/>      @{const_syntax c}   -- ML version of &quot;CONST c&quot; above<br/>      @{syntax_const c}   -- literally c (checked wrt. &#39;syntax&#39; declarations)<br/><br/>  - Literal types within &#39;typed_print_translations&#39;, i.e. those *not*<br/>    represented as pseudo-terms are represented verbatim.  Use @{class<br/>    c} or @{type_name c} here instead of the above syntax<br/>    antiquotations.<br/><br/>Note that old non-authentic syntax was based on unqualified base<br/>names, so all of the above &quot;constant&quot; names would coincide.  Recall<br/>that &#39;print_syntax&#39; and ML_command &quot;set Syntax.trace_ast&quot; help to<br/>diagnose syntax problems.<br/><br/>* Type constructors admit general mixfix syntax, not just infix.<br/><br/>* Concrete syntax may be attached to local entities without a proof<br/>body, too.  This works via regular mixfix annotations for &#39;fix&#39;,<br/>&#39;def&#39;, &#39;obtain&#39; etc. or via the explicit &#39;write&#39; command, which is<br/>similar to the &#39;notation&#39; command in theory specifications.<br/><br/>* Discontinued unnamed infix syntax (legacy feature for many years) --<br/>need to specify constant name and syntax separately.  Internal ML<br/>datatype constructors have been renamed from InfixName to Infix etc.<br/>Minor INCOMPATIBILITY.<br/><br/>* Schematic theorem statements need to be explicitly markup as such,<br/>via commands &#39;schematic_lemma&#39;, &#39;schematic_theorem&#39;,<br/>&#39;schematic_corollary&#39;.  Thus the relevance of the proof is made<br/>syntactically clear, which impacts performance in a parallel or<br/>asynchronous interactive environment.  Minor INCOMPATIBILITY.<br/><br/>* Use of cumulative prems via &quot;!&quot; in some proof methods has been<br/>discontinued (old legacy feature).<br/><br/>* References &#39;trace_simp&#39; and &#39;debug_simp&#39; have been replaced by<br/>configuration options stored in the context. Enabling tracing (the<br/>case of debugging is similar) in proofs works via<br/><br/>  using [[trace_simp = true]]<br/><br/>Tracing is then active for all invocations of the simplifier in<br/>subsequent goal refinement steps. Tracing may also still be enabled or<br/>disabled via the ProofGeneral settings menu.<br/><br/>* Separate commands &#39;hide_class&#39;, &#39;hide_type&#39;, &#39;hide_const&#39;,<br/>&#39;hide_fact&#39; replace the former &#39;hide&#39; KIND command.  Minor<br/>INCOMPATIBILITY.<br/><br/>* Improved parallelism of proof term normalization: usedir -p2 -q0 is<br/>more efficient than combinations with -q1 or -q2.<br/><br/><br/>*** Pure ***<br/><br/>* Proofterms record type-class reasoning explicitly, using the<br/>&quot;unconstrain&quot; operation internally.  This eliminates all sort<br/>constraints from a theorem and proof, introducing explicit<br/>OFCLASS-premises.  On the proof term level, this operation is<br/>automatically applied at theorem boundaries, such that closed proofs<br/>are always free of sort constraints.  INCOMPATIBILITY for tools that<br/>inspect proof terms.<br/><br/>* Local theory specifications may depend on extra type variables that<br/>are not present in the result type -- arguments TYPE(&#39;a) :: &#39;a itself<br/>are added internally.  For example:<br/><br/>  definition unitary :: bool where &quot;unitary = (ALL (x::&#39;a) y. x = y)&quot;<br/><br/>* Predicates of locales introduced by classes carry a mandatory<br/>&quot;class&quot; prefix.  INCOMPATIBILITY.<br/><br/>* Vacuous class specifications observe default sort.  INCOMPATIBILITY.<br/><br/>* Old &#39;axclass&#39; command has been discontinued.  INCOMPATIBILITY, use<br/>&#39;class&#39; instead.<br/><br/>* Command &#39;code_reflect&#39; allows to incorporate generated ML code into<br/>runtime environment; replaces immature code_datatype antiquotation.<br/>INCOMPATIBILITY.<br/><br/>* Code generator: simple concept for abstract datatypes obeying<br/>invariants.<br/><br/>* Code generator: details of internal data cache have no impact on the<br/>user space functionality any longer.<br/><br/>* Methods &quot;unfold_locales&quot; and &quot;intro_locales&quot; ignore non-locale<br/>subgoals.  This is more appropriate for interpretations with &#39;where&#39;.<br/>INCOMPATIBILITY.<br/><br/>* Command &#39;example_proof&#39; opens an empty proof body.  This allows to<br/>experiment with Isar, without producing any persistent result.<br/><br/>* Commands &#39;type_notation&#39; and &#39;no_type_notation&#39; declare type syntax<br/>within a local theory context, with explicit checking of the<br/>constructors involved (in contrast to the raw &#39;syntax&#39; versions).<br/><br/>* Commands &#39;types&#39; and &#39;typedecl&#39; now work within a local theory<br/>context -- without introducing dependencies on parameters or<br/>assumptions, which is not possible in Isabelle/Pure.<br/><br/>* Command &#39;defaultsort&#39; has been renamed to &#39;default_sort&#39;, it works<br/>within a local theory context.  Minor INCOMPATIBILITY.<br/><br/><br/>*** HOL ***<br/><br/>* Command &#39;typedef&#39; now works within a local theory context -- without<br/>introducing dependencies on parameters or assumptions, which is not<br/>possible in Isabelle/Pure/HOL.  Note that the logical environment may<br/>contain multiple interpretations of local typedefs (with different<br/>non-emptiness proofs), even in a global theory context.<br/><br/>* New package for quotient types.  Commands &#39;quotient_type&#39; and<br/>&#39;quotient_definition&#39; may be used for defining types and constants by<br/>quotient constructions.  An example is the type of integers created by<br/>quotienting pairs of natural numbers:<br/><br/>  fun<br/>    intrel :: &quot;(nat * nat) =&gt; (nat * nat) =&gt; bool&quot;<br/>  where<br/>    &quot;intrel (x, y) (u, v) = (x + v = u + y)&quot;<br/><br/>  quotient_type int = &quot;nat * nat&quot; / intrel<br/>    by (auto simp add: equivp_def expand_fun_eq)<br/><br/>  quotient_definition<br/>    &quot;0::int&quot; is &quot;(0::nat, 0::nat)&quot;<br/><br/>The method &quot;lifting&quot; can be used to lift of theorems from the<br/>underlying &quot;raw&quot; type to the quotient type.  The example<br/>src/HOL/Quotient_Examples/FSet.thy includes such a quotient<br/>construction and provides a reasoning infrastructure for finite sets.<br/><br/>* Renamed Library/Quotient.thy to Library/Quotient_Type.thy to avoid<br/>clash with new theory Quotient in Main HOL.<br/><br/>* Moved the SMT binding into the main HOL session, eliminating<br/>separate HOL-SMT session.<br/><br/>* List membership infix mem operation is only an input abbreviation.<br/>INCOMPATIBILITY.<br/><br/>* Theory Library/Word.thy has been removed.  Use library Word/Word.thy<br/>for future developements; former Library/Word.thy is still present in<br/>the AFP entry RSAPPS.<br/><br/>* Theorem Int.int_induct renamed to Int.int_of_nat_induct and is no<br/>longer shadowed.  INCOMPATIBILITY.<br/><br/>* Dropped theorem duplicate comp_arith; use semiring_norm instead.<br/>INCOMPATIBILITY.<br/><br/>* Dropped theorem RealPow.real_sq_order; use power2_le_imp_le instead.<br/>INCOMPATIBILITY.<br/><br/>* Dropped normalizing_semiring etc; use the facts in semiring classes<br/>instead.  INCOMPATIBILITY.<br/><br/>* Dropped several real-specific versions of lemmas about floor and<br/>ceiling; use the generic lemmas from theory &quot;Archimedean_Field&quot;<br/>instead.  INCOMPATIBILITY.<br/><br/>  floor_number_of_eq         ~&gt; floor_number_of<br/>  le_floor_eq_number_of      ~&gt; number_of_le_floor<br/>  le_floor_eq_zero           ~&gt; zero_le_floor<br/>  le_floor_eq_one            ~&gt; one_le_floor<br/>  floor_less_eq_number_of    ~&gt; floor_less_number_of<br/>  floor_less_eq_zero         ~&gt; floor_less_zero<br/>  floor_less_eq_one          ~&gt; floor_less_one<br/>  less_floor_eq_number_of    ~&gt; number_of_less_floor<br/>  less_floor_eq_zero         ~&gt; zero_less_floor<br/>  less_floor_eq_one          ~&gt; one_less_floor<br/>  floor_le_eq_number_of      ~&gt; floor_le_number_of<br/>  floor_le_eq_zero           ~&gt; floor_le_zero<br/>  floor_le_eq_one            ~&gt; floor_le_one<br/>  floor_subtract_number_of   ~&gt; floor_diff_number_of<br/>  floor_subtract_one         ~&gt; floor_diff_one<br/>  ceiling_number_of_eq       ~&gt; ceiling_number_of<br/>  ceiling_le_eq_number_of    ~&gt; ceiling_le_number_of<br/>  ceiling_le_zero_eq         ~&gt; ceiling_le_zero<br/>  ceiling_le_eq_one          ~&gt; ceiling_le_one<br/>  less_ceiling_eq_number_of  ~&gt; number_of_less_ceiling<br/>  less_ceiling_eq_zero       ~&gt; zero_less_ceiling<br/>  less_ceiling_eq_one        ~&gt; one_less_ceiling<br/>  ceiling_less_eq_number_of  ~&gt; ceiling_less_number_of<br/>  ceiling_less_eq_zero       ~&gt; ceiling_less_zero<br/>  ceiling_less_eq_one        ~&gt; ceiling_less_one<br/>  le_ceiling_eq_number_of    ~&gt; number_of_le_ceiling<br/>  le_ceiling_eq_zero         ~&gt; zero_le_ceiling<br/>  le_ceiling_eq_one          ~&gt; one_le_ceiling<br/>  ceiling_subtract_number_of ~&gt; ceiling_diff_number_of<br/>  ceiling_subtract_one       ~&gt; ceiling_diff_one<br/><br/>* Theory &quot;Finite_Set&quot;: various folding_XXX locales facilitate the<br/>application of the various fold combinators on finite sets.<br/><br/>* Library theory &quot;RBT&quot; renamed to &quot;RBT_Impl&quot;; new library theory &quot;RBT&quot;<br/>provides abstract red-black tree type which is backed by &quot;RBT_Impl&quot; as<br/>implementation.  INCOMPATIBILITY.<br/><br/>* Theory Library/Coinductive_List has been removed -- superseded by<br/>AFP/thys/Coinductive.<br/><br/>* Theory PReal, including the type &quot;preal&quot; and related operations, has<br/>been removed.  INCOMPATIBILITY.<br/><br/>* Real: new development using Cauchy Sequences.<br/><br/>* Split off theory &quot;Big_Operators&quot; containing setsum, setprod,<br/>Inf_fin, Sup_fin, Min, Max from theory Finite_Set.  INCOMPATIBILITY.<br/><br/>* Theory &quot;Rational&quot; renamed to &quot;Rat&quot;, for consistency with &quot;Nat&quot;,<br/>&quot;Int&quot; etc.  INCOMPATIBILITY.<br/><br/>* Constant Rat.normalize needs to be qualified.  INCOMPATIBILITY.<br/><br/>* New set of rules &quot;ac_simps&quot; provides combined assoc / commute<br/>rewrites for all interpretations of the appropriate generic locales.<br/><br/>* Renamed theory &quot;OrderedGroup&quot; to &quot;Groups&quot; and split theory<br/>&quot;Ring_and_Field&quot; into theories &quot;Rings&quot; and &quot;Fields&quot;; for more<br/>appropriate and more consistent names suitable for name prefixes<br/>within the HOL theories.  INCOMPATIBILITY.<br/><br/>* Some generic constants have been put to appropriate theories:<br/>  - less_eq, less: Orderings<br/>  - zero, one, plus, minus, uminus, times, abs, sgn: Groups<br/>  - inverse, divide: Rings<br/>INCOMPATIBILITY.<br/><br/>* More consistent naming of type classes involving orderings (and<br/>lattices):<br/><br/>    lower_semilattice                   ~&gt; semilattice_inf<br/>    upper_semilattice                   ~&gt; semilattice_sup<br/><br/>    dense_linear_order                  ~&gt; dense_linorder<br/><br/>    pordered_ab_group_add               ~&gt; ordered_ab_group_add<br/>    pordered_ab_group_add_abs           ~&gt; ordered_ab_group_add_abs<br/>    pordered_ab_semigroup_add           ~&gt; ordered_ab_semigroup_add<br/>    pordered_ab_semigroup_add_imp_le    ~&gt; ordered_ab_semigroup_add_imp_le<br/>    pordered_cancel_ab_semigroup_add    ~&gt; ordered_cancel_ab_semigroup_add<br/>    pordered_cancel_comm_semiring       ~&gt; ordered_cancel_comm_semiring<br/>    pordered_cancel_semiring            ~&gt; ordered_cancel_semiring<br/>    pordered_comm_monoid_add            ~&gt; ordered_comm_monoid_add<br/>    pordered_comm_ring                  ~&gt; ordered_comm_ring<br/>    pordered_comm_semiring              ~&gt; ordered_comm_semiring<br/>    pordered_ring                       ~&gt; ordered_ring<br/>    pordered_ring_abs                   ~&gt; ordered_ring_abs<br/>    pordered_semiring                   ~&gt; ordered_semiring<br/><br/>    ordered_ab_group_add                ~&gt; linordered_ab_group_add<br/>    ordered_ab_semigroup_add            ~&gt; linordered_ab_semigroup_add<br/>    ordered_cancel_ab_semigroup_add     ~&gt; linordered_cancel_ab_semigroup_add<br/>    ordered_comm_semiring_strict        ~&gt; linordered_comm_semiring_strict<br/>    ordered_field                       ~&gt; linordered_field<br/>    ordered_field_no_lb                 ~&gt; linordered_field_no_lb<br/>    ordered_field_no_ub                 ~&gt; linordered_field_no_ub<br/>    ordered_field_dense_linear_order    ~&gt; dense_linordered_field<br/>    ordered_idom                        ~&gt; linordered_idom<br/>    ordered_ring                        ~&gt; linordered_ring<br/>    ordered_ring_le_cancel_factor       ~&gt; linordered_ring_le_cancel_factor<br/>    ordered_ring_less_cancel_factor     ~&gt; linordered_ring_less_cancel_factor<br/>    ordered_ring_strict                 ~&gt; linordered_ring_strict<br/>    ordered_semidom                     ~&gt; linordered_semidom<br/>    ordered_semiring                    ~&gt; linordered_semiring<br/>    ordered_semiring_1                  ~&gt; linordered_semiring_1<br/>    ordered_semiring_1_strict           ~&gt; linordered_semiring_1_strict<br/>    ordered_semiring_strict             ~&gt; linordered_semiring_strict<br/><br/>  The following slightly odd type classes have been moved to a<br/>  separate theory Library/Lattice_Algebras:<br/><br/>    lordered_ab_group_add               ~&gt; lattice_ab_group_add<br/>    lordered_ab_group_add_abs           ~&gt; lattice_ab_group_add_abs<br/>    lordered_ab_group_add_meet          ~&gt; semilattice_inf_ab_group_add<br/>    lordered_ab_group_add_join          ~&gt; semilattice_sup_ab_group_add<br/>    lordered_ring                       ~&gt; lattice_ring<br/><br/>INCOMPATIBILITY.<br/><br/>* Refined field classes:<br/>  - classes division_ring_inverse_zero, field_inverse_zero,<br/>    linordered_field_inverse_zero include rule inverse 0 = 0 --<br/>    subsumes former division_by_zero class;<br/>  - numerous lemmas have been ported from field to division_ring.<br/>INCOMPATIBILITY.<br/><br/>* Refined algebra theorem collections:<br/>  - dropped theorem group group_simps, use algebra_simps instead;<br/>  - dropped theorem group ring_simps, use field_simps instead;<br/>  - proper theorem collection field_simps subsumes former theorem<br/>    groups field_eq_simps and field_simps;<br/>  - dropped lemma eq_minus_self_iff which is a duplicate for<br/>    equal_neg_zero.<br/>INCOMPATIBILITY.<br/><br/>* Theory Finite_Set and List: some lemmas have been generalized from<br/>sets to lattices:<br/><br/>  fun_left_comm_idem_inter      ~&gt; fun_left_comm_idem_inf<br/>  fun_left_comm_idem_union      ~&gt; fun_left_comm_idem_sup<br/>  inter_Inter_fold_inter        ~&gt; inf_Inf_fold_inf<br/>  union_Union_fold_union        ~&gt; sup_Sup_fold_sup<br/>  Inter_fold_inter              ~&gt; Inf_fold_inf<br/>  Union_fold_union              ~&gt; Sup_fold_sup<br/>  inter_INTER_fold_inter        ~&gt; inf_INFI_fold_inf<br/>  union_UNION_fold_union        ~&gt; sup_SUPR_fold_sup<br/>  INTER_fold_inter              ~&gt; INFI_fold_inf<br/>  UNION_fold_union              ~&gt; SUPR_fold_sup<br/><br/>* Theory &quot;Complete_Lattice&quot;: lemmas top_def and bot_def have been<br/>replaced by the more convenient lemmas Inf_empty and Sup_empty.<br/>Dropped lemmas Inf_insert_simp and Sup_insert_simp, which are subsumed<br/>by Inf_insert and Sup_insert.  Lemmas Inf_UNIV and Sup_UNIV replace<br/>former Inf_Univ and Sup_Univ.  Lemmas inf_top_right and sup_bot_right<br/>subsume inf_top and sup_bot respectively.  INCOMPATIBILITY.<br/><br/>* Reorganized theory Multiset: swapped notation of pointwise and<br/>multiset order:<br/><br/>  - pointwise ordering is instance of class order with standard syntax<br/>    &lt;= and &lt;;<br/>  - multiset ordering has syntax &lt;=# and &lt;#; partial order properties<br/>    are provided by means of interpretation with prefix<br/>    multiset_order;<br/>  - less duplication, less historical organization of sections,<br/>    conversion from associations lists to multisets, rudimentary code<br/>    generation;<br/>  - use insert_DiffM2 [symmetric] instead of elem_imp_eq_diff_union,<br/>    if needed.<br/><br/>Renamed:<br/><br/>  multiset_eq_conv_count_eq  ~&gt;  multiset_ext_iff<br/>  multi_count_ext  ~&gt;  multiset_ext<br/>  diff_union_inverse2  ~&gt;  diff_union_cancelR<br/><br/>INCOMPATIBILITY.<br/><br/>* Theory Permutation: replaced local &quot;remove&quot; by List.remove1.<br/><br/>* Code generation: ML and OCaml code is decorated with signatures.<br/><br/>* Theory List: added transpose.<br/><br/>* Library/Nat_Bijection.thy is a collection of bijective functions<br/>between nat and other types, which supersedes the older libraries<br/>Library/Nat_Int_Bij.thy and HOLCF/NatIso.thy.  INCOMPATIBILITY.<br/><br/>  Constants:<br/>  Nat_Int_Bij.nat2_to_nat         ~&gt; prod_encode<br/>  Nat_Int_Bij.nat_to_nat2         ~&gt; prod_decode<br/>  Nat_Int_Bij.int_to_nat_bij      ~&gt; int_encode<br/>  Nat_Int_Bij.nat_to_int_bij      ~&gt; int_decode<br/>  Countable.pair_encode           ~&gt; prod_encode<br/>  NatIso.prod2nat                 ~&gt; prod_encode<br/>  NatIso.nat2prod                 ~&gt; prod_decode<br/>  NatIso.sum2nat                  ~&gt; sum_encode<br/>  NatIso.nat2sum                  ~&gt; sum_decode<br/>  NatIso.list2nat                 ~&gt; list_encode<br/>  NatIso.nat2list                 ~&gt; list_decode<br/>  NatIso.set2nat                  ~&gt; set_encode<br/>  NatIso.nat2set                  ~&gt; set_decode<br/><br/>  Lemmas:<br/>  Nat_Int_Bij.bij_nat_to_int_bij  ~&gt; bij_int_decode<br/>  Nat_Int_Bij.nat2_to_nat_inj     ~&gt; inj_prod_encode<br/>  Nat_Int_Bij.nat2_to_nat_surj    ~&gt; surj_prod_encode<br/>  Nat_Int_Bij.nat_to_nat2_inj     ~&gt; inj_prod_decode<br/>  Nat_Int_Bij.nat_to_nat2_surj    ~&gt; surj_prod_decode<br/>  Nat_Int_Bij.i2n_n2i_id          ~&gt; int_encode_inverse<br/>  Nat_Int_Bij.n2i_i2n_id          ~&gt; int_decode_inverse<br/>  Nat_Int_Bij.surj_nat_to_int_bij ~&gt; surj_int_encode<br/>  Nat_Int_Bij.surj_int_to_nat_bij ~&gt; surj_int_decode<br/>  Nat_Int_Bij.inj_nat_to_int_bij  ~&gt; inj_int_encode<br/>  Nat_Int_Bij.inj_int_to_nat_bij  ~&gt; inj_int_decode<br/>  Nat_Int_Bij.bij_nat_to_int_bij  ~&gt; bij_int_encode<br/>  Nat_Int_Bij.bij_int_to_nat_bij  ~&gt; bij_int_decode<br/><br/>* Sledgehammer:<br/>  - Renamed ATP commands:<br/>    atp_info     ~&gt; sledgehammer running_atps<br/>    atp_kill     ~&gt; sledgehammer kill_atps<br/>    atp_messages ~&gt; sledgehammer messages<br/>    atp_minimize ~&gt; sledgehammer minimize<br/>    print_atps   ~&gt; sledgehammer available_atps<br/>    INCOMPATIBILITY.<br/>  - Added user&#39;s manual (&quot;isabelle doc sledgehammer&quot;).<br/>  - Added option syntax and &quot;sledgehammer_params&quot; to customize<br/>    Sledgehammer&#39;s behavior.  See the manual for details.<br/>  - Modified the Isar proof reconstruction code so that it produces<br/>    direct proofs rather than proofs by contradiction.  (This feature<br/>    is still experimental.)<br/>  - Made Isar proof reconstruction work for SPASS, remote ATPs, and in<br/>    full-typed mode.<br/>  - Added support for TPTP syntax for SPASS via the &quot;spass_tptp&quot; ATP.<br/><br/>* Nitpick:<br/>  - Added and implemented &quot;binary_ints&quot; and &quot;bits&quot; options.<br/>  - Added &quot;std&quot; option and implemented support for nonstandard models.<br/>  - Added and implemented &quot;finitize&quot; option to improve the precision<br/>    of infinite datatypes based on a monotonicity analysis.<br/>  - Added support for quotient types.<br/>  - Added support for &quot;specification&quot; and &quot;ax_specification&quot;<br/>    constructs.<br/>  - Added support for local definitions (for &quot;function&quot; and<br/>    &quot;termination&quot; proofs).<br/>  - Added support for term postprocessors.<br/>  - Optimized &quot;Multiset.multiset&quot; and &quot;FinFun.finfun&quot;.<br/>  - Improved efficiency of &quot;destroy_constrs&quot; optimization.<br/>  - Fixed soundness bugs related to &quot;destroy_constrs&quot; optimization and<br/>    record getters.<br/>  - Fixed soundness bug related to higher-order constructors.<br/>  - Fixed soundness bug when &quot;full_descrs&quot; is enabled.<br/>  - Improved precision of set constructs.<br/>  - Added &quot;atoms&quot; option.<br/>  - Added cache to speed up repeated Kodkod invocations on the same<br/>    problems.<br/>  - Renamed &quot;MiniSatJNI&quot;, &quot;zChaffJNI&quot;, &quot;BerkMinAlloy&quot;, and<br/>    &quot;SAT4JLight&quot; to &quot;MiniSat_JNI&quot;, &quot;zChaff_JNI&quot;, &quot;BerkMin_Alloy&quot;, and<br/>    &quot;SAT4J_Light&quot;.  INCOMPATIBILITY.<br/>  - Removed &quot;skolemize&quot;, &quot;uncurry&quot;, &quot;sym_break&quot;, &quot;flatten_prop&quot;,<br/>    &quot;sharing_depth&quot;, and &quot;show_skolems&quot; options.  INCOMPATIBILITY.<br/>  - Removed &quot;nitpick_intro&quot; attribute.  INCOMPATIBILITY.<br/><br/>* Method &quot;induct&quot; now takes instantiations of the form t, where t is not<br/>  a variable, as a shorthand for &quot;x == t&quot;, where x is a fresh variable.<br/>  If this is not intended, t has to be enclosed in parentheses.<br/>  By default, the equalities generated by definitional instantiations<br/>  are pre-simplified, which may cause parameters of inductive cases<br/>  to disappear, or may even delete some of the inductive cases.<br/>  Use &quot;induct (no_simp)&quot; instead of &quot;induct&quot; to restore the old<br/>  behaviour. The (no_simp) option is also understood by the &quot;cases&quot;<br/>  and &quot;nominal_induct&quot; methods, which now perform pre-simplification, too.<br/>  INCOMPATIBILITY.<br/><br/><br/>*** HOLCF ***<br/><br/>* Variable names in lemmas generated by the domain package have<br/>changed; the naming scheme is now consistent with the HOL datatype<br/>package.  Some proof scripts may be affected, INCOMPATIBILITY.<br/><br/>* The domain package no longer defines the function &quot;foo_copy&quot; for<br/>recursive domain &quot;foo&quot;.  The reach lemma is now stated directly in<br/>terms of &quot;foo_take&quot;.  Lemmas and proofs that mention &quot;foo_copy&quot; must<br/>be reformulated in terms of &quot;foo_take&quot;, INCOMPATIBILITY.<br/><br/>* Most definedness lemmas generated by the domain package (previously<br/>of the form &quot;x ~= UU ==&gt; foo$x ~= UU&quot;) now have an if-and-only-if form<br/>like &quot;foo$x = UU &lt;-&gt; x = UU&quot;, which works better as a simp rule.<br/>Proofs that used definedness lemmas as intro rules may break,<br/>potential INCOMPATIBILITY.<br/><br/>* Induction and casedist rules generated by the domain package now<br/>declare proper case_names (one called &quot;bottom&quot;, and one named for each<br/>constructor).  INCOMPATIBILITY.<br/><br/>* For mutually-recursive domains, separate &quot;reach&quot; and &quot;take_lemma&quot;<br/>rules are generated for each domain, INCOMPATIBILITY.<br/><br/>  foo_bar.reach       ~&gt; foo.reach  bar.reach<br/>  foo_bar.take_lemmas ~&gt; foo.take_lemma  bar.take_lemma<br/><br/>* Some lemmas generated by the domain package have been renamed for<br/>consistency with the datatype package, INCOMPATIBILITY.<br/><br/>  foo.ind        ~&gt; foo.induct<br/>  foo.finite_ind ~&gt; foo.finite_induct<br/>  foo.coind      ~&gt; foo.coinduct<br/>  foo.casedist   ~&gt; foo.exhaust<br/>  foo.exhaust    ~&gt; foo.nchotomy<br/><br/>* For consistency with other definition packages, the fixrec package<br/>now generates qualified theorem names, INCOMPATIBILITY.<br/><br/>  foo_simps  ~&gt; foo.simps<br/>  foo_unfold ~&gt; foo.unfold<br/>  foo_induct ~&gt; foo.induct<br/><br/>* The &quot;fixrec_simp&quot; attribute has been removed.  The &quot;fixrec_simp&quot;<br/>method and internal fixrec proofs now use the default simpset instead.<br/>INCOMPATIBILITY.<br/><br/>* The &quot;contlub&quot; predicate has been removed.  Proof scripts should use<br/>lemma contI2 in place of monocontlub2cont, INCOMPATIBILITY.<br/><br/>* The &quot;admw&quot; predicate has been removed, INCOMPATIBILITY.<br/><br/>* The constants cpair, cfst, and csnd have been removed in favor of<br/>Pair, fst, and snd from Isabelle/HOL, INCOMPATIBILITY.<br/><br/><br/>*** ML ***<br/><br/>* Antiquotations for basic formal entities:<br/><br/>    @{class NAME}         -- type class<br/>    @{class_syntax NAME}  -- syntax representation of the above<br/><br/>    @{type_name NAME}     -- logical type<br/>    @{type_abbrev NAME}   -- type abbreviation<br/>    @{nonterminal NAME}   -- type of concrete syntactic category<br/>    @{type_syntax NAME}   -- syntax representation of any of the above<br/><br/>    @{const_name NAME}    -- logical constant (INCOMPATIBILITY)<br/>    @{const_abbrev NAME}  -- abbreviated constant<br/>    @{const_syntax NAME}  -- syntax representation of any of the above<br/><br/>* Antiquotation @{syntax_const NAME} ensures that NAME refers to a raw<br/>syntax constant (cf. &#39;syntax&#39; command).<br/><br/>* Antiquotation @{make_string} inlines a function to print arbitrary<br/>values similar to the ML toplevel.  The result is compiler dependent<br/>and may fall back on &quot;?&quot; in certain situations.<br/><br/>* Diagnostic commands &#39;ML_val&#39; and &#39;ML_command&#39; may refer to<br/>antiquotations @{Isar.state} and @{Isar.goal}.  This replaces impure<br/>Isar.state() and Isar.goal(), which belong to the old TTY loop and do<br/>not work with the asynchronous Isar document model.<br/><br/>* Configuration options now admit dynamic default values, depending on<br/>the context or even global references.<br/><br/>* SHA1.digest digests strings according to SHA-1 (see RFC 3174).  It<br/>uses an efficient external library if available (for Poly/ML).<br/><br/>* Renamed some important ML structures, while keeping the old names<br/>for some time as aliases within the structure Legacy:<br/><br/>  OuterKeyword  ~&gt;  Keyword<br/>  OuterLex      ~&gt;  Token<br/>  OuterParse    ~&gt;  Parse<br/>  OuterSyntax   ~&gt;  Outer_Syntax<br/>  PrintMode     ~&gt;  Print_Mode<br/>  SpecParse     ~&gt;  Parse_Spec<br/>  ThyInfo       ~&gt;  Thy_Info<br/>  ThyLoad       ~&gt;  Thy_Load<br/>  ThyOutput     ~&gt;  Thy_Output<br/>  TypeInfer     ~&gt;  Type_Infer<br/><br/>Note that &quot;open Legacy&quot; simplifies porting of sources, but forgetting<br/>to remove it again will complicate porting again in the future.<br/><br/>* Most operations that refer to a global context are named<br/>accordingly, e.g. Simplifier.global_context or<br/>ProofContext.init_global.  There are some situations where a global<br/>context actually works, but under normal circumstances one needs to<br/>pass the proper local context through the code!<br/><br/>* Discontinued old TheoryDataFun with its copy/init operation -- data<br/>needs to be pure.  Functor Theory_Data_PP retains the traditional<br/>Pretty.pp argument to merge, which is absent in the standard<br/>Theory_Data version.<br/><br/>* Sorts.certify_sort and derived &quot;cert&quot; operations for types and terms<br/>no longer minimize sorts.  Thus certification at the boundary of the<br/>inference kernel becomes invariant under addition of class relations,<br/>which is an important monotonicity principle.  Sorts are now minimized<br/>in the syntax layer only, at the boundary between the end-user and the<br/>system.  Subtle INCOMPATIBILITY, may have to use Sign.minimize_sort<br/>explicitly in rare situations.<br/><br/>* Renamed old-style Drule.standard to Drule.export_without_context, to<br/>emphasize that this is in no way a standard operation.<br/>INCOMPATIBILITY.<br/><br/>* Subgoal.FOCUS (and variants): resulting goal state is normalized as<br/>usual for resolution.  Rare INCOMPATIBILITY.<br/><br/>* Renamed varify/unvarify operations to varify_global/unvarify_global<br/>to emphasize that these only work in a global situation (which is<br/>quite rare).<br/><br/>* Curried take and drop in library.ML; negative length is interpreted<br/>as infinity (as in chop).  Subtle INCOMPATIBILITY.<br/><br/>* Proof terms: type substitutions on proof constants now use canonical<br/>order of type variables.  INCOMPATIBILITY for tools working with proof<br/>terms.<br/><br/>* Raw axioms/defs may no longer carry sort constraints, and raw defs<br/>may no longer carry premises.  User-level specifications are<br/>transformed accordingly by Thm.add_axiom/add_def.<br/><br/><br/>*** System ***<br/><br/>* Discontinued special HOL_USEDIR_OPTIONS for the main HOL image;<br/>ISABELLE_USEDIR_OPTIONS applies uniformly to all sessions.  Note that<br/>proof terms are enabled unconditionally in the new HOL-Proofs image.<br/><br/>* Discontinued old ISABELLE and ISATOOL environment settings (legacy<br/>feature since Isabelle2009).  Use ISABELLE_PROCESS and ISABELLE_TOOL,<br/>respectively.<br/><br/>* Old lib/scripts/polyml-platform is superseded by the<br/>ISABELLE_PLATFORM setting variable, which defaults to the 32 bit<br/>variant, even on a 64 bit machine.  The following example setting<br/>prefers 64 bit if available:<br/><br/>  ML_PLATFORM=&quot;${ISABELLE_PLATFORM64:-$ISABELLE_PLATFORM}&quot;<br/><br/>* The preliminary Isabelle/jEdit application demonstrates the emerging<br/>Isabelle/Scala layer for advanced prover interaction and integration.<br/>See src/Tools/jEdit or &quot;isabelle jedit&quot; provided by the properly built<br/>component.<br/><br/>* &quot;IsabelleText&quot; is a Unicode font derived from Bitstream Vera Mono<br/>and Bluesky TeX fonts.  It provides the usual Isabelle symbols,<br/>similar to the default assignment of the document preparation system<br/>(cf. isabellesym.sty).  The Isabelle/Scala class Isabelle_System<br/>provides some operations for direct access to the font without asking<br/>the user for manual installation.<br/><br/><br/><br/>New in Isabelle2009-1 (December 2009)<br/>-------------------------------------<br/><br/>*** General ***<br/><br/>* Discontinued old form of &quot;escaped symbols&quot; such as \∀.  Only<br/>one backslash should be used, even in ML sources.<br/><br/><br/>*** Pure ***<br/><br/>* Locale interpretation propagates mixins along the locale hierarchy.<br/>The currently only available mixins are the equations used to map<br/>local definitions to terms of the target domain of an interpretation.<br/><br/>* Reactivated diagnostic command &#39;print_interps&#39;.  Use &quot;print_interps<br/>loc&quot; to print all interpretations of locale &quot;loc&quot; in the theory.<br/>Interpretations in proofs are not shown.<br/><br/>* Thoroughly revised locales tutorial.  New section on conditional<br/>interpretation.<br/><br/>* On instantiation of classes, remaining undefined class parameters<br/>are formally declared.  INCOMPATIBILITY.<br/><br/><br/>*** Document preparation ***<br/><br/>* New generalized style concept for printing terms: @{foo (style) ...}<br/>instead of @{foo_style style ...}  (old form is still retained for<br/>backward compatibility).  Styles can be also applied for<br/>antiquotations prop, term_type and typeof.<br/><br/><br/>*** HOL ***<br/><br/>* New proof method &quot;smt&quot; for a combination of first-order logic with<br/>equality, linear and nonlinear (natural/integer/real) arithmetic, and<br/>fixed-size bitvectors; there is also basic support for higher-order<br/>features (esp. lambda abstractions).  It is an incomplete decision<br/>procedure based on external SMT solvers using the oracle mechanism;<br/>for the SMT solver Z3, this method is proof-producing.  Certificates<br/>are provided to avoid calling the external solvers solely for<br/>re-checking proofs.  Due to a remote SMT service there is no need for<br/>installing SMT solvers locally.  See src/HOL/SMT.<br/><br/>* New commands to load and prove verification conditions generated by<br/>the Boogie program verifier or derived systems (e.g. the Verifying C<br/>Compiler (VCC) or Spec#).  See src/HOL/Boogie.<br/><br/>* New counterexample generator tool &#39;nitpick&#39; based on the Kodkod<br/>relational model finder.  See src/HOL/Tools/Nitpick and<br/>src/HOL/Nitpick_Examples.<br/><br/>* New commands &#39;code_pred&#39; and &#39;values&#39; to invoke the predicate<br/>compiler and to enumerate values of inductive predicates.<br/><br/>* A tabled implementation of the reflexive transitive closure.<br/><br/>* New implementation of quickcheck uses generic code generator;<br/>default generators are provided for all suitable HOL types, records<br/>and datatypes.  Old quickcheck can be re-activated importing theory<br/>Library/SML_Quickcheck.<br/><br/>* New testing tool Mirabelle for automated proof tools.  Applies<br/>several tools and tactics like sledgehammer, metis, or quickcheck, to<br/>every proof step in a theory.  To be used in batch mode via the<br/>&quot;mirabelle&quot; utility.<br/><br/>* New proof method &quot;sos&quot; (sum of squares) for nonlinear real<br/>arithmetic (originally due to John Harison). It requires theory<br/>Library/Sum_Of_Squares.  It is not a complete decision procedure but<br/>works well in practice on quantifier-free real arithmetic with +, -,<br/>*, ^, =, &lt;= and &lt;, i.e. boolean combinations of equalities and<br/>inequalities between polynomials.  It makes use of external<br/>semidefinite programming solvers.  Method &quot;sos&quot; generates a<br/>certificate that can be pasted into the proof thus avoiding the need<br/>to call an external tool every time the proof is checked.  See<br/>src/HOL/Library/Sum_Of_Squares.<br/><br/>* New method &quot;linarith&quot; invokes existing linear arithmetic decision<br/>procedure only.<br/><br/>* New command &#39;atp_minimal&#39; reduces result produced by Sledgehammer.<br/><br/>* New Sledgehammer option &quot;Full Types&quot; in Proof General settings menu.<br/>Causes full type information to be output to the ATPs.  This slows<br/>ATPs down considerably but eliminates a source of unsound &quot;proofs&quot;<br/>that fail later.<br/><br/>* New method &quot;metisFT&quot;: A version of metis that uses full type<br/>information in order to avoid failures of proof reconstruction.<br/><br/>* New evaluator &quot;approximate&quot; approximates an real valued term using<br/>the same method as the approximation method.<br/><br/>* Method &quot;approximate&quot; now supports arithmetic expressions as<br/>boundaries of intervals and implements interval splitting and Taylor<br/>series expansion.<br/><br/>* ML antiquotation @{code_datatype} inserts definition of a datatype<br/>generated by the code generator; e.g. see src/HOL/Predicate.thy.<br/><br/>* New theory SupInf of the supremum and infimum operators for sets of<br/>reals.<br/><br/>* New theory Probability, which contains a development of measure<br/>theory, eventually leading to Lebesgue integration and probability.<br/><br/>* Extended Multivariate Analysis to include derivation and Brouwer&#39;s<br/>fixpoint theorem.<br/><br/>* Reorganization of number theory, INCOMPATIBILITY:<br/>  - new number theory development for nat and int, in theories Divides<br/>    and GCD as well as in new session Number_Theory<br/>  - some constants and facts now suffixed with _nat and _int<br/>    accordingly<br/>  - former session NumberTheory now named Old_Number_Theory, including<br/>    theories Legacy_GCD and Primes (prefer Number_Theory if possible)<br/>  - moved theory Pocklington from src/HOL/Library to<br/>    src/HOL/Old_Number_Theory<br/><br/>* Theory GCD includes functions Gcd/GCD and Lcm/LCM for the gcd and<br/>lcm of finite and infinite sets. It is shown that they form a complete<br/>lattice.<br/><br/>* Class semiring_div requires superclass no_zero_divisors and proof of<br/>div_mult_mult1; theorems div_mult_mult1, div_mult_mult2,<br/>div_mult_mult1_if, div_mult_mult1 and div_mult_mult2 have been<br/>generalized to class semiring_div, subsuming former theorems<br/>zdiv_zmult_zmult1, zdiv_zmult_zmult1_if, zdiv_zmult_zmult1 and<br/>zdiv_zmult_zmult2.  div_mult_mult1 is now [simp] by default.<br/>INCOMPATIBILITY.<br/><br/>* Refinements to lattice classes and sets:<br/>  - less default intro/elim rules in locale variant, more default<br/>    intro/elim rules in class variant: more uniformity<br/>  - lemma ge_sup_conv renamed to le_sup_iff, in accordance with<br/>    le_inf_iff<br/>  - dropped lemma alias inf_ACI for inf_aci (same for sup_ACI and<br/>    sup_aci)<br/>  - renamed ACI to inf_sup_aci<br/>  - new class &quot;boolean_algebra&quot;<br/>  - class &quot;complete_lattice&quot; moved to separate theory<br/>    &quot;Complete_Lattice&quot;; corresponding constants (and abbreviations)<br/>    renamed and with authentic syntax:<br/>    Set.Inf ~&gt;    Complete_Lattice.Inf<br/>    Set.Sup ~&gt;    Complete_Lattice.Sup<br/>    Set.INFI ~&gt;   Complete_Lattice.INFI<br/>    Set.SUPR ~&gt;   Complete_Lattice.SUPR<br/>    Set.Inter ~&gt;  Complete_Lattice.Inter<br/>    Set.Union ~&gt;  Complete_Lattice.Union<br/>    Set.INTER ~&gt;  Complete_Lattice.INTER<br/>    Set.UNION ~&gt;  Complete_Lattice.UNION<br/>  - authentic syntax for<br/>    Set.Pow<br/>    Set.image<br/>  - mere abbreviations:<br/>    Set.empty               (for bot)<br/>    Set.UNIV                (for top)<br/>    Set.inter               (for inf, formerly Set.Int)<br/>    Set.union               (for sup, formerly Set.Un)<br/>    Complete_Lattice.Inter  (for Inf)<br/>    Complete_Lattice.Union  (for Sup)<br/>    Complete_Lattice.INTER  (for INFI)<br/>    Complete_Lattice.UNION  (for SUPR)<br/>  - object-logic definitions as far as appropriate<br/><br/>INCOMPATIBILITY.  Care is required when theorems Int_subset_iff or<br/>Un_subset_iff are explicitly deleted as default simp rules; then also<br/>their lattice counterparts le_inf_iff and le_sup_iff have to be<br/>deleted to achieve the desired effect.<br/><br/>* Rules inf_absorb1, inf_absorb2, sup_absorb1, sup_absorb2 are no simp<br/>rules by default any longer; the same applies to min_max.inf_absorb1<br/>etc.  INCOMPATIBILITY.<br/><br/>* Rules sup_Int_eq and sup_Un_eq are no longer declared as<br/>pred_set_conv by default.  INCOMPATIBILITY.<br/><br/>* Power operations on relations and functions are now one dedicated<br/>constant &quot;compow&quot; with infix syntax &quot;^^&quot;.  Power operation on<br/>multiplicative monoids retains syntax &quot;^&quot; and is now defined generic<br/>in class power.  INCOMPATIBILITY.<br/><br/>* Relation composition &quot;R O S&quot; now has a more standard argument order:<br/>&quot;R O S = {(x, z). EX y. (x, y) : R &amp; (y, z) : S}&quot;.  INCOMPATIBILITY,<br/>rewrite propositions with &quot;S O R&quot; --&gt; &quot;R O S&quot;. Proofs may occasionally<br/>break, since the O_assoc rule was not rewritten like this.  Fix using<br/>O_assoc[symmetric].  The same applies to the curried version &quot;R OO S&quot;.<br/><br/>* Function &quot;Inv&quot; is renamed to &quot;inv_into&quot; and function &quot;inv&quot; is now an<br/>abbreviation for &quot;inv_into UNIV&quot;.  Lemmas are renamed accordingly.<br/>INCOMPATIBILITY.<br/><br/>* Most rules produced by inductive and datatype package have mandatory<br/>prefixes.  INCOMPATIBILITY.<br/><br/>* Changed &quot;DERIV_intros&quot; to a dynamic fact, which can be augmented by<br/>the attribute of the same name.  Each of the theorems in the list<br/>DERIV_intros assumes composition with an additional function and<br/>matches a variable to the derivative, which has to be solved by the<br/>Simplifier.  Hence (auto intro!: DERIV_intros) computes the derivative<br/>of most elementary terms.  Former Maclauren.DERIV_tac and<br/>Maclauren.deriv_tac should be replaced by (auto intro!: DERIV_intros).<br/>INCOMPATIBILITY.<br/><br/>* Code generator attributes follow the usual underscore convention:<br/>    code_unfold     replaces    code unfold<br/>    code_post       replaces    code post<br/>    etc.<br/>  INCOMPATIBILITY.<br/><br/>* Renamed methods:<br/>    sizechange -&gt; size_change<br/>    induct_scheme -&gt; induction_schema<br/>  INCOMPATIBILITY.<br/><br/>* Discontinued abbreviation &quot;arbitrary&quot; of constant &quot;undefined&quot;.<br/>INCOMPATIBILITY, use &quot;undefined&quot; directly.<br/><br/>* Renamed theorems:<br/>    Suc_eq_add_numeral_1 -&gt; Suc_eq_plus1<br/>    Suc_eq_add_numeral_1_left -&gt; Suc_eq_plus1_left<br/>    Suc_plus1 -&gt; Suc_eq_plus1<br/>    *anti_sym -&gt; *antisym*<br/>    vector_less_eq_def -&gt; vector_le_def<br/>  INCOMPATIBILITY.<br/><br/>* Added theorem List.map_map as [simp].  Removed List.map_compose.<br/>INCOMPATIBILITY.<br/><br/>* Removed predicate &quot;M hassize n&quot; (&lt;--&gt; card M = n &amp; finite M).<br/>INCOMPATIBILITY.<br/><br/><br/>*** HOLCF ***<br/><br/>* Theory Representable defines a class &quot;rep&quot; of domains that are<br/>representable (via an ep-pair) in the universal domain type &quot;udom&quot;.<br/>Instances are provided for all type constructors defined in HOLCF.<br/><br/>* The &#39;new_domain&#39; command is a purely definitional version of the<br/>domain package, for representable domains.  Syntax is identical to the<br/>old domain package.  The &#39;new_domain&#39; package also supports indirect<br/>recursion using previously-defined type constructors.  See<br/>src/HOLCF/ex/New_Domain.thy for examples.<br/><br/>* Method &quot;fixrec_simp&quot; unfolds one step of a fixrec-defined constant<br/>on the left-hand side of an equation, and then performs<br/>simplification.  Rewriting is done using rules declared with the<br/>&quot;fixrec_simp&quot; attribute.  The &quot;fixrec_simp&quot; method is intended as a<br/>replacement for &quot;fixpat&quot;; see src/HOLCF/ex/Fixrec_ex.thy for examples.<br/><br/>* The pattern-match compiler in &#39;fixrec&#39; can now handle constructors<br/>with HOL function types.  Pattern-match combinators for the Pair<br/>constructor are pre-configured.<br/><br/>* The &#39;fixrec&#39; package now produces better fixed-point induction rules<br/>for mutually-recursive definitions:  Induction rules have conclusions<br/>of the form &quot;P foo bar&quot; instead of &quot;P &lt;foo, bar&gt;&quot;.<br/><br/>* The constant &quot;sq_le&quot; (with infix syntax &quot;&lt;&lt;&quot; or &quot;⊑&quot;) has<br/>been renamed to &quot;below&quot;.  The name &quot;below&quot; now replaces &quot;less&quot; in many<br/>theorem names.  (Legacy theorem names using &quot;less&quot; are still supported<br/>as well.)<br/><br/>* The &#39;fixrec&#39; package now supports &quot;bottom patterns&quot;.  Bottom<br/>patterns can be used to generate strictness rules, or to make<br/>functions more strict (much like the bang-patterns supported by the<br/>Glasgow Haskell Compiler).  See src/HOLCF/ex/Fixrec_ex.thy for<br/>examples.<br/><br/><br/>*** ML ***<br/><br/>* Support for Poly/ML 5.3.0, with improved reporting of compiler<br/>errors and run-time exceptions, including detailed source positions.<br/><br/>* Structure Name_Space (formerly NameSpace) now manages uniquely<br/>identified entries, with some additional information such as source<br/>position, logical grouping etc.<br/><br/>* Theory and context data is now introduced by the simplified and<br/>modernized functors Theory_Data, Proof_Data, Generic_Data.  Data needs<br/>to be pure, but the old TheoryDataFun for mutable data (with explicit<br/>copy operation) is still available for some time.<br/><br/>* Structure Synchronized (cf. src/Pure/Concurrent/synchronized.ML)<br/>provides a high-level programming interface to synchronized state<br/>variables with atomic update.  This works via pure function<br/>application within a critical section -- its runtime should be as<br/>short as possible; beware of deadlocks if critical code is nested,<br/>either directly or indirectly via other synchronized variables!<br/><br/>* Structure Unsynchronized (cf. src/Pure/ML-Systems/unsynchronized.ML)<br/>wraps raw ML references, explicitly indicating their non-thread-safe<br/>behaviour.  The Isar toplevel keeps this structure open, to<br/>accommodate Proof General as well as quick and dirty interactive<br/>experiments with references.<br/><br/>* PARALLEL_CHOICE and PARALLEL_GOALS provide basic support for<br/>parallel tactical reasoning.<br/><br/>* Tacticals Subgoal.FOCUS, Subgoal.FOCUS_PREMS, Subgoal.FOCUS_PARAMS<br/>are similar to SUBPROOF, but are slightly more flexible: only the<br/>specified parts of the subgoal are imported into the context, and the<br/>body tactic may introduce new subgoals and schematic variables.<br/><br/>* Old tactical METAHYPS, which does not observe the proof context, has<br/>been renamed to Old_Goals.METAHYPS and awaits deletion.  Use SUBPROOF<br/>or Subgoal.FOCUS etc.<br/><br/>* Renamed functor TableFun to Table, and GraphFun to Graph.  (Since<br/>functors have their own ML name space there is no point to mark them<br/>separately.)  Minor INCOMPATIBILITY.<br/><br/>* Renamed NamedThmsFun to Named_Thms.  INCOMPATIBILITY.<br/><br/>* Renamed several structures FooBar to Foo_Bar.  Occasional,<br/>INCOMPATIBILITY.<br/><br/>* Operations of structure Skip_Proof no longer require quick_and_dirty<br/>mode, which avoids critical setmp.<br/><br/>* Eliminated old Attrib.add_attributes, Method.add_methods and related<br/>combinators for &quot;args&quot;.  INCOMPATIBILITY, need to use simplified<br/>Attrib/Method.setup introduced in Isabelle2009.<br/><br/>* Proper context for simpset_of, claset_of, clasimpset_of.  May fall<br/>back on global_simpset_of, global_claset_of, global_clasimpset_of as<br/>last resort.  INCOMPATIBILITY.<br/><br/>* Display.pretty_thm now requires a proper context (cf. former<br/>ProofContext.pretty_thm).  May fall back on Display.pretty_thm_global<br/>or even Display.pretty_thm_without_context as last resort.<br/>INCOMPATIBILITY.<br/><br/>* Discontinued Display.pretty_ctyp/cterm etc.  INCOMPATIBILITY, use<br/>Syntax.pretty_typ/term directly, preferably with proper context<br/>instead of global theory.<br/><br/><br/>*** System ***<br/><br/>* Further fine tuning of parallel proof checking, scales up to 8 cores<br/>(max. speedup factor 5.0).  See also Goal.parallel_proofs in ML and<br/>usedir option -q.<br/><br/>* Support for additional &quot;Isabelle components&quot; via etc/components, see<br/>also the system manual.<br/><br/>* The isabelle makeall tool now operates on all components with<br/>IsaMakefile, not just hardwired &quot;logics&quot;.<br/><br/>* Removed &quot;compress&quot; option from isabelle-process and isabelle usedir;<br/>this is always enabled.<br/><br/>* Discontinued support for Poly/ML 4.x versions.<br/><br/>* Isabelle tool &quot;wwwfind&quot; provides web interface for &#39;find_theorems&#39;<br/>on a given logic image.  This requires the lighttpd webserver and is<br/>currently supported on Linux only.<br/><br/><br/><br/>New in Isabelle2009 (April 2009)<br/>--------------------------------<br/><br/>*** General ***<br/><br/>* Simplified main Isabelle executables, with less surprises on<br/>case-insensitive file-systems (such as Mac OS).<br/><br/>  - The main Isabelle tool wrapper is now called &quot;isabelle&quot; instead of<br/>    &quot;isatool.&quot;<br/><br/>  - The former &quot;isabelle&quot; alias for &quot;isabelle-process&quot; has been<br/>    removed (should rarely occur to regular users).<br/><br/>  - The former &quot;isabelle-interface&quot; and its alias &quot;Isabelle&quot; have been<br/>    removed (interfaces are now regular Isabelle tools).<br/><br/>Within scripts and make files, the Isabelle environment variables<br/>ISABELLE_TOOL and ISABELLE_PROCESS replace old ISATOOL and ISABELLE,<br/>respectively.  (The latter are still available as legacy feature.)<br/><br/>The old isabelle-interface wrapper could react in confusing ways if<br/>the interface was uninstalled or changed otherwise.  Individual<br/>interface tool configuration is now more explicit, see also the<br/>Isabelle system manual.  In particular, Proof General is now available<br/>via &quot;isabelle emacs&quot;.<br/><br/>INCOMPATIBILITY, need to adapt derivative scripts.  Users may need to<br/>purge installed copies of Isabelle executables and re-run &quot;isabelle<br/>install -p ...&quot;, or use symlinks.<br/><br/>* The default for ISABELLE_HOME_USER is now ~/.isabelle instead of the<br/>old ~/isabelle, which was slightly non-standard and apt to cause<br/>surprises on case-insensitive file-systems (such as Mac OS).<br/><br/>INCOMPATIBILITY, need to move existing ~/isabelle/etc,<br/>~/isabelle/heaps, ~/isabelle/browser_info to the new place.  Special<br/>care is required when using older releases of Isabelle.  Note that<br/>ISABELLE_HOME_USER can be changed in Isabelle/etc/settings of any<br/>Isabelle distribution, in order to use the new ~/.isabelle uniformly.<br/><br/>* Proofs of fully specified statements are run in parallel on<br/>multi-core systems.  A speedup factor of 2.5 to 3.2 can be expected on<br/>a regular 4-core machine, if the initial heap space is made reasonably<br/>large (cf. Poly/ML option -H).  (Requires Poly/ML 5.2.1 or later.)<br/><br/>* The main reference manuals (&quot;isar-ref&quot;, &quot;implementation&quot;, and<br/>&quot;system&quot;) have been updated and extended.  Formally checked references<br/>as hyperlinks are now available uniformly.<br/><br/><br/>*** Pure ***<br/><br/>* Complete re-implementation of locales.  INCOMPATIBILITY in several<br/>respects.  The most important changes are listed below.  See the<br/>Tutorial on Locales (&quot;locales&quot; manual) for details.<br/><br/>- In locale expressions, instantiation replaces renaming.  Parameters<br/>must be declared in a for clause.  To aid compatibility with previous<br/>parameter inheritance, in locale declarations, parameters that are not<br/>&#39;touched&#39; (instantiation position &quot;_&quot; or omitted) are implicitly added<br/>with their syntax at the beginning of the for clause.<br/><br/>- Syntax from abbreviations and definitions in locales is available in<br/>locale expressions and context elements.  The latter is particularly<br/>useful in locale declarations.<br/><br/>- More flexible mechanisms to qualify names generated by locale<br/>expressions.  Qualifiers (prefixes) may be specified in locale<br/>expressions, and can be marked as mandatory (syntax: &quot;name!:&quot;) or<br/>optional (syntax &quot;name?:&quot;).  The default depends for plain &quot;name:&quot;<br/>depends on the situation where a locale expression is used: in<br/>commands &#39;locale&#39; and &#39;sublocale&#39; prefixes are optional, in<br/>&#39;interpretation&#39; and &#39;interpret&#39; prefixes are mandatory.  The old<br/>implicit qualifiers derived from the parameter names of a locale are<br/>no longer generated.<br/><br/>- Command &quot;sublocale l &lt; e&quot; replaces &quot;interpretation l &lt; e&quot;.  The<br/>instantiation clause in &quot;interpretation&quot; and &quot;interpret&quot; (square<br/>brackets) is no longer available.  Use locale expressions.<br/><br/>- When converting proof scripts, mandatory qualifiers in<br/>&#39;interpretation&#39; and &#39;interpret&#39; should be retained by default, even<br/>if this is an INCOMPATIBILITY compared to former behavior.  In the<br/>worst case, use the &quot;name?:&quot; form for non-mandatory ones.  Qualifiers<br/>in locale expressions range over a single locale instance only.<br/><br/>- Dropped locale element &quot;includes&quot;.  This is a major INCOMPATIBILITY.<br/>In existing theorem specifications replace the includes element by the<br/>respective context elements of the included locale, omitting those<br/>that are already present in the theorem specification.  Multiple<br/>assume elements of a locale should be replaced by a single one<br/>involving the locale predicate.  In the proof body, declarations (most<br/>notably theorems) may be regained by interpreting the respective<br/>locales in the proof context as required (command &quot;interpret&quot;).<br/><br/>If using &quot;includes&quot; in replacement of a target solely because the<br/>parameter types in the theorem are not as general as in the target,<br/>consider declaring a new locale with additional type constraints on<br/>the parameters (context element &quot;constrains&quot;).<br/><br/>- Discontinued &quot;locale (open)&quot;.  INCOMPATIBILITY.<br/><br/>- Locale interpretation commands no longer attempt to simplify goal.<br/>INCOMPATIBILITY: in rare situations the generated goal differs.  Use<br/>methods intro_locales and unfold_locales to clarify.<br/><br/>- Locale interpretation commands no longer accept interpretation<br/>attributes.  INCOMPATIBILITY.<br/><br/>* Class declaration: so-called &quot;base sort&quot; must not be given in import<br/>list any longer, but is inferred from the specification.  Particularly<br/>in HOL, write<br/><br/>    class foo = ...<br/><br/>instead of<br/><br/>    class foo = type + ...<br/><br/>* Class target: global versions of theorems stemming do not carry a<br/>parameter prefix any longer.  INCOMPATIBILITY.<br/><br/>* Class &#39;instance&#39; command no longer accepts attached definitions.<br/>INCOMPATIBILITY, use proper &#39;instantiation&#39; target instead.<br/><br/>* Recovered hiding of consts, which was accidentally broken in<br/>Isabelle2007.  Potential INCOMPATIBILITY, ``hide const c&#39;&#39; really<br/>makes c inaccessible; consider using ``hide (open) const c&#39;&#39; instead.<br/><br/>* Slightly more coherent Pure syntax, with updated documentation in<br/>isar-ref manual.  Removed locales meta_term_syntax and<br/>meta_conjunction_syntax: TERM and &amp;&amp;&amp; (formerly &amp;&amp;) are now permanent,<br/>INCOMPATIBILITY in rare situations.  Note that &amp;&amp;&amp; should not be used<br/>directly in regular applications.<br/><br/>* There is a new syntactic category &quot;float_const&quot; for signed decimal<br/>fractions (e.g. 123.45 or -123.45).<br/><br/>* Removed exotic &#39;token_translation&#39; command.  INCOMPATIBILITY, use ML<br/>interface with &#39;setup&#39; command instead.<br/><br/>* Command &#39;local_setup&#39; is similar to &#39;setup&#39;, but operates on a local<br/>theory context.<br/><br/>* The &#39;axiomatization&#39; command now only works within a global theory<br/>context.  INCOMPATIBILITY.<br/><br/>* Goal-directed proof now enforces strict proof irrelevance wrt. sort<br/>hypotheses.  Sorts required in the course of reasoning need to be<br/>covered by the constraints in the initial statement, completed by the<br/>type instance information of the background theory.  Non-trivial sort<br/>hypotheses, which rarely occur in practice, may be specified via<br/>vacuous propositions of the form SORT_CONSTRAINT(&#39;a::c).  For example:<br/><br/>  lemma assumes &quot;SORT_CONSTRAINT(&#39;a::empty)&quot; shows False ...<br/><br/>The result contains an implicit sort hypotheses as before --<br/>SORT_CONSTRAINT premises are eliminated as part of the canonical rule<br/>normalization.<br/><br/>* Generalized Isar history, with support for linear undo, direct state<br/>addressing etc.<br/><br/>* Changed defaults for unify configuration options:<br/><br/>  unify_trace_bound = 50 (formerly 25)<br/>  unify_search_bound = 60 (formerly 30)<br/><br/>* Different bookkeeping for code equations (INCOMPATIBILITY):<br/><br/>  a) On theory merge, the last set of code equations for a particular<br/>     constant is taken (in accordance with the policy applied by other<br/>     parts of the code generator framework).<br/><br/>  b) Code equations stemming from explicit declarations (e.g. code<br/>     attribute) gain priority over default code equations stemming<br/>     from definition, primrec, fun etc.<br/><br/>* Keyword &#39;code_exception&#39; now named &#39;code_abort&#39;.  INCOMPATIBILITY.<br/><br/>* Unified theorem tables for both code generators.  Thus [code<br/>func] has disappeared and only [code] remains.  INCOMPATIBILITY.<br/><br/>* Command &#39;find_consts&#39; searches for constants based on type and name<br/>patterns, e.g.<br/><br/>    find_consts &quot;_ =&gt; bool&quot;<br/><br/>By default, matching is against subtypes, but it may be restricted to<br/>the whole type.  Searching by name is possible.  Multiple queries are<br/>conjunctive and queries may be negated by prefixing them with a<br/>hyphen:<br/><br/>    find_consts strict: &quot;_ =&gt; bool&quot; name: &quot;Int&quot; -&quot;int =&gt; int&quot;<br/><br/>* New &#39;find_theorems&#39; criterion &quot;solves&quot; matches theorems that<br/>directly solve the current goal (modulo higher-order unification).<br/><br/>* Auto solve feature for main theorem statements: whenever a new goal<br/>is stated, &quot;find_theorems solves&quot; is called; any theorems that could<br/>solve the lemma directly are listed as part of the goal state.<br/>Cf. associated options in Proof General Isabelle settings menu,<br/>enabled by default, with reasonable timeout for pathological cases of<br/>higher-order unification.<br/><br/><br/>*** Document preparation ***<br/><br/>* Antiquotation @{lemma} now imitates a regular terminal proof,<br/>demanding keyword &#39;by&#39; and supporting the full method expression<br/>syntax just like the Isar command &#39;by&#39;.<br/><br/><br/>*** HOL ***<br/><br/>* Integrated main parts of former image HOL-Complex with HOL.  Entry<br/>points Main and Complex_Main remain as before.<br/><br/>* Logic image HOL-Plain provides a minimal HOL with the most important<br/>tools available (inductive, datatype, primrec, ...).  This facilitates<br/>experimentation and tool development.  Note that user applications<br/>(and library theories) should never refer to anything below theory<br/>Main, as before.<br/><br/>* Logic image HOL-Main stops at theory Main, and thus facilitates<br/>experimentation due to shorter build times.<br/><br/>* Logic image HOL-NSA contains theories of nonstandard analysis which<br/>were previously part of former HOL-Complex.  Entry point Hyperreal<br/>remains valid, but theories formerly using Complex_Main should now use<br/>new entry point Hypercomplex.<br/><br/>* Generic ATP manager for Sledgehammer, based on ML threads instead of<br/>Posix processes.  Avoids potentially expensive forking of the ML<br/>process.  New thread-based implementation also works on non-Unix<br/>platforms (Cygwin).  Provers are no longer hardwired, but defined<br/>within the theory via plain ML wrapper functions.  Basic Sledgehammer<br/>commands are covered in the isar-ref manual.<br/><br/>* Wrapper scripts for remote SystemOnTPTP service allows to use<br/>sledgehammer without local ATP installation (Vampire etc.). Other<br/>provers may be included via suitable ML wrappers, see also<br/>src/HOL/ATP_Linkup.thy.<br/><br/>* ATP selection (E/Vampire/Spass) is now via Proof General&#39;s settings<br/>menu.<br/><br/>* The metis method no longer fails because the theorem is too trivial<br/>(contains the empty clause).<br/><br/>* The metis method now fails in the usual manner, rather than raising<br/>an exception, if it determines that it cannot prove the theorem.<br/><br/>* Method &quot;coherent&quot; implements a prover for coherent logic (see also<br/>src/Tools/coherent.ML).<br/><br/>* Constants &quot;undefined&quot; and &quot;default&quot; replace &quot;arbitrary&quot;.  Usually<br/>&quot;undefined&quot; is the right choice to replace &quot;arbitrary&quot;, though<br/>logically there is no difference.  INCOMPATIBILITY.<br/><br/>* Command &quot;value&quot; now integrates different evaluation mechanisms.  The<br/>result of the first successful evaluation mechanism is printed.  In<br/>square brackets a particular named evaluation mechanisms may be<br/>specified (currently, [SML], [code] or [nbe]).  See further<br/>src/HOL/ex/Eval_Examples.thy.<br/><br/>* Normalization by evaluation now allows non-leftlinear equations.<br/>Declare with attribute [code nbe].<br/><br/>* Methods &quot;case_tac&quot; and &quot;induct_tac&quot; now refer to the very same rules<br/>as the structured Isar versions &quot;cases&quot; and &quot;induct&quot;, cf. the<br/>corresponding &quot;cases&quot; and &quot;induct&quot; attributes.  Mutual induction rules<br/>are now presented as a list of individual projections<br/>(e.g. foo_bar.inducts for types foo and bar); the old format with<br/>explicit HOL conjunction is no longer supported.  INCOMPATIBILITY, in<br/>rare situations a different rule is selected --- notably nested tuple<br/>elimination instead of former prod.exhaust: use explicit (case_tac t<br/>rule: prod.exhaust) here.<br/><br/>* Attributes &quot;cases&quot;, &quot;induct&quot;, &quot;coinduct&quot; support &quot;del&quot; option.<br/><br/>* Removed fact &quot;case_split_thm&quot;, which duplicates &quot;case_split&quot;.<br/><br/>* The option datatype has been moved to a new theory Option.  Renamed<br/>option_map to Option.map, and o2s to Option.set, INCOMPATIBILITY.<br/><br/>* New predicate &quot;strict_mono&quot; classifies strict functions on partial<br/>orders.  With strict functions on linear orders, reasoning about<br/>(in)equalities is facilitated by theorems &quot;strict_mono_eq&quot;,<br/>&quot;strict_mono_less_eq&quot; and &quot;strict_mono_less&quot;.<br/><br/>* Some set operations are now proper qualified constants with<br/>authentic syntax.  INCOMPATIBILITY:<br/><br/>    op Int ~&gt;   Set.Int<br/>    op Un ~&gt;    Set.Un<br/>    INTER ~&gt;    Set.INTER<br/>    UNION ~&gt;    Set.UNION<br/>    Inter ~&gt;    Set.Inter<br/>    Union ~&gt;    Set.Union<br/>    {} ~&gt;       Set.empty<br/>    UNIV ~&gt;     Set.UNIV<br/><br/>* Class complete_lattice with operations Inf, Sup, INFI, SUPR now in<br/>theory Set.<br/><br/>* Auxiliary class &quot;itself&quot; has disappeared -- classes without any<br/>parameter are treated as expected by the &#39;class&#39; command.<br/><br/>* Leibnitz&#39;s Series for Pi and the arcus tangens and logarithm series.<br/><br/>* Common decision procedures (Cooper, MIR, Ferrack, Approximation,<br/>Dense_Linear_Order) are now in directory HOL/Decision_Procs.<br/><br/>* Theory src/HOL/Decision_Procs/Approximation provides the new proof<br/>method &quot;approximation&quot;.  It proves formulas on real values by using<br/>interval arithmetic.  In the formulas are also the transcendental<br/>functions sin, cos, tan, atan, ln, exp and the constant pi are<br/>allowed. For examples see<br/>src/HOL/Descision_Procs/ex/Approximation_Ex.thy.<br/><br/>* Theory &quot;Reflection&quot; now resides in HOL/Library.<br/><br/>* Entry point to Word library now simply named &quot;Word&quot;.<br/>INCOMPATIBILITY.<br/><br/>* Made source layout more coherent with logical distribution<br/>structure:<br/><br/>    src/HOL/Library/RType.thy ~&gt; src/HOL/Typerep.thy<br/>    src/HOL/Library/Code_Message.thy ~&gt; src/HOL/<br/>    src/HOL/Library/GCD.thy ~&gt; src/HOL/<br/>    src/HOL/Library/Order_Relation.thy ~&gt; src/HOL/<br/>    src/HOL/Library/Parity.thy ~&gt; src/HOL/<br/>    src/HOL/Library/Univ_Poly.thy ~&gt; src/HOL/<br/>    src/HOL/Real/ContNotDenum.thy ~&gt; src/HOL/Library/<br/>    src/HOL/Real/Lubs.thy ~&gt; src/HOL/<br/>    src/HOL/Real/PReal.thy ~&gt; src/HOL/<br/>    src/HOL/Real/Rational.thy ~&gt; src/HOL/<br/>    src/HOL/Real/RComplete.thy ~&gt; src/HOL/<br/>    src/HOL/Real/RealDef.thy ~&gt; src/HOL/<br/>    src/HOL/Real/RealPow.thy ~&gt; src/HOL/<br/>    src/HOL/Real/Real.thy ~&gt; src/HOL/<br/>    src/HOL/Complex/Complex_Main.thy ~&gt; src/HOL/<br/>    src/HOL/Complex/Complex.thy ~&gt; src/HOL/<br/>    src/HOL/Complex/FrechetDeriv.thy ~&gt; src/HOL/Library/<br/>    src/HOL/Complex/Fundamental_Theorem_Algebra.thy ~&gt; src/HOL/Library/<br/>    src/HOL/Hyperreal/Deriv.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Fact.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Integration.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Lim.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Ln.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Log.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/MacLaurin.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/NthRoot.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Series.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/SEQ.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Taylor.thy ~&gt; src/HOL/<br/>    src/HOL/Hyperreal/Transcendental.thy ~&gt; src/HOL/<br/>    src/HOL/Real/Float ~&gt; src/HOL/Library/<br/>    src/HOL/Real/HahnBanach ~&gt; src/HOL/HahnBanach<br/>    src/HOL/Real/RealVector.thy ~&gt; src/HOL/<br/><br/>    src/HOL/arith_data.ML ~&gt; src/HOL/Tools<br/>    src/HOL/hologic.ML ~&gt; src/HOL/Tools<br/>    src/HOL/simpdata.ML ~&gt; src/HOL/Tools<br/>    src/HOL/int_arith1.ML ~&gt; src/HOL/Tools/int_arith.ML<br/>    src/HOL/int_factor_simprocs.ML ~&gt; src/HOL/Tools<br/>    src/HOL/nat_simprocs.ML ~&gt; src/HOL/Tools<br/>    src/HOL/Real/float_arith.ML ~&gt; src/HOL/Tools<br/>    src/HOL/Real/float_syntax.ML ~&gt; src/HOL/Tools<br/>    src/HOL/Real/rat_arith.ML ~&gt; src/HOL/Tools<br/>    src/HOL/Real/real_arith.ML ~&gt; src/HOL/Tools<br/><br/>    src/HOL/Library/Array.thy ~&gt; src/HOL/Imperative_HOL<br/>    src/HOL/Library/Heap_Monad.thy ~&gt; src/HOL/Imperative_HOL<br/>    src/HOL/Library/Heap.thy ~&gt; src/HOL/Imperative_HOL<br/>    src/HOL/Library/Imperative_HOL.thy ~&gt; src/HOL/Imperative_HOL<br/>    src/HOL/Library/Ref.thy ~&gt; src/HOL/Imperative_HOL<br/>    src/HOL/Library/Relational.thy ~&gt; src/HOL/Imperative_HOL<br/><br/>* If methods &quot;eval&quot; and &quot;evaluation&quot; encounter a structured proof<br/>state with !!/==&gt;, only the conclusion is evaluated to True (if<br/>possible), avoiding strange error messages.<br/><br/>* Method &quot;sizechange&quot; automates termination proofs using (a<br/>modification of) the size-change principle.  Requires SAT solver.  See<br/>src/HOL/ex/Termination.thy for examples.<br/><br/>* Simplifier: simproc for let expressions now unfolds if bound<br/>variable occurs at most once in let expression body.  INCOMPATIBILITY.<br/><br/>* Method &quot;arith&quot;: Linear arithmetic now ignores all inequalities when<br/>fast_arith_neq_limit is exceeded, instead of giving up entirely.<br/><br/>* New attribute &quot;arith&quot; for facts that should always be used<br/>automatically by arithmetic. It is intended to be used locally in<br/>proofs, e.g.<br/><br/>  assumes [arith]: &quot;x &gt; 0&quot;<br/><br/>Global usage is discouraged because of possible performance impact.<br/><br/>* New classes &quot;top&quot; and &quot;bot&quot; with corresponding operations &quot;top&quot; and<br/>&quot;bot&quot; in theory Orderings; instantiation of class &quot;complete_lattice&quot;<br/>requires instantiation of classes &quot;top&quot; and &quot;bot&quot;.  INCOMPATIBILITY.<br/><br/>* Changed definition lemma &quot;less_fun_def&quot; in order to provide an<br/>instance for preorders on functions; use lemma &quot;less_le&quot; instead.<br/>INCOMPATIBILITY.<br/><br/>* Theory Orderings: class &quot;wellorder&quot; moved here, with explicit<br/>induction rule &quot;less_induct&quot; as assumption.  For instantiation of<br/>&quot;wellorder&quot; by means of predicate &quot;wf&quot;, use rule wf_wellorderI.<br/>INCOMPATIBILITY.<br/><br/>* Theory Orderings: added class &quot;preorder&quot; as superclass of &quot;order&quot;.<br/>INCOMPATIBILITY: Instantiation proofs for order, linorder<br/>etc. slightly changed.  Some theorems named order_class.* now named<br/>preorder_class.*.<br/><br/>* Theory Relation: renamed &quot;refl&quot; to &quot;refl_on&quot;, &quot;reflexive&quot; to &quot;refl,<br/>&quot;diag&quot; to &quot;Id_on&quot;.<br/><br/>* Theory Finite_Set: added a new fold combinator of type<br/><br/>  (&#39;a =&gt; &#39;b =&gt; &#39;b) =&gt; &#39;b =&gt; &#39;a set =&gt; &#39;b<br/><br/>Occasionally this is more convenient than the old fold combinator<br/>which is now defined in terms of the new one and renamed to<br/>fold_image.<br/><br/>* Theories Ring_and_Field and OrderedGroup: The lemmas &quot;group_simps&quot;<br/>and &quot;ring_simps&quot; have been replaced by &quot;algebra_simps&quot; (which can be<br/>extended with further lemmas!).  At the moment both still exist but<br/>the former will disappear at some point.<br/><br/>* Theory Power: Lemma power_Suc is now declared as a simp rule in<br/>class recpower.  Type-specific simp rules for various recpower types<br/>have been removed.  INCOMPATIBILITY, rename old lemmas as follows:<br/><br/>rat_power_0    -&gt; power_0<br/>rat_power_Suc  -&gt; power_Suc<br/>realpow_0      -&gt; power_0<br/>realpow_Suc    -&gt; power_Suc<br/>complexpow_0   -&gt; power_0<br/>complexpow_Suc -&gt; power_Suc<br/>power_poly_0   -&gt; power_0<br/>power_poly_Suc -&gt; power_Suc<br/><br/>* Theories Ring_and_Field and Divides: Definition of &quot;op dvd&quot; has been<br/>moved to separate class dvd in Ring_and_Field; a couple of lemmas on<br/>dvd has been generalized to class comm_semiring_1.  Likewise a bunch<br/>of lemmas from Divides has been generalized from nat to class<br/>semiring_div.  INCOMPATIBILITY.  This involves the following theorem<br/>renames resulting from duplicate elimination:<br/><br/>    dvd_def_mod ~&gt;          dvd_eq_mod_eq_0<br/>    zero_dvd_iff ~&gt;         dvd_0_left_iff<br/>    dvd_0 ~&gt;                dvd_0_right<br/>    DIVISION_BY_ZERO_DIV ~&gt; div_by_0<br/>    DIVISION_BY_ZERO_MOD ~&gt; mod_by_0<br/>    mult_div ~&gt;             div_mult_self2_is_id<br/>    mult_mod ~&gt;             mod_mult_self2_is_0<br/><br/>* Theory IntDiv: removed many lemmas that are instances of class-based<br/>generalizations (from Divides and Ring_and_Field).  INCOMPATIBILITY,<br/>rename old lemmas as follows:<br/><br/>dvd_diff               -&gt; nat_dvd_diff<br/>dvd_zminus_iff         -&gt; dvd_minus_iff<br/>mod_add1_eq            -&gt; mod_add_eq<br/>mod_mult1_eq           -&gt; mod_mult_right_eq<br/>mod_mult1_eq&#39;          -&gt; mod_mult_left_eq<br/>mod_mult_distrib_mod   -&gt; mod_mult_eq<br/>nat_mod_add_left_eq    -&gt; mod_add_left_eq<br/>nat_mod_add_right_eq   -&gt; mod_add_right_eq<br/>nat_mod_div_trivial    -&gt; mod_div_trivial<br/>nat_mod_mod_trivial    -&gt; mod_mod_trivial<br/>zdiv_zadd_self1        -&gt; div_add_self1<br/>zdiv_zadd_self2        -&gt; div_add_self2<br/>zdiv_zmult_self1       -&gt; div_mult_self2_is_id<br/>zdiv_zmult_self2       -&gt; div_mult_self1_is_id<br/>zdvd_triv_left         -&gt; dvd_triv_left<br/>zdvd_triv_right        -&gt; dvd_triv_right<br/>zdvd_zmult_cancel_disj -&gt; dvd_mult_cancel_left<br/>zmod_eq0_zdvd_iff      -&gt; dvd_eq_mod_eq_0[symmetric]<br/>zmod_zadd_left_eq      -&gt; mod_add_left_eq<br/>zmod_zadd_right_eq     -&gt; mod_add_right_eq<br/>zmod_zadd_self1        -&gt; mod_add_self1<br/>zmod_zadd_self2        -&gt; mod_add_self2<br/>zmod_zadd1_eq          -&gt; mod_add_eq<br/>zmod_zdiff1_eq         -&gt; mod_diff_eq<br/>zmod_zdvd_zmod         -&gt; mod_mod_cancel<br/>zmod_zmod_cancel       -&gt; mod_mod_cancel<br/>zmod_zmult_self1       -&gt; mod_mult_self2_is_0<br/>zmod_zmult_self2       -&gt; mod_mult_self1_is_0<br/>zmod_1                 -&gt; mod_by_1<br/>zdiv_1                 -&gt; div_by_1<br/>zdvd_abs1              -&gt; abs_dvd_iff<br/>zdvd_abs2              -&gt; dvd_abs_iff<br/>zdvd_refl              -&gt; dvd_refl<br/>zdvd_trans             -&gt; dvd_trans<br/>zdvd_zadd              -&gt; dvd_add<br/>zdvd_zdiff             -&gt; dvd_diff<br/>zdvd_zminus_iff        -&gt; dvd_minus_iff<br/>zdvd_zminus2_iff       -&gt; minus_dvd_iff<br/>zdvd_zmultD            -&gt; dvd_mult_right<br/>zdvd_zmultD2           -&gt; dvd_mult_left<br/>zdvd_zmult_mono        -&gt; mult_dvd_mono<br/>zdvd_0_right           -&gt; dvd_0_right<br/>zdvd_0_left            -&gt; dvd_0_left_iff<br/>zdvd_1_left            -&gt; one_dvd<br/>zminus_dvd_iff         -&gt; minus_dvd_iff<br/><br/>* Theory Rational: &#39;Fract k 0&#39; now equals &#39;0&#39;.  INCOMPATIBILITY.<br/><br/>* The real numbers offer decimal input syntax: 12.34 is translated<br/>into 1234/10^2. This translation is not reversed upon output.<br/><br/>* Theory Library/Polynomial defines an abstract type &#39;a poly of<br/>univariate polynomials with coefficients of type &#39;a.  In addition to<br/>the standard ring operations, it also supports div and mod.  Code<br/>generation is also supported, using list-style constructors.<br/><br/>* Theory Library/Inner_Product defines a class of real_inner for real<br/>inner product spaces, with an overloaded operation inner :: &#39;a =&gt; &#39;a<br/>=&gt; real.  Class real_inner is a subclass of real_normed_vector from<br/>theory RealVector.<br/><br/>* Theory Library/Product_Vector provides instances for the product<br/>type &#39;a * &#39;b of several classes from RealVector and Inner_Product.<br/>Definitions of addition, subtraction, scalar multiplication, norms,<br/>and inner products are included.<br/><br/>* Theory Library/Bit defines the field &quot;bit&quot; of integers modulo 2.  In<br/>addition to the field operations, numerals and case syntax are also<br/>supported.<br/><br/>* Theory Library/Diagonalize provides constructive version of Cantor&#39;s<br/>first diagonalization argument.<br/><br/>* Theory Library/GCD: Curried operations gcd, lcm (for nat) and zgcd,<br/>zlcm (for int); carried together from various gcd/lcm developements in<br/>the HOL Distribution.  Constants zgcd and zlcm replace former igcd and<br/>ilcm; corresponding theorems renamed accordingly.  INCOMPATIBILITY,<br/>may recover tupled syntax as follows:<br/><br/>    hide (open) const gcd<br/>    abbreviation gcd where<br/>      &quot;gcd == (%(a, b). GCD.gcd a b)&quot;<br/>    notation (output)<br/>      GCD.gcd (&quot;gcd &#39;(_, _&#39;)&quot;)<br/><br/>The same works for lcm, zgcd, zlcm.<br/><br/>* Theory Library/Nat_Infinity: added addition, numeral syntax and more<br/>instantiations for algebraic structures.  Removed some duplicate<br/>theorems.  Changes in simp rules.  INCOMPATIBILITY.<br/><br/>* ML antiquotation @{code} takes a constant as argument and generates<br/>corresponding code in background and inserts name of the corresponding<br/>resulting ML value/function/datatype constructor binding in place.<br/>All occurrences of @{code} with a single ML block are generated<br/>simultaneously.  Provides a generic and safe interface for<br/>instrumentalizing code generation.  See<br/>src/HOL/Decision_Procs/Ferrack.thy for a more ambitious application.<br/>In future you ought to refrain from ad-hoc compiling generated SML<br/>code on the ML toplevel.  Note that (for technical reasons) @{code}<br/>cannot refer to constants for which user-defined serializations are<br/>set.  Refer to the corresponding ML counterpart directly in that<br/>cases.<br/><br/>* Command &#39;rep_datatype&#39;: instead of theorem names the command now<br/>takes a list of terms denoting the constructors of the type to be<br/>represented as datatype.  The characteristic theorems have to be<br/>proven.  INCOMPATIBILITY.  Also observe that the following theorems<br/>have disappeared in favour of existing ones:<br/><br/>    unit_induct                 ~&gt; unit.induct<br/>    prod_induct                 ~&gt; prod.induct<br/>    sum_induct                  ~&gt; sum.induct<br/>    Suc_Suc_eq                  ~&gt; nat.inject<br/>    Suc_not_Zero Zero_not_Suc   ~&gt; nat.distinct<br/><br/><br/>*** HOL-Algebra ***<br/><br/>* New locales for orders and lattices where the equivalence relation<br/>is not restricted to equality.  INCOMPATIBILITY: all order and lattice<br/>locales use a record structure with field eq for the equivalence.<br/><br/>* New theory of factorial domains.<br/><br/>* Units_l_inv and Units_r_inv are now simp rules by default.<br/>INCOMPATIBILITY.  Simplifier proof that require deletion of l_inv<br/>and/or r_inv will now also require deletion of these lemmas.<br/><br/>* Renamed the following theorems, INCOMPATIBILITY:<br/><br/>UpperD ~&gt; Upper_memD<br/>LowerD ~&gt; Lower_memD<br/>least_carrier ~&gt; least_closed<br/>greatest_carrier ~&gt; greatest_closed<br/>greatest_Lower_above ~&gt; greatest_Lower_below<br/>one_zero ~&gt; carrier_one_zero<br/>one_not_zero ~&gt; carrier_one_not_zero  (collision with assumption)<br/><br/><br/>*** HOL-Nominal ***<br/><br/>* Nominal datatypes can now contain type-variables.<br/><br/>* Commands &#39;nominal_inductive&#39; and &#39;equivariance&#39; work with local<br/>theory targets.<br/><br/>* Nominal primrec can now works with local theory targets and its<br/>specification syntax now conforms to the general format as seen in<br/>&#39;inductive&#39; etc.<br/><br/>* Method &quot;perm_simp&quot; honours the standard simplifier attributes<br/>(no_asm), (no_asm_use) etc.<br/><br/>* The new predicate #* is defined like freshness, except that on the<br/>left hand side can be a set or list of atoms.<br/><br/>* Experimental command &#39;nominal_inductive2&#39; derives strong induction<br/>principles for inductive definitions.  In contrast to<br/>&#39;nominal_inductive&#39;, which can only deal with a fixed number of<br/>binders, it can deal with arbitrary expressions standing for sets of<br/>atoms to be avoided.  The only inductive definition we have at the<br/>moment that needs this generalisation is the typing rule for Lets in<br/>the algorithm W:<br/><br/> Gamma |- t1 : T1   (x,close Gamma T1)::Gamma |- t2 : T2   x#Gamma<br/> -----------------------------------------------------------------<br/>         Gamma |- Let x be t1 in t2 : T2<br/><br/>In this rule one wants to avoid all the binders that are introduced by<br/>&quot;close Gamma T1&quot;.  We are looking for other examples where this<br/>feature might be useful.  Please let us know.<br/><br/><br/>*** HOLCF ***<br/><br/>* Reimplemented the simplification procedure for proving continuity<br/>subgoals.  The new simproc is extensible; users can declare additional<br/>continuity introduction rules with the attribute [cont2cont].<br/><br/>* The continuity simproc now uses a different introduction rule for<br/>solving continuity subgoals on terms with lambda abstractions.  In<br/>some rare cases the new simproc may fail to solve subgoals that the<br/>old one could solve, and &quot;simp add: cont2cont_LAM&quot; may be necessary.<br/>Potential INCOMPATIBILITY.<br/><br/>* Command &#39;fixrec&#39;: specification syntax now conforms to the general<br/>format as seen in &#39;inductive&#39; etc.  See src/HOLCF/ex/Fixrec_ex.thy for<br/>examples.  INCOMPATIBILITY.<br/><br/><br/>*** ZF ***<br/><br/>* Proof of Zorn&#39;s Lemma for partial orders.<br/><br/><br/>*** ML ***<br/><br/>* Multithreading for Poly/ML 5.1/5.2 is no longer supported, only for<br/>Poly/ML 5.2.1 or later.  Important note: the TimeLimit facility<br/>depends on multithreading, so timouts will not work before Poly/ML<br/>5.2.1!<br/><br/>* High-level support for concurrent ML programming, see<br/>src/Pure/Cuncurrent.  The data-oriented model of &quot;future values&quot; is<br/>particularly convenient to organize independent functional<br/>computations.  The concept of &quot;synchronized variables&quot; provides a<br/>higher-order interface for components with shared state, avoiding the<br/>delicate details of mutexes and condition variables.  (Requires<br/>Poly/ML 5.2.1 or later.)<br/><br/>* ML bindings produced via Isar commands are stored within the Isar<br/>context (theory or proof).  Consequently, commands like &#39;use&#39; and &#39;ML&#39;<br/>become thread-safe and work with undo as expected (concerning<br/>top-level bindings, not side-effects on global references).<br/>INCOMPATIBILITY, need to provide proper Isar context when invoking the<br/>compiler at runtime; really global bindings need to be given outside a<br/>theory.  (Requires Poly/ML 5.2 or later.)<br/><br/>* Command &#39;ML_prf&#39; is analogous to &#39;ML&#39; but works within a proof<br/>context.  Top-level ML bindings are stored within the proof context in<br/>a purely sequential fashion, disregarding the nested proof structure.<br/>ML bindings introduced by &#39;ML_prf&#39; are discarded at the end of the<br/>proof.  (Requires Poly/ML 5.2 or later.)<br/><br/>* Simplified ML attribute and method setup, cf. functions Attrib.setup<br/>and Method.setup, as well as Isar commands &#39;attribute_setup&#39; and<br/>&#39;method_setup&#39;.  INCOMPATIBILITY for &#39;method_setup&#39;, need to simplify<br/>existing code accordingly, or use plain &#39;setup&#39; together with old<br/>Method.add_method.<br/><br/>* Simplified ML oracle interface Thm.add_oracle promotes &#39;a -&gt; cterm<br/>to &#39;a -&gt; thm, while results are always tagged with an authentic oracle<br/>name.  The Isar command &#39;oracle&#39; is now polymorphic, no argument type<br/>is specified.  INCOMPATIBILITY, need to simplify existing oracle code<br/>accordingly.  Note that extra performance may be gained by producing<br/>the cterm carefully, avoiding slow Thm.cterm_of.<br/><br/>* Simplified interface for defining document antiquotations via<br/>ThyOutput.antiquotation, ThyOutput.output, and optionally<br/>ThyOutput.maybe_pretty_source.  INCOMPATIBILITY, need to simplify user<br/>antiquotations accordingly, see src/Pure/Thy/thy_output.ML for common<br/>examples.<br/><br/>* More systematic treatment of long names, abstract name bindings, and<br/>name space operations.  Basic operations on qualified names have been<br/>move from structure NameSpace to Long_Name, e.g. Long_Name.base_name,<br/>Long_Name.append.  Old type bstring has been mostly replaced by<br/>abstract type binding (see structure Binding), which supports precise<br/>qualification by packages and local theory targets, as well as proper<br/>tracking of source positions.  INCOMPATIBILITY, need to wrap old<br/>bstring values into Binding.name, or better pass through abstract<br/>bindings everywhere.  See further src/Pure/General/long_name.ML,<br/>src/Pure/General/binding.ML and src/Pure/General/name_space.ML<br/><br/>* Result facts (from PureThy.note_thms, ProofContext.note_thms,<br/>LocalTheory.note etc.) now refer to the *full* internal name, not the<br/>bstring as before.  INCOMPATIBILITY, not detected by ML type-checking!<br/><br/>* Disposed old type and term read functions (Sign.read_def_typ,<br/>Sign.read_typ, Sign.read_def_terms, Sign.read_term,<br/>Thm.read_def_cterms, Thm.read_cterm etc.).  INCOMPATIBILITY, should<br/>use regular Syntax.read_typ, Syntax.read_term, Syntax.read_typ_global,<br/>Syntax.read_term_global etc.; see also OldGoals.read_term as last<br/>resort for legacy applications.<br/><br/>* Disposed old declarations, tactics, tactic combinators that refer to<br/>the simpset or claset of an implicit theory (such as Addsimps,<br/>Simp_tac, SIMPSET).  INCOMPATIBILITY, should use @{simpset} etc. in<br/>embedded ML text, or local_simpset_of with a proper context passed as<br/>explicit runtime argument.<br/><br/>* Rules and tactics that read instantiations (read_instantiate,<br/>res_inst_tac, thin_tac, subgoal_tac etc.) now demand a proper proof<br/>context, which is required for parsing and type-checking.  Moreover,<br/>the variables are specified as plain indexnames, not string encodings<br/>thereof.  INCOMPATIBILITY.<br/><br/>* Generic Toplevel.add_hook interface allows to analyze the result of<br/>transactions.  E.g. see src/Pure/ProofGeneral/proof_general_pgip.ML<br/>for theorem dependency output of transactions resulting in a new<br/>theory state.<br/><br/>* ML antiquotations: block-structured compilation context indicated by<br/>⦃ ... ⦄; additional antiquotation forms:<br/><br/>  @{binding name}                         - basic name binding<br/>  @{let ?pat = term}                      - term abbreviation (HO matching)<br/>  @{note name = fact}                     - fact abbreviation<br/>  @{thm fact}                             - singleton fact (with attributes)<br/>  @{thms fact}                            - general fact (with attributes)<br/>  @{lemma prop by method}                 - singleton goal<br/>  @{lemma prop by meth1 meth2}            - singleton goal<br/>  @{lemma prop1 ... propN by method}      - general goal<br/>  @{lemma prop1 ... propN by meth1 meth2} - general goal<br/>  @{lemma (open) ...}                     - open derivation<br/><br/><br/>*** System ***<br/><br/>* The Isabelle &quot;emacs&quot; tool provides a specific interface to invoke<br/>Proof General / Emacs, with more explicit failure if that is not<br/>installed (the old isabelle-interface script silently falls back on<br/>isabelle-process).  The PROOFGENERAL_HOME setting determines the<br/>installation location of the Proof General distribution.<br/><br/>* Isabelle/lib/classes/Pure.jar provides basic support to integrate<br/>the Isabelle process into a JVM/Scala application.  See<br/>Isabelle/lib/jedit/plugin for a minimal example.  (The obsolete Java<br/>process wrapper has been discontinued.)<br/><br/>* Added homegrown Isabelle font with unicode layout, see lib/fonts.<br/><br/>* Various status messages (with exact source position information) are<br/>emitted, if proper markup print mode is enabled.  This allows<br/>user-interface components to provide detailed feedback on internal<br/>prover operations.<br/><br/><br/><br/>New in Isabelle2008 (June 2008)<br/>-------------------------------<br/><br/>*** General ***<br/><br/>* The Isabelle/Isar Reference Manual (isar-ref) has been reorganized<br/>and updated, with formally checked references as hyperlinks.<br/><br/>* Theory loader: use_thy (and similar operations) no longer set the<br/>implicit ML context, which was occasionally hard to predict and in<br/>conflict with concurrency.  INCOMPATIBILITY, use ML within Isar which<br/>provides a proper context already.<br/><br/>* Theory loader: old-style ML proof scripts being *attached* to a thy<br/>file are no longer supported.  INCOMPATIBILITY, regular &#39;uses&#39; and<br/>&#39;use&#39; within a theory file will do the job.<br/><br/>* Name space merge now observes canonical order, i.e. the second space<br/>is inserted into the first one, while existing entries in the first<br/>space take precedence.  INCOMPATIBILITY in rare situations, may try to<br/>swap theory imports.<br/><br/>* Syntax: symbol χ is now considered a letter.  Potential<br/>INCOMPATIBILITY in identifier syntax etc.<br/><br/>* Outer syntax: string tokens no longer admit escaped white space,<br/>which was an accidental (undocumented) feature.  INCOMPATIBILITY, use<br/>white space without escapes.<br/><br/>* Outer syntax: string tokens may contain arbitrary character codes<br/>specified via 3 decimal digits (as in SML).  E.g. &quot;foo\095bar&quot; for<br/>&quot;foo_bar&quot;.<br/><br/><br/>*** Pure ***<br/><br/>* Context-dependent token translations.  Default setup reverts locally<br/>fixed variables, and adds hilite markup for undeclared frees.<br/><br/>* Unused theorems can be found using the new command &#39;unused_thms&#39;.<br/>There are three ways of invoking it:<br/><br/>(1) unused_thms<br/>     Only finds unused theorems in the current theory.<br/><br/>(2) unused_thms thy_1 ... thy_n -<br/>     Finds unused theorems in the current theory and all of its ancestors,<br/>     excluding the theories thy_1 ... thy_n and all of their ancestors.<br/><br/>(3) unused_thms thy_1 ... thy_n - thy&#39;_1 ... thy&#39;_m<br/>     Finds unused theorems in the theories thy&#39;_1 ... thy&#39;_m and all of<br/>     their ancestors, excluding the theories thy_1 ... thy_n and all of<br/>     their ancestors.<br/><br/>In order to increase the readability of the list produced by<br/>unused_thms, theorems that have been created by a particular instance<br/>of a theory command such as &#39;inductive&#39; or &#39;function&#39; are considered<br/>to belong to the same &quot;group&quot;, meaning that if at least one theorem in<br/>this group is used, the other theorems in the same group are no longer<br/>reported as unused.  Moreover, if all theorems in the group are<br/>unused, only one theorem in the group is displayed.<br/><br/>Note that proof objects have to be switched on in order for<br/>unused_thms to work properly (i.e. !proofs must be &gt;= 1, which is<br/>usually the case when using Proof General with the default settings).<br/><br/>* Authentic naming of facts disallows ad-hoc overwriting of previous<br/>theorems within the same name space.  INCOMPATIBILITY, need to remove<br/>duplicate fact bindings, or even accidental fact duplications.  Note<br/>that tools may maintain dynamically scoped facts systematically, using<br/>PureThy.add_thms_dynamic.<br/><br/>* Command &#39;hide&#39; now allows to hide from &quot;fact&quot; name space as well.<br/><br/>* Eliminated destructive theorem database, simpset, claset, and<br/>clasimpset.  Potential INCOMPATIBILITY, really need to observe linear<br/>update of theories within ML code.<br/><br/>* Eliminated theory ProtoPure and CPure, leaving just one Pure theory.<br/>INCOMPATIBILITY, object-logics depending on former Pure require<br/>additional setup PureThy.old_appl_syntax_setup; object-logics<br/>depending on former CPure need to refer to Pure.<br/><br/>* Commands &#39;use&#39; and &#39;ML&#39; are now purely functional, operating on<br/>theory/local_theory.  Removed former &#39;ML_setup&#39; (on theory), use &#39;ML&#39;<br/>instead.  Added &#39;ML_val&#39; as mere diagnostic replacement for &#39;ML&#39;.<br/>INCOMPATIBILITY.<br/><br/>* Command &#39;setup&#39;: discontinued implicit version with ML reference.<br/><br/>* Instantiation target allows for simultaneous specification of class<br/>instance operations together with an instantiation proof.<br/>Type-checking phase allows to refer to class operations uniformly.<br/>See src/HOL/Complex/Complex.thy for an Isar example and<br/>src/HOL/Library/Eval.thy for an ML example.<br/><br/>* Indexing of literal facts: be more serious about including only<br/>facts from the visible specification/proof context, but not the<br/>background context (locale etc.).  Affects `prop` notation and method<br/>&quot;fact&quot;.  INCOMPATIBILITY: need to name facts explicitly in rare<br/>situations.<br/><br/>* Method &quot;cases&quot;, &quot;induct&quot;, &quot;coinduct&quot;: removed obsolete/undocumented<br/>&quot;(open)&quot; option, which used to expose internal bound variables to the<br/>proof text.<br/><br/>* Isar statements: removed obsolete case &quot;rule_context&quot;.<br/>INCOMPATIBILITY, better use explicit fixes/assumes.<br/><br/>* Locale proofs: default proof step now includes &#39;unfold_locales&#39;;<br/>hence &#39;proof&#39; without argument may be used to unfold locale<br/>predicates.<br/><br/><br/>*** Document preparation ***<br/><br/>* Simplified pdfsetup.sty: color/hyperref is used unconditionally for<br/>both pdf and dvi (hyperlinks usually work in xdvi as well); removed<br/>obsolete thumbpdf setup (contemporary PDF viewers do this on the<br/>spot); renamed link color from &quot;darkblue&quot; to &quot;linkcolor&quot; (default<br/>value unchanged, can be redefined via \definecolor); no longer sets<br/>&quot;a4paper&quot; option (unnecessary or even intrusive).<br/><br/>* Antiquotation @{lemma A method} proves proposition A by the given<br/>method (either a method name or a method name plus (optional) method<br/>arguments in parentheses) and prints A just like @{prop A}.<br/><br/><br/>*** HOL ***<br/><br/>* New primrec package.  Specification syntax conforms in style to<br/>definition/function/....  No separate induction rule is provided.  The<br/>&quot;primrec&quot; command distinguishes old-style and new-style specifications<br/>by syntax.  The former primrec package is now named OldPrimrecPackage.<br/>When adjusting theories, beware: constants stemming from new-style<br/>primrec specifications have authentic syntax.<br/><br/>* Metis prover is now an order of magnitude faster, and also works<br/>with multithreading.<br/><br/>* Metis: the maximum number of clauses that can be produced from a<br/>theorem is now given by the attribute max_clauses.  Theorems that<br/>exceed this number are ignored, with a warning printed.<br/><br/>* Sledgehammer no longer produces structured proofs by default. To<br/>enable, declare [[sledgehammer_full = true]].  Attributes<br/>reconstruction_modulus, reconstruction_sorts renamed<br/>sledgehammer_modulus, sledgehammer_sorts.  INCOMPATIBILITY.<br/><br/>* Method &quot;induct_scheme&quot; derives user-specified induction rules<br/>from well-founded induction and completeness of patterns. This factors<br/>out some operations that are done internally by the function package<br/>and makes them available separately.  See<br/>src/HOL/ex/Induction_Scheme.thy for examples.<br/><br/>* More flexible generation of measure functions for termination<br/>proofs: Measure functions can be declared by proving a rule of the<br/>form &quot;is_measure f&quot; and giving it the [measure_function] attribute.<br/>The &quot;is_measure&quot; predicate is logically meaningless (always true), and<br/>just guides the heuristic.  To find suitable measure functions, the<br/>termination prover sets up the goal &quot;is_measure ?f&quot; of the appropriate<br/>type and generates all solutions by Prolog-style backward proof using<br/>the declared rules.<br/><br/>This setup also deals with rules like<br/><br/>  &quot;is_measure f ==&gt; is_measure (list_size f)&quot;<br/><br/>which accommodates nested datatypes that recurse through lists.<br/>Similar rules are predeclared for products and option types.<br/><br/>* Turned the type of sets &quot;&#39;a set&quot; into an abbreviation for &quot;&#39;a =&gt; bool&quot;<br/><br/>  INCOMPATIBILITIES:<br/><br/>  - Definitions of overloaded constants on sets have to be replaced by<br/>    definitions on =&gt; and bool.<br/><br/>  - Some definitions of overloaded operators on sets can now be proved<br/>    using the definitions of the operators on =&gt; and bool.  Therefore,<br/>    the following theorems have been renamed:<br/><br/>      subset_def   -&gt; subset_eq<br/>      psubset_def  -&gt; psubset_eq<br/>      set_diff_def -&gt; set_diff_eq<br/>      Compl_def    -&gt; Compl_eq<br/>      Sup_set_def  -&gt; Sup_set_eq<br/>      Inf_set_def  -&gt; Inf_set_eq<br/>      sup_set_def  -&gt; sup_set_eq<br/>      inf_set_def  -&gt; inf_set_eq<br/><br/>  - Due to the incompleteness of the HO unification algorithm, some<br/>    rules such as subst may require manual instantiation, if some of<br/>    the unknowns in the rule is a set.<br/><br/>  - Higher order unification and forward proofs:<br/>    The proof pattern<br/><br/>      have &quot;P (S::&#39;a set)&quot; &lt;...&gt;<br/>      then have &quot;EX S. P S&quot; ..<br/><br/>    no longer works (due to the incompleteness of the HO unification<br/>    algorithm) and must be replaced by the pattern<br/><br/>      have &quot;EX S. P S&quot;<br/>      proof<br/>        show &quot;P S&quot; &lt;...&gt;<br/>      qed<br/><br/>  - Calculational reasoning with subst (or similar rules):<br/>    The proof pattern<br/><br/>      have &quot;P (S::&#39;a set)&quot; &lt;...&gt;<br/>      also have &quot;S = T&quot; &lt;...&gt;<br/>      finally have &quot;P T&quot; .<br/><br/>    no longer works (for similar reasons as the previous example) and<br/>    must be replaced by something like<br/><br/>      have &quot;P (S::&#39;a set)&quot; &lt;...&gt;<br/>      moreover have &quot;S = T&quot; &lt;...&gt;<br/>      ultimately have &quot;P T&quot; by simp<br/><br/>  - Tactics or packages written in ML code:<br/>    Code performing pattern matching on types via<br/><br/>      Type (&quot;set&quot;, [T]) =&gt; ...<br/><br/>    must be rewritten. Moreover, functions like strip_type or<br/>    binder_types no longer return the right value when applied to a<br/>    type of the form<br/><br/>      T1 =&gt; ... =&gt; Tn =&gt; U =&gt; bool<br/><br/>    rather than<br/><br/>      T1 =&gt; ... =&gt; Tn =&gt; U set<br/><br/>* Merged theories Wellfounded_Recursion, Accessible_Part and<br/>Wellfounded_Relations to theory Wellfounded.<br/><br/>* Explicit class &quot;eq&quot; for executable equality.  INCOMPATIBILITY.<br/><br/>* Class finite no longer treats UNIV as class parameter.  Use class<br/>enum from theory Library/Enum instead to achieve a similar effect.<br/>INCOMPATIBILITY.<br/><br/>* Theory List: rule list_induct2 now has explicitly named cases &quot;Nil&quot;<br/>and &quot;Cons&quot;.  INCOMPATIBILITY.<br/><br/>* HOL (and FOL): renamed variables in rules imp_elim and swap.<br/>Potential INCOMPATIBILITY.<br/><br/>* Theory Product_Type: duplicated lemmas split_Pair_apply and<br/>injective_fst_snd removed, use split_eta and prod_eqI instead.<br/>Renamed upd_fst to apfst and upd_snd to apsnd.  INCOMPATIBILITY.<br/><br/>* Theory Nat: removed redundant lemmas that merely duplicate lemmas of<br/>the same name in theory Orderings:<br/><br/>  less_trans<br/>  less_linear<br/>  le_imp_less_or_eq<br/>  le_less_trans<br/>  less_le_trans<br/>  less_not_sym<br/>  less_asym<br/><br/>Renamed less_imp_le to less_imp_le_nat, and less_irrefl to<br/>less_irrefl_nat.  Potential INCOMPATIBILITY due to more general types<br/>and different variable names.<br/><br/>* Library/Option_ord.thy: Canonical order on option type.<br/><br/>* Library/RBT.thy: Red-black trees, an efficient implementation of<br/>finite maps.<br/><br/>* Library/Countable.thy: Type class for countable types.<br/><br/>* Theory Int: The representation of numerals has changed.  The infix<br/>operator BIT and the bit datatype with constructors B0 and B1 have<br/>disappeared.  INCOMPATIBILITY, use &quot;Int.Bit0 x&quot; and &quot;Int.Bit1 y&quot; in<br/>place of &quot;x BIT bit.B0&quot; and &quot;y BIT bit.B1&quot;, respectively.  Theorems<br/>involving BIT, B0, or B1 have been renamed with &quot;Bit0&quot; or &quot;Bit1&quot;<br/>accordingly.<br/><br/>* Theory Nat: definition of &lt;= and &lt; on natural numbers no longer<br/>depend on well-founded relations.  INCOMPATIBILITY.  Definitions<br/>le_def and less_def have disappeared.  Consider lemmas not_less<br/>[symmetric, where ?&#39;a = nat] and less_eq [symmetric] instead.<br/><br/>* Theory Finite_Set: locales ACf, ACe, ACIf, ACIfSL and ACIfSLlin<br/>(whose purpose mainly is for various fold_set functionals) have been<br/>abandoned in favor of the existing algebraic classes<br/>ab_semigroup_mult, comm_monoid_mult, ab_semigroup_idem_mult,<br/>lower_semilattice (resp. upper_semilattice) and linorder.<br/>INCOMPATIBILITY.<br/><br/>* Theory Transitive_Closure: induct and cases rules now declare proper<br/>case_names (&quot;base&quot; and &quot;step&quot;).  INCOMPATIBILITY.<br/><br/>* Theorem Inductive.lfp_ordinal_induct generalized to complete<br/>lattices.  The form set-specific version is available as<br/>Inductive.lfp_ordinal_induct_set.<br/><br/>* Renamed theorems &quot;power.simps&quot; to &quot;power_int.simps&quot;.<br/>INCOMPATIBILITY.<br/><br/>* Class semiring_div provides basic abstract properties of semirings<br/>with division and modulo operations.  Subsumes former class dvd_mod.<br/><br/>* Merged theories IntDef, Numeral and IntArith into unified theory<br/>Int.  INCOMPATIBILITY.<br/><br/>* Theory Library/Code_Index: type &quot;index&quot; now represents natural<br/>numbers rather than integers.  INCOMPATIBILITY.<br/><br/>* New class &quot;uminus&quot; with operation &quot;uminus&quot; (split of from class<br/>&quot;minus&quot; which now only has operation &quot;minus&quot;, binary).<br/>INCOMPATIBILITY.<br/><br/>* Constants &quot;card&quot;, &quot;internal_split&quot;, &quot;option_map&quot; now with authentic<br/>syntax.  INCOMPATIBILITY.<br/><br/>* Definitions subset_def, psubset_def, set_diff_def, Compl_def,<br/>le_bool_def, less_bool_def, le_fun_def, less_fun_def, inf_bool_def,<br/>sup_bool_def, Inf_bool_def, Sup_bool_def, inf_fun_def, sup_fun_def,<br/>Inf_fun_def, Sup_fun_def, inf_set_def, sup_set_def, Inf_set_def,<br/>Sup_set_def, le_def, less_def, option_map_def now with object<br/>equality.  INCOMPATIBILITY.<br/><br/>* Records. Removed K_record, and replaced it by pure lambda term<br/>%x. c. The simplifier setup is now more robust against eta expansion.<br/>INCOMPATIBILITY: in cases explicitly referring to K_record.<br/><br/>* Library/Multiset: {#a, b, c#} abbreviates {#a#} + {#b#} + {#c#}.<br/><br/>* Library/ListVector: new theory of arithmetic vector operations.<br/><br/>* Library/Order_Relation: new theory of various orderings as sets of<br/>pairs.  Defines preorders, partial orders, linear orders and<br/>well-orders on sets and on types.<br/><br/><br/>*** ZF ***<br/><br/>* Renamed some theories to allow to loading both ZF and HOL in the<br/>same session:<br/><br/>  Datatype  -&gt; Datatype_ZF<br/>  Inductive -&gt; Inductive_ZF<br/>  Int       -&gt; Int_ZF<br/>  IntDiv    -&gt; IntDiv_ZF<br/>  Nat       -&gt; Nat_ZF<br/>  List      -&gt; List_ZF<br/>  Main      -&gt; Main_ZF<br/><br/>INCOMPATIBILITY: ZF theories that import individual theories below<br/>Main might need to be adapted.  Regular theory Main is still<br/>available, as trivial extension of Main_ZF.<br/><br/><br/>*** ML ***<br/><br/>* ML within Isar: antiquotation @{const name} or @{const<br/>name(typargs)} produces statically-checked Const term.<br/><br/>* Functor NamedThmsFun: data is available to the user as dynamic fact<br/>(of the same name).  Removed obsolete print command.<br/><br/>* Removed obsolete &quot;use_legacy_bindings&quot; function.<br/><br/>* The ``print mode&#39;&#39; is now a thread-local value derived from a global<br/>template (the former print_mode reference), thus access becomes<br/>non-critical.  The global print_mode reference is for session<br/>management only; user-code should use print_mode_value,<br/>print_mode_active, PrintMode.setmp etc.  INCOMPATIBILITY.<br/><br/>* Functions system/system_out provide a robust way to invoke external<br/>shell commands, with propagation of interrupts (requires Poly/ML<br/>5.2.1).  Do not use OS.Process.system etc. from the basis library!<br/><br/><br/>*** System ***<br/><br/>* Default settings: PROOFGENERAL_OPTIONS no longer impose xemacs ---<br/>in accordance with Proof General 3.7, which prefers GNU emacs.<br/><br/>* isatool tty runs Isabelle process with plain tty interaction;<br/>optional line editor may be specified via ISABELLE_LINE_EDITOR<br/>setting, the default settings attempt to locate &quot;ledit&quot; and &quot;rlwrap&quot;.<br/><br/>* isatool browser now works with Cygwin as well, using general<br/>&quot;javapath&quot; function defined in Isabelle process environment.<br/><br/>* YXML notation provides a simple and efficient alternative to<br/>standard XML transfer syntax.  See src/Pure/General/yxml.ML and<br/>isatool yxml as described in the Isabelle system manual.<br/><br/>* JVM class isabelle.IsabelleProcess (located in Isabelle/lib/classes)<br/>provides general wrapper for managing an Isabelle process in a robust<br/>fashion, with ``cooked&#39;&#39; output from stdin/stderr.<br/><br/>* Rudimentary Isabelle plugin for jEdit (see Isabelle/lib/jedit),<br/>based on Isabelle/JVM process wrapper (see Isabelle/lib/classes).<br/><br/>* Removed obsolete THIS_IS_ISABELLE_BUILD feature.  NB: the documented<br/>way of changing the user&#39;s settings is via<br/>ISABELLE_HOME_USER/etc/settings, which is a fully featured bash<br/>script.<br/><br/>* Multithreading.max_threads := 0 refers to the number of actual CPU<br/>cores of the underlying machine, which is a good starting point for<br/>optimal performance tuning.  The corresponding usedir option -M allows<br/>&quot;max&quot; as an alias for &quot;0&quot;.  WARNING: does not work on certain versions<br/>of Mac OS (with Poly/ML 5.1).<br/><br/>* isabelle-process: non-ML sessions are run with &quot;nice&quot;, to reduce the<br/>adverse effect of Isabelle flooding interactive front-ends (notably<br/>ProofGeneral / XEmacs).<br/><br/><br/><br/>New in Isabelle2007 (November 2007)<br/>-----------------------------------<br/><br/>*** General ***<br/><br/>* More uniform information about legacy features, notably a<br/>warning/error of &quot;Legacy feature: ...&quot;, depending on the state of the<br/>tolerate_legacy_features flag (default true). FUTURE INCOMPATIBILITY:<br/>legacy features will disappear eventually.<br/><br/>* Theory syntax: the header format ``theory A = B + C:&#39;&#39; has been<br/>discontinued in favour of ``theory A imports B C begin&#39;&#39;.  Use isatool<br/>fixheaders to convert existing theory files.  INCOMPATIBILITY.<br/><br/>* Theory syntax: the old non-Isar theory file format has been<br/>discontinued altogether.  Note that ML proof scripts may still be used<br/>with Isar theories; migration is usually quite simple with the ML<br/>function use_legacy_bindings.  INCOMPATIBILITY.<br/><br/>* Theory syntax: some popular names (e.g. &#39;class&#39;, &#39;declaration&#39;,<br/>&#39;fun&#39;, &#39;help&#39;, &#39;if&#39;) are now keywords.  INCOMPATIBILITY, use double<br/>quotes.<br/><br/>* Theory loader: be more serious about observing the static theory<br/>header specifications (including optional directories), but not the<br/>accidental file locations of previously successful loads.  The strict<br/>update policy of former update_thy is now already performed by<br/>use_thy, so the former has been removed; use_thys updates several<br/>theories simultaneously, just as &#39;imports&#39; within a theory header<br/>specification, but without merging the results.  Potential<br/>INCOMPATIBILITY: may need to refine theory headers and commands<br/>ROOT.ML which depend on load order.<br/><br/>* Theory loader: optional support for content-based file<br/>identification, instead of the traditional scheme of full physical<br/>path plus date stamp; configured by the ISABELLE_FILE_IDENT setting<br/>(cf. the system manual).  The new scheme allows to work with<br/>non-finished theories in persistent session images, such that source<br/>files may be moved later on without requiring reloads.<br/><br/>* Theory loader: old-style ML proof scripts being *attached* to a thy<br/>file (with the same base name as the theory) are considered a legacy<br/>feature, which will disappear eventually. Even now, the theory loader<br/>no longer maintains dependencies on such files.<br/><br/>* Syntax: the scope for resolving ambiguities via type-inference is<br/>now limited to individual terms, instead of whole simultaneous<br/>specifications as before. This greatly reduces the complexity of the<br/>syntax module and improves flexibility by separating parsing and<br/>type-checking. INCOMPATIBILITY: additional type-constraints (explicit<br/>&#39;fixes&#39; etc.) are required in rare situations.<br/><br/>* Syntax: constants introduced by new-style packages (&#39;definition&#39;,<br/>&#39;abbreviation&#39; etc.) are passed through the syntax module in<br/>``authentic mode&#39;&#39;. This means that associated mixfix annotations<br/>really stick to such constants, independently of potential name space<br/>ambiguities introduced later on. INCOMPATIBILITY: constants in parse<br/>trees are represented slightly differently, may need to adapt syntax<br/>translations accordingly. Use CONST marker in &#39;translations&#39; and<br/>@{const_syntax} antiquotation in &#39;parse_translation&#39; etc.<br/><br/>* Legacy goal package: reduced interface to the bare minimum required<br/>to keep existing proof scripts running.  Most other user-level<br/>functions are now part of the OldGoals structure, which is *not* open<br/>by default (consider isatool expandshort before open OldGoals).<br/>Removed top_sg, prin, printyp, pprint_term/typ altogether, because<br/>these tend to cause confusion about the actual goal (!) context being<br/>used here, which is not necessarily the same as the_context().<br/><br/>* Command &#39;find_theorems&#39;: supports &quot;*&quot; wild-card in &quot;name:&quot;<br/>criterion; &quot;with_dups&quot; option.  Certain ProofGeneral versions might<br/>support a specific search form (see ProofGeneral/CHANGES).<br/><br/>* The ``prems limit&#39;&#39; option (cf. ProofContext.prems_limit) is now -1<br/>by default, which means that &quot;prems&quot; (and also &quot;fixed variables&quot;) are<br/>suppressed from proof state output.  Note that the ProofGeneral<br/>settings mechanism allows to change and save options persistently, but<br/>older versions of Isabelle will fail to start up if a negative prems<br/>limit is imposed.<br/><br/>* Local theory targets may be specified by non-nested blocks of<br/>``context/locale/class ... begin&#39;&#39; followed by ``end&#39;&#39;.  The body may<br/>contain definitions, theorems etc., including any derived mechanism<br/>that has been implemented on top of these primitives.  This concept<br/>generalizes the existing ``theorem (in ...)&#39;&#39; towards more versatility<br/>and scalability.<br/><br/>* Proof General interface: proper undo of final &#39;end&#39; command;<br/>discontinued Isabelle/classic mode (ML proof scripts).<br/><br/><br/>*** Document preparation ***<br/><br/>* Added antiquotation @{theory name} which prints the given name,<br/>after checking that it refers to a valid ancestor theory in the<br/>current context.<br/><br/>* Added antiquotations @{ML_type text} and @{ML_struct text} which<br/>check the given source text as ML type/structure, printing verbatim.<br/><br/>* Added antiquotation @{abbrev &quot;c args&quot;} which prints the abbreviation<br/>&quot;c args == rhs&quot; given in the current context.  (Any number of<br/>arguments may be given on the LHS.)<br/><br/><br/>*** Pure ***<br/><br/>* The &#39;class&#39; package offers a combination of axclass and locale to<br/>achieve Haskell-like type classes in Isabelle.  Definitions and<br/>theorems within a class context produce both relative results (with<br/>implicit parameters according to the locale context), and polymorphic<br/>constants with qualified polymorphism (according to the class<br/>context).  Within the body context of a &#39;class&#39; target, a separate<br/>syntax layer (&quot;user space type system&quot;) takes care of converting<br/>between global polymorphic consts and internal locale representation.<br/>See src/HOL/ex/Classpackage.thy for examples (as well as main HOL).<br/>&quot;isatool doc classes&quot; provides a tutorial.<br/><br/>* Generic code generator framework allows to generate executable<br/>code for ML and Haskell (including Isabelle classes).  A short usage<br/>sketch:<br/><br/>    internal compilation:<br/>        export_code &lt;list of constants (term syntax)&gt; in SML<br/>    writing SML code to a file:<br/>        export_code &lt;list of constants (term syntax)&gt; in SML &lt;filename&gt;<br/>    writing OCaml code to a file:<br/>        export_code &lt;list of constants (term syntax)&gt; in OCaml &lt;filename&gt;<br/>    writing Haskell code to a bunch of files:<br/>        export_code &lt;list of constants (term syntax)&gt; in Haskell &lt;filename&gt;<br/><br/>    evaluating closed propositions to True/False using code generation:<br/>        method ``eval&#39;&#39;<br/><br/>Reasonable default setup of framework in HOL.<br/><br/>Theorem attributs for selecting and transforming function equations theorems:<br/><br/>    [code fun]:        select a theorem as function equation for a specific constant<br/>    [code fun del]:    deselect a theorem as function equation for a specific constant<br/>    [code inline]:     select an equation theorem for unfolding (inlining) in place<br/>    [code inline del]: deselect an equation theorem for unfolding (inlining) in place<br/><br/>User-defined serializations (target in {SML, OCaml, Haskell}):<br/><br/>    code_const &lt;and-list of constants (term syntax)&gt;<br/>      {(target) &lt;and-list of const target syntax&gt;}+<br/><br/>    code_type &lt;and-list of type constructors&gt;<br/>      {(target) &lt;and-list of type target syntax&gt;}+<br/><br/>    code_instance &lt;and-list of instances&gt;<br/>      {(target)}+<br/>        where instance ::= &lt;type constructor&gt; :: &lt;class&gt;<br/><br/>    code_class &lt;and_list of classes&gt;<br/>      {(target) &lt;and-list of class target syntax&gt;}+<br/>        where class target syntax ::= &lt;class name&gt; {where {&lt;classop&gt; == &lt;target syntax&gt;}+}?<br/><br/>code_instance and code_class only are effective to target Haskell.<br/><br/>For example usage see src/HOL/ex/Codegenerator.thy and<br/>src/HOL/ex/Codegenerator_Pretty.thy.  A separate tutorial on code<br/>generation from Isabelle/HOL theories is available via &quot;isatool doc<br/>codegen&quot;.<br/><br/>* Code generator: consts in &#39;consts_code&#39; Isar commands are now<br/>referred to by usual term syntax (including optional type<br/>annotations).<br/><br/>* Command &#39;no_translations&#39; removes translation rules from theory<br/>syntax.<br/><br/>* Overloaded definitions are now actually checked for acyclic<br/>dependencies.  The overloading scheme is slightly more general than<br/>that of Haskell98, although Isabelle does not demand an exact<br/>correspondence to type class and instance declarations.<br/>INCOMPATIBILITY, use ``defs (unchecked overloaded)&#39;&#39; to admit more<br/>exotic versions of overloading -- at the discretion of the user!<br/><br/>Polymorphic constants are represented via type arguments, i.e. the<br/>instantiation that matches an instance against the most general<br/>declaration given in the signature.  For example, with the declaration<br/>c :: &#39;a =&gt; &#39;a =&gt; &#39;a, an instance c :: nat =&gt; nat =&gt; nat is represented<br/>as c(nat).  Overloading is essentially simultaneous structural<br/>recursion over such type arguments.  Incomplete specification patterns<br/>impose global constraints on all occurrences, e.g. c(&#39;a * &#39;a) on the<br/>LHS means that more general c(&#39;a * &#39;b) will be disallowed on any RHS.<br/>Command &#39;print_theory&#39; outputs the normalized system of recursive<br/>equations, see section &quot;definitions&quot;.<br/><br/>* Configuration options are maintained within the theory or proof<br/>context (with name and type bool/int/string), providing a very simple<br/>interface to a poor-man&#39;s version of general context data.  Tools may<br/>declare options in ML (e.g. using Attrib.config_int) and then refer to<br/>these values using Config.get etc.  Users may change options via an<br/>associated attribute of the same name.  This form of context<br/>declaration works particularly well with commands &#39;declare&#39; or<br/>&#39;using&#39;, for example ``declare [[foo = 42]]&#39;&#39;.  Thus it has become<br/>very easy to avoid global references, which would not observe Isar<br/>toplevel undo/redo and fail to work with multithreading.<br/><br/>Various global ML references of Pure and HOL have been turned into<br/>configuration options:<br/><br/>  Unify.search_bound		unify_search_bound<br/>  Unify.trace_bound		unify_trace_bound<br/>  Unify.trace_simp		unify_trace_simp<br/>  Unify.trace_types		unify_trace_types<br/>  Simplifier.simp_depth_limit	simp_depth_limit<br/>  Blast.depth_limit		blast_depth_limit<br/>  DatatypeProp.dtK		datatype_distinctness_limit<br/>  fast_arith_neq_limit  	fast_arith_neq_limit<br/>  fast_arith_split_limit	fast_arith_split_limit<br/><br/>* Named collections of theorems may be easily installed as context<br/>data using the functor NamedThmsFun (see also<br/>src/Pure/Tools/named_thms.ML).  The user may add or delete facts via<br/>attributes; there is also a toplevel print command.  This facility is<br/>just a common case of general context data, which is the preferred way<br/>for anything more complex than just a list of facts in canonical<br/>order.<br/><br/>* Isar: command &#39;declaration&#39; augments a local theory by generic<br/>declaration functions written in ML.  This enables arbitrary content<br/>being added to the context, depending on a morphism that tells the<br/>difference of the original declaration context wrt. the application<br/>context encountered later on.<br/><br/>* Isar: proper interfaces for simplification procedures.  Command<br/>&#39;simproc_setup&#39; declares named simprocs (with match patterns, and body<br/>text in ML).  Attribute &quot;simproc&quot; adds/deletes simprocs in the current<br/>context.  ML antiquotation @{simproc name} retrieves named simprocs.<br/><br/>* Isar: an extra pair of brackets around attribute declarations<br/>abbreviates a theorem reference involving an internal dummy fact,<br/>which will be ignored later --- only the effect of the attribute on<br/>the background context will persist.  This form of in-place<br/>declarations is particularly useful with commands like &#39;declare&#39; and<br/>&#39;using&#39;, for example ``have A using [[simproc a]] by simp&#39;&#39;.<br/><br/>* Isar: method &quot;assumption&quot; (and implicit closing of subproofs) now<br/>takes simple non-atomic goal assumptions into account: after applying<br/>an assumption as a rule the resulting subgoals are solved by atomic<br/>assumption steps.  This is particularly useful to finish &#39;obtain&#39;<br/>goals, such as &quot;!!x. (!!x. P x ==&gt; thesis) ==&gt; P x ==&gt; thesis&quot;,<br/>without referring to the original premise &quot;!!x. P x ==&gt; thesis&quot; in the<br/>Isar proof context.  POTENTIAL INCOMPATIBILITY: method &quot;assumption&quot; is<br/>more permissive.<br/><br/>* Isar: implicit use of prems from the Isar proof context is<br/>considered a legacy feature.  Common applications like ``have A .&#39;&#39;<br/>may be replaced by ``have A by fact&#39;&#39; or ``note `A`&#39;&#39;.  In general,<br/>referencing facts explicitly here improves readability and<br/>maintainability of proof texts.<br/><br/>* Isar: improper proof element &#39;guess&#39; is like &#39;obtain&#39;, but derives<br/>the obtained context from the course of reasoning!  For example:<br/><br/>  assume &quot;EX x y. A x &amp; B y&quot;   -- &quot;any previous fact&quot;<br/>  then guess x and y by clarify<br/><br/>This technique is potentially adventurous, depending on the facts and<br/>proof tools being involved here.<br/><br/>* Isar: known facts from the proof context may be specified as literal<br/>propositions, using ASCII back-quote syntax.  This works wherever<br/>named facts used to be allowed so far, in proof commands, proof<br/>methods, attributes etc.  Literal facts are retrieved from the context<br/>according to unification of type and term parameters.  For example,<br/>provided that &quot;A&quot; and &quot;A ==&gt; B&quot; and &quot;!!x. P x ==&gt; Q x&quot; are known<br/>theorems in the current context, then these are valid literal facts:<br/>`A` and `A ==&gt; B` and `!!x. P x ==&gt; Q x&quot; as well as `P a ==&gt; Q a` etc.<br/><br/>There is also a proof method &quot;fact&quot; which does the same composition<br/>for explicit goal states, e.g. the following proof texts coincide with<br/>certain special cases of literal facts:<br/><br/>  have &quot;A&quot; by fact                 ==  note `A`<br/>  have &quot;A ==&gt; B&quot; by fact           ==  note `A ==&gt; B`<br/>  have &quot;!!x. P x ==&gt; Q x&quot; by fact  ==  note `!!x. P x ==&gt; Q x`<br/>  have &quot;P a ==&gt; Q a&quot; by fact       ==  note `P a ==&gt; Q a`<br/><br/>* Isar: &quot;:&quot; (colon) is no longer a symbolic identifier character in<br/>outer syntax.  Thus symbolic identifiers may be used without<br/>additional white space in declarations like this: ``assume *: A&#39;&#39;.<br/><br/>* Isar: &#39;print_facts&#39; prints all local facts of the current context,<br/>both named and unnamed ones.<br/><br/>* Isar: &#39;def&#39; now admits simultaneous definitions, e.g.:<br/><br/>  def x == &quot;t&quot; and y == &quot;u&quot;<br/><br/>* Isar: added command &#39;unfolding&#39;, which is structurally similar to<br/>&#39;using&#39;, but affects both the goal state and facts by unfolding given<br/>rewrite rules.  Thus many occurrences of the &#39;unfold&#39; method or<br/>&#39;unfolded&#39; attribute may be replaced by first-class proof text.<br/><br/>* Isar: methods &#39;unfold&#39; / &#39;fold&#39;, attributes &#39;unfolded&#39; / &#39;folded&#39;,<br/>and command &#39;unfolding&#39; now all support object-level equalities<br/>(potentially conditional).  The underlying notion of rewrite rule is<br/>analogous to the &#39;rule_format&#39; attribute, but *not* that of the<br/>Simplifier (which is usually more generous).<br/><br/>* Isar: the new attribute [rotated n] (default n = 1) rotates the<br/>premises of a theorem by n. Useful in conjunction with drule.<br/><br/>* Isar: the goal restriction operator [N] (default N = 1) evaluates a<br/>method expression within a sandbox consisting of the first N<br/>sub-goals, which need to exist.  For example, ``simp_all [3]&#39;&#39;<br/>simplifies the first three sub-goals, while (rule foo, simp_all)[]<br/>simplifies all new goals that emerge from applying rule foo to the<br/>originally first one.<br/><br/>* Isar: schematic goals are no longer restricted to higher-order<br/>patterns; e.g. ``lemma &quot;?P(?x)&quot; by (rule TrueI)&#39;&#39; now works as<br/>expected.<br/><br/>* Isar: the conclusion of a long theorem statement is now either<br/>&#39;shows&#39; (a simultaneous conjunction, as before), or &#39;obtains&#39;<br/>(essentially a disjunction of cases with local parameters and<br/>assumptions).  The latter allows to express general elimination rules<br/>adequately; in this notation common elimination rules look like this:<br/><br/>  lemma exE:    -- &quot;EX x. P x ==&gt; (!!x. P x ==&gt; thesis) ==&gt; thesis&quot;<br/>    assumes &quot;EX x. P x&quot;<br/>    obtains x where &quot;P x&quot;<br/><br/>  lemma conjE:  -- &quot;A &amp; B ==&gt; (A ==&gt; B ==&gt; thesis) ==&gt; thesis&quot;<br/>    assumes &quot;A &amp; B&quot;<br/>    obtains A and B<br/><br/>  lemma disjE:  -- &quot;A | B ==&gt; (A ==&gt; thesis) ==&gt; (B ==&gt; thesis) ==&gt; thesis&quot;<br/>    assumes &quot;A | B&quot;<br/>    obtains<br/>      A<br/>    | B<br/><br/>The subsequent classical rules even refer to the formal &quot;thesis&quot;<br/>explicitly:<br/><br/>  lemma classical:     -- &quot;(~ thesis ==&gt; thesis) ==&gt; thesis&quot;<br/>    obtains &quot;~ thesis&quot;<br/><br/>  lemma Peirce&#39;s_Law:  -- &quot;((thesis ==&gt; something) ==&gt; thesis) ==&gt; thesis&quot;<br/>    obtains &quot;thesis ==&gt; something&quot;<br/><br/>The actual proof of an &#39;obtains&#39; statement is analogous to that of the<br/>Isar proof element &#39;obtain&#39;, only that there may be several cases.<br/>Optional case names may be specified in parentheses; these will be<br/>available both in the present proof and as annotations in the<br/>resulting rule, for later use with the &#39;cases&#39; method (cf. attribute<br/>case_names).<br/><br/>* Isar: the assumptions of a long theorem statement are available as<br/>&quot;assms&quot; fact in the proof context.  This is more appropriate than the<br/>(historical) &quot;prems&quot;, which refers to all assumptions of the current<br/>context, including those from the target locale, proof body etc.<br/><br/>* Isar: &#39;print_statement&#39; prints theorems from the current theory or<br/>proof context in long statement form, according to the syntax of a<br/>top-level lemma.<br/><br/>* Isar: &#39;obtain&#39; takes an optional case name for the local context<br/>introduction rule (default &quot;that&quot;).<br/><br/>* Isar: removed obsolete &#39;concl is&#39; patterns.  INCOMPATIBILITY, use<br/>explicit (is &quot;_ ==&gt; ?foo&quot;) in the rare cases where this still happens<br/>to occur.<br/><br/>* Pure: syntax &quot;CONST name&quot; produces a fully internalized constant<br/>according to the current context.  This is particularly useful for<br/>syntax translations that should refer to internal constant<br/>representations independently of name spaces.<br/><br/>* Pure: syntax constant for foo (binder &quot;FOO &quot;) is called &quot;foo_binder&quot;<br/>instead of &quot;FOO &quot;. This allows multiple binder declarations to coexist<br/>in the same context.  INCOMPATIBILITY.<br/><br/>* Isar/locales: &#39;notation&#39; provides a robust interface to the &#39;syntax&#39;<br/>primitive that also works in a locale context (both for constants and<br/>fixed variables). Type declaration and internal syntactic representation<br/>of given constants retrieved from the context. Likewise, the<br/>&#39;no_notation&#39; command allows to remove given syntax annotations from the<br/>current context.<br/><br/>* Isar/locales: new derived specification elements &#39;axiomatization&#39;,<br/>&#39;definition&#39;, &#39;abbreviation&#39;, which support type-inference, admit<br/>object-level specifications (equality, equivalence).  See also the<br/>isar-ref manual.  Examples:<br/><br/>  axiomatization<br/>    eq  (infix &quot;===&quot; 50) where<br/>    eq_refl: &quot;x === x&quot; and eq_subst: &quot;x === y ==&gt; P x ==&gt; P y&quot;<br/><br/>  definition &quot;f x y = x + y + 1&quot;<br/>  definition g where &quot;g x = f x x&quot;<br/><br/>  abbreviation<br/>    neq  (infix &quot;=!=&quot; 50) where<br/>    &quot;x =!= y == ~ (x === y)&quot;<br/><br/>These specifications may be also used in a locale context.  Then the<br/>constants being introduced depend on certain fixed parameters, and the<br/>constant name is qualified by the locale base name.  An internal<br/>abbreviation takes care for convenient input and output, making the<br/>parameters implicit and using the original short name.  See also<br/>src/HOL/ex/Abstract_NAT.thy for an example of deriving polymorphic<br/>entities from a monomorphic theory.<br/><br/>Presently, abbreviations are only available &#39;in&#39; a target locale, but<br/>not inherited by general import expressions.  Also note that<br/>&#39;abbreviation&#39; may be used as a type-safe replacement for &#39;syntax&#39; +<br/>&#39;translations&#39; in common applications.  The &quot;no_abbrevs&quot; print mode<br/>prevents folding of abbreviations in term output.<br/><br/>Concrete syntax is attached to specified constants in internal form,<br/>independently of name spaces.  The parse tree representation is<br/>slightly different -- use &#39;notation&#39; instead of raw &#39;syntax&#39;, and<br/>&#39;translations&#39; with explicit &quot;CONST&quot; markup to accommodate this.<br/><br/>* Pure/Isar: unified syntax for new-style specification mechanisms<br/>(e.g.  &#39;definition&#39;, &#39;abbreviation&#39;, or &#39;inductive&#39; in HOL) admits<br/>full type inference and dummy patterns (&quot;_&quot;).  For example:<br/><br/>  definition &quot;K x _ = x&quot;<br/><br/>  inductive conj for A B<br/>  where &quot;A ==&gt; B ==&gt; conj A B&quot;<br/><br/>* Pure: command &#39;print_abbrevs&#39; prints all constant abbreviations of<br/>the current context.  Print mode &quot;no_abbrevs&quot; prevents inversion of<br/>abbreviations on output.<br/><br/>* Isar/locales: improved parameter handling: use of locales &quot;var&quot; and<br/>&quot;struct&quot; no longer necessary; - parameter renamings are no longer<br/>required to be injective.  For example, this allows to define<br/>endomorphisms as locale endom = homom mult mult h.<br/><br/>* Isar/locales: changed the way locales with predicates are defined.<br/>Instead of accumulating the specification, the imported expression is<br/>now an interpretation.  INCOMPATIBILITY: different normal form of<br/>locale expressions.  In particular, in interpretations of locales with<br/>predicates, goals repesenting already interpreted fragments are not<br/>removed automatically.  Use methods `intro_locales&#39; and<br/>`unfold_locales&#39;; see below.<br/><br/>* Isar/locales: new methods `intro_locales&#39; and `unfold_locales&#39;<br/>provide backward reasoning on locales predicates.  The methods are<br/>aware of interpretations and discharge corresponding goals.<br/>`intro_locales&#39; is less aggressive then `unfold_locales&#39; and does not<br/>unfold predicates to assumptions.<br/><br/>* Isar/locales: the order in which locale fragments are accumulated<br/>has changed.  This enables to override declarations from fragments due<br/>to interpretations -- for example, unwanted simp rules.<br/><br/>* Isar/locales: interpretation in theories and proof contexts has been<br/>extended.  One may now specify (and prove) equations, which are<br/>unfolded in interpreted theorems.  This is useful for replacing<br/>defined concepts (constants depending on locale parameters) by<br/>concepts already existing in the target context.  Example:<br/><br/>  interpretation partial_order [&quot;op &lt;= :: [int, int] =&gt; bool&quot;]<br/>    where &quot;partial_order.less (op &lt;=) (x::int) y = (x &lt; y)&quot;<br/><br/>Typically, the constant `partial_order.less&#39; is created by a<br/>definition specification element in the context of locale<br/>partial_order.<br/><br/>* Method &quot;induct&quot;: improved internal context management to support<br/>local fixes and defines on-the-fly. Thus explicit meta-level<br/>connectives !!  and ==&gt; are rarely required anymore in inductive goals<br/>(using object-logic connectives for this purpose has been long<br/>obsolete anyway). Common proof patterns are explained in<br/>src/HOL/Induct/Common_Patterns.thy, see also<br/>src/HOL/Isar_examples/Puzzle.thy and src/HOL/Lambda for realistic<br/>examples.<br/><br/>* Method &quot;induct&quot;: improved handling of simultaneous goals. Instead of<br/>introducing object-level conjunction, the statement is now split into<br/>several conclusions, while the corresponding symbolic cases are nested<br/>accordingly. INCOMPATIBILITY, proofs need to be structured explicitly,<br/>see src/HOL/Induct/Common_Patterns.thy, for example.<br/><br/>* Method &quot;induct&quot;: mutual induction rules are now specified as a list<br/>of rule sharing the same induction cases. HOL packages usually provide<br/>foo_bar.inducts for mutually defined items foo and bar (e.g. inductive<br/>predicates/sets or datatypes). INCOMPATIBILITY, users need to specify<br/>mutual induction rules differently, i.e. like this:<br/><br/>  (induct rule: foo_bar.inducts)<br/>  (induct set: foo bar)<br/>  (induct pred: foo bar)<br/>  (induct type: foo bar)<br/><br/>The ML function ProjectRule.projections turns old-style rules into the<br/>new format.<br/><br/>* Method &quot;coinduct&quot;: dual of induction, see<br/>src/HOL/Library/Coinductive_List.thy for various examples.<br/><br/>* Method &quot;cases&quot;, &quot;induct&quot;, &quot;coinduct&quot;: the ``(open)&#39;&#39; option is<br/>considered a legacy feature.<br/><br/>* Attribute &quot;symmetric&quot; produces result with standardized schematic<br/>variables (index 0).  Potential INCOMPATIBILITY.<br/><br/>* Simplifier: by default the simplifier trace only shows top level<br/>rewrites now. That is, trace_simp_depth_limit is set to 1 by<br/>default. Thus there is less danger of being flooded by the trace. The<br/>trace indicates where parts have been suppressed.<br/><br/>* Provers/classical: removed obsolete classical version of elim_format<br/>attribute; classical elim/dest rules are now treated uniformly when<br/>manipulating the claset.<br/><br/>* Provers/classical: stricter checks to ensure that supplied intro,<br/>dest and elim rules are well-formed; dest and elim rules must have at<br/>least one premise.<br/><br/>* Provers/classical: attributes dest/elim/intro take an optional<br/>weight argument for the rule (just as the Pure versions).  Weights are<br/>ignored by automated tools, but determine the search order of single<br/>rule steps.<br/><br/>* Syntax: input syntax now supports dummy variable binding &quot;%_. b&quot;,<br/>where the body does not mention the bound variable.  Note that dummy<br/>patterns implicitly depend on their context of bounds, which makes<br/>&quot;{_. _}&quot; match any set comprehension as expected.  Potential<br/>INCOMPATIBILITY -- parse translations need to cope with syntactic<br/>constant &quot;_idtdummy&quot; in the binding position.<br/><br/>* Syntax: removed obsolete syntactic constant &quot;_K&quot; and its associated<br/>parse translation.  INCOMPATIBILITY -- use dummy abstraction instead,<br/>for example &quot;A -&gt; B&quot; =&gt; &quot;Pi A (%_. B)&quot;.<br/><br/>* Pure: &#39;class_deps&#39; command visualizes the subclass relation, using<br/>the graph browser tool.<br/><br/>* Pure: &#39;print_theory&#39; now suppresses certain internal declarations by<br/>default; use &#39;!&#39; option for full details.<br/><br/><br/>*** HOL ***<br/><br/>* Method &quot;metis&quot; proves goals by applying the Metis general-purpose<br/>resolution prover (see also http://gilith.com/software/metis/).<br/>Examples are in the directory MetisExamples.  WARNING: the<br/>Isabelle/HOL-Metis integration does not yet work properly with<br/>multi-threading.<br/><br/>* Command &#39;sledgehammer&#39; invokes external automatic theorem provers as<br/>background processes.  It generates calls to the &quot;metis&quot; method if<br/>successful. These can be pasted into the proof.  Users do not have to<br/>wait for the automatic provers to return.  WARNING: does not really<br/>work with multi-threading.<br/><br/>* New &quot;auto_quickcheck&quot; feature tests outermost goal statements for<br/>potential counter-examples.  Controlled by ML references<br/>auto_quickcheck (default true) and auto_quickcheck_time_limit (default<br/>5000 milliseconds).  Fails silently if statements is outside of<br/>executable fragment, or any other codgenerator problem occurs.<br/><br/>* New constant &quot;undefined&quot; with axiom &quot;undefined x = undefined&quot;.<br/><br/>* Added class &quot;HOL.eq&quot;, allowing for code generation with polymorphic<br/>equality.<br/><br/>* Some renaming of class constants due to canonical name prefixing in<br/>the new &#39;class&#39; package:<br/><br/>    HOL.abs ~&gt; HOL.abs_class.abs<br/>    HOL.divide ~&gt; HOL.divide_class.divide<br/>    0 ~&gt; HOL.zero_class.zero<br/>    1 ~&gt; HOL.one_class.one<br/>    op + ~&gt; HOL.plus_class.plus<br/>    op - ~&gt; HOL.minus_class.minus<br/>    uminus ~&gt; HOL.minus_class.uminus<br/>    op * ~&gt; HOL.times_class.times<br/>    op &lt; ~&gt; HOL.ord_class.less<br/>    op &lt;= &gt; HOL.ord_class.less_eq<br/>    Nat.power ~&gt; Power.power_class.power<br/>    Nat.size ~&gt; Nat.size_class.size<br/>    Numeral.number_of ~&gt; Numeral.number_class.number_of<br/>    FixedPoint.Inf ~&gt; Lattices.complete_lattice_class.Inf<br/>    FixedPoint.Sup ~&gt; Lattices.complete_lattice_class.Sup<br/>    Orderings.min ~&gt; Orderings.ord_class.min<br/>    Orderings.max ~&gt; Orderings.ord_class.max<br/>    Divides.op div ~&gt; Divides.div_class.div<br/>    Divides.op mod ~&gt; Divides.div_class.mod<br/>    Divides.op dvd ~&gt; Divides.div_class.dvd<br/><br/>INCOMPATIBILITY.  Adaptions may be required in the following cases:<br/><br/>a) User-defined constants using any of the names &quot;plus&quot;, &quot;minus&quot;,<br/>&quot;times&quot;, &quot;less&quot; or &quot;less_eq&quot;. The standard syntax translations for<br/>&quot;+&quot;, &quot;-&quot; and &quot;*&quot; may go wrong.  INCOMPATIBILITY: use more specific<br/>names.<br/><br/>b) Variables named &quot;plus&quot;, &quot;minus&quot;, &quot;times&quot;, &quot;less&quot;, &quot;less_eq&quot;<br/>INCOMPATIBILITY: use more specific names.<br/><br/>c) Permutative equations (e.g. &quot;a + b = b + a&quot;)<br/>Since the change of names also changes the order of terms, permutative<br/>rewrite rules may get applied in a different order. Experience shows<br/>that this is rarely the case (only two adaptions in the whole Isabelle<br/>distribution).  INCOMPATIBILITY: rewrite proofs<br/><br/>d) ML code directly refering to constant names<br/>This in general only affects hand-written proof tactics, simprocs and<br/>so on.  INCOMPATIBILITY: grep your sourcecode and replace names.<br/>Consider using @{const_name} antiquotation.<br/><br/>* New class &quot;default&quot; with associated constant &quot;default&quot;.<br/><br/>* Function &quot;sgn&quot; is now overloaded and available on int, real, complex<br/>(and other numeric types), using class &quot;sgn&quot;.  Two possible defs of<br/>sgn are given as equational assumptions in the classes sgn_if and<br/>sgn_div_norm; ordered_idom now also inherits from sgn_if.<br/>INCOMPATIBILITY.<br/><br/>* Locale &quot;partial_order&quot; now unified with class &quot;order&quot; (cf. theory<br/>Orderings), added parameter &quot;less&quot;.  INCOMPATIBILITY.<br/><br/>* Renamings in classes &quot;order&quot; and &quot;linorder&quot;: facts &quot;refl&quot;, &quot;trans&quot; and<br/>&quot;cases&quot; to &quot;order_refl&quot;, &quot;order_trans&quot; and &quot;linorder_cases&quot;, to avoid<br/>clashes with HOL &quot;refl&quot; and &quot;trans&quot;.  INCOMPATIBILITY.<br/><br/>* Classes &quot;order&quot; and &quot;linorder&quot;: potential INCOMPATIBILITY due to<br/>changed order of proof goals in instance proofs.<br/><br/>* The transitivity reasoner for partial and linear orders is set up<br/>for classes &quot;order&quot; and &quot;linorder&quot;.  Instances of the reasoner are available<br/>in all contexts importing or interpreting the corresponding locales.<br/>Method &quot;order&quot; invokes the reasoner separately; the reasoner<br/>is also integrated with the Simplifier as a solver.  Diagnostic<br/>command &#39;print_orders&#39; shows the available instances of the reasoner<br/>in the current context.<br/><br/>* Localized monotonicity predicate in theory &quot;Orderings&quot;; integrated<br/>lemmas max_of_mono and min_of_mono with this predicate.<br/>INCOMPATIBILITY.<br/><br/>* Formulation of theorem &quot;dense&quot; changed slightly due to integration<br/>with new class dense_linear_order.<br/><br/>* Uniform lattice theory development in HOL.<br/><br/>    constants &quot;meet&quot; and &quot;join&quot; now named &quot;inf&quot; and &quot;sup&quot;<br/>    constant &quot;Meet&quot; now named &quot;Inf&quot;<br/><br/>    classes &quot;meet_semilorder&quot; and &quot;join_semilorder&quot; now named<br/>      &quot;lower_semilattice&quot; and &quot;upper_semilattice&quot;<br/>    class &quot;lorder&quot; now named &quot;lattice&quot;<br/>    class &quot;comp_lat&quot; now named &quot;complete_lattice&quot;<br/><br/>    Instantiation of lattice classes allows explicit definitions<br/>    for &quot;inf&quot; and &quot;sup&quot; operations (or &quot;Inf&quot; and &quot;Sup&quot; for complete lattices).<br/><br/>  INCOMPATIBILITY.  Theorem renames:<br/><br/>    meet_left_le            ~&gt; inf_le1<br/>    meet_right_le           ~&gt; inf_le2<br/>    join_left_le            ~&gt; sup_ge1<br/>    join_right_le           ~&gt; sup_ge2<br/>    meet_join_le            ~&gt; inf_sup_ord<br/>    le_meetI                ~&gt; le_infI<br/>    join_leI                ~&gt; le_supI<br/>    le_meet                 ~&gt; le_inf_iff<br/>    le_join                 ~&gt; ge_sup_conv<br/>    meet_idempotent         ~&gt; inf_idem<br/>    join_idempotent         ~&gt; sup_idem<br/>    meet_comm               ~&gt; inf_commute<br/>    join_comm               ~&gt; sup_commute<br/>    meet_leI1               ~&gt; le_infI1<br/>    meet_leI2               ~&gt; le_infI2<br/>    le_joinI1               ~&gt; le_supI1<br/>    le_joinI2               ~&gt; le_supI2<br/>    meet_assoc              ~&gt; inf_assoc<br/>    join_assoc              ~&gt; sup_assoc<br/>    meet_left_comm          ~&gt; inf_left_commute<br/>    meet_left_idempotent    ~&gt; inf_left_idem<br/>    join_left_comm          ~&gt; sup_left_commute<br/>    join_left_idempotent    ~&gt; sup_left_idem<br/>    meet_aci                ~&gt; inf_aci<br/>    join_aci                ~&gt; sup_aci<br/>    le_def_meet             ~&gt; le_iff_inf<br/>    le_def_join             ~&gt; le_iff_sup<br/>    join_absorp2            ~&gt; sup_absorb2<br/>    join_absorp1            ~&gt; sup_absorb1<br/>    meet_absorp1            ~&gt; inf_absorb1<br/>    meet_absorp2            ~&gt; inf_absorb2<br/>    meet_join_absorp        ~&gt; inf_sup_absorb<br/>    join_meet_absorp        ~&gt; sup_inf_absorb<br/>    distrib_join_le         ~&gt; distrib_sup_le<br/>    distrib_meet_le         ~&gt; distrib_inf_le<br/><br/>    add_meet_distrib_left   ~&gt; add_inf_distrib_left<br/>    add_join_distrib_left   ~&gt; add_sup_distrib_left<br/>    is_join_neg_meet        ~&gt; is_join_neg_inf<br/>    is_meet_neg_join        ~&gt; is_meet_neg_sup<br/>    add_meet_distrib_right  ~&gt; add_inf_distrib_right<br/>    add_join_distrib_right  ~&gt; add_sup_distrib_right<br/>    add_meet_join_distribs  ~&gt; add_sup_inf_distribs<br/>    join_eq_neg_meet        ~&gt; sup_eq_neg_inf<br/>    meet_eq_neg_join        ~&gt; inf_eq_neg_sup<br/>    add_eq_meet_join        ~&gt; add_eq_inf_sup<br/>    meet_0_imp_0            ~&gt; inf_0_imp_0<br/>    join_0_imp_0            ~&gt; sup_0_imp_0<br/>    meet_0_eq_0             ~&gt; inf_0_eq_0<br/>    join_0_eq_0             ~&gt; sup_0_eq_0<br/>    neg_meet_eq_join        ~&gt; neg_inf_eq_sup<br/>    neg_join_eq_meet        ~&gt; neg_sup_eq_inf<br/>    join_eq_if              ~&gt; sup_eq_if<br/><br/>    mono_meet               ~&gt; mono_inf<br/>    mono_join               ~&gt; mono_sup<br/>    meet_bool_eq            ~&gt; inf_bool_eq<br/>    join_bool_eq            ~&gt; sup_bool_eq<br/>    meet_fun_eq             ~&gt; inf_fun_eq<br/>    join_fun_eq             ~&gt; sup_fun_eq<br/>    meet_set_eq             ~&gt; inf_set_eq<br/>    join_set_eq             ~&gt; sup_set_eq<br/>    meet1_iff               ~&gt; inf1_iff<br/>    meet2_iff               ~&gt; inf2_iff<br/>    meet1I                  ~&gt; inf1I<br/>    meet2I                  ~&gt; inf2I<br/>    meet1D1                 ~&gt; inf1D1<br/>    meet2D1                 ~&gt; inf2D1<br/>    meet1D2                 ~&gt; inf1D2<br/>    meet2D2                 ~&gt; inf2D2<br/>    meet1E                  ~&gt; inf1E<br/>    meet2E                  ~&gt; inf2E<br/>    join1_iff               ~&gt; sup1_iff<br/>    join2_iff               ~&gt; sup2_iff<br/>    join1I1                 ~&gt; sup1I1<br/>    join2I1                 ~&gt; sup2I1<br/>    join1I1                 ~&gt; sup1I1<br/>    join2I2                 ~&gt; sup1I2<br/>    join1CI                 ~&gt; sup1CI<br/>    join2CI                 ~&gt; sup2CI<br/>    join1E                  ~&gt; sup1E<br/>    join2E                  ~&gt; sup2E<br/><br/>    is_meet_Meet            ~&gt; is_meet_Inf<br/>    Meet_bool_def           ~&gt; Inf_bool_def<br/>    Meet_fun_def            ~&gt; Inf_fun_def<br/>    Meet_greatest           ~&gt; Inf_greatest<br/>    Meet_lower              ~&gt; Inf_lower<br/>    Meet_set_def            ~&gt; Inf_set_def<br/><br/>    Sup_def                 ~&gt; Sup_Inf<br/>    Sup_bool_eq             ~&gt; Sup_bool_def<br/>    Sup_fun_eq              ~&gt; Sup_fun_def<br/>    Sup_set_eq              ~&gt; Sup_set_def<br/><br/>    listsp_meetI            ~&gt; listsp_infI<br/>    listsp_meet_eq          ~&gt; listsp_inf_eq<br/><br/>    meet_min                ~&gt; inf_min<br/>    join_max                ~&gt; sup_max<br/><br/>* Added syntactic class &quot;size&quot;; overloaded constant &quot;size&quot; now has<br/>type &quot;&#39;a::size ==&gt; bool&quot;<br/><br/>* Internal reorganisation of `size&#39; of datatypes: size theorems<br/>&quot;foo.size&quot; are no longer subsumed by &quot;foo.simps&quot; (but are still<br/>simplification rules by default!); theorems &quot;prod.size&quot; now named<br/>&quot;*.size&quot;.<br/><br/>* Class &quot;div&quot; now inherits from class &quot;times&quot; rather than &quot;type&quot;.<br/>INCOMPATIBILITY.<br/><br/>* HOL/Finite_Set: &quot;name-space&quot; locales Lattice, Distrib_lattice,<br/>Linorder etc.  have disappeared; operations defined in terms of<br/>fold_set now are named Inf_fin, Sup_fin.  INCOMPATIBILITY.<br/><br/>* HOL/Nat: neq0_conv no longer declared as iff.  INCOMPATIBILITY.<br/><br/>* HOL-Word: New extensive library and type for generic, fixed size<br/>machine words, with arithmetic, bit-wise, shifting and rotating<br/>operations, reflection into int, nat, and bool lists, automation for<br/>linear arithmetic (by automatic reflection into nat or int), including<br/>lemmas on overflow and monotonicity.  Instantiated to all appropriate<br/>arithmetic type classes, supporting automatic simplification of<br/>numerals on all operations.<br/><br/>* Library/Boolean_Algebra: locales for abstract boolean algebras.<br/><br/>* Library/Numeral_Type: numbers as types, e.g. TYPE(32).<br/><br/>* Code generator library theories:<br/>  - Code_Integer represents HOL integers by big integer literals in target<br/>    languages.<br/>  - Code_Char represents HOL characters by character literals in target<br/>    languages.<br/>  - Code_Char_chr like Code_Char, but also offers treatment of character<br/>    codes; includes Code_Integer.<br/>  - Executable_Set allows to generate code for finite sets using lists.<br/>  - Executable_Rat implements rational numbers as triples (sign, enumerator,<br/>    denominator).<br/>  - Executable_Real implements a subset of real numbers, namly those<br/>    representable by rational numbers.<br/>  - Efficient_Nat implements natural numbers by integers, which in general will<br/>    result in higher efficency; pattern matching with 0/Suc is eliminated;<br/>    includes Code_Integer.<br/>  - Code_Index provides an additional datatype index which is mapped to<br/>    target-language built-in integers.<br/>  - Code_Message provides an additional datatype message_string which is isomorphic to<br/>    strings; messages are mapped to target-language strings.<br/><br/>* New package for inductive predicates<br/><br/>  An n-ary predicate p with m parameters z_1, ..., z_m can now be defined via<br/><br/>    inductive<br/>      p :: &quot;U_1 =&gt; ... =&gt; U_m =&gt; T_1 =&gt; ... =&gt; T_n =&gt; bool&quot;<br/>      for z_1 :: U_1 and ... and z_n :: U_m<br/>    where<br/>      rule_1: &quot;... ==&gt; p z_1 ... z_m t_1_1 ... t_1_n&quot;<br/>    | ...<br/><br/>  with full support for type-inference, rather than<br/><br/>    consts s :: &quot;U_1 =&gt; ... =&gt; U_m =&gt; (T_1 * ... * T_n) set&quot;<br/><br/>    abbreviation p :: &quot;U_1 =&gt; ... =&gt; U_m =&gt; T_1 =&gt; ... =&gt; T_n =&gt; bool&quot;<br/>    where &quot;p z_1 ... z_m x_1 ... x_n == (x_1, ..., x_n) : s z_1 ... z_m&quot;<br/><br/>    inductive &quot;s z_1 ... z_m&quot;<br/>    intros<br/>      rule_1: &quot;... ==&gt; (t_1_1, ..., t_1_n) : s z_1 ... z_m&quot;<br/>      ...<br/><br/>  For backward compatibility, there is a wrapper allowing inductive<br/>  sets to be defined with the new package via<br/><br/>    inductive_set<br/>      s :: &quot;U_1 =&gt; ... =&gt; U_m =&gt; (T_1 * ... * T_n) set&quot;<br/>      for z_1 :: U_1 and ... and z_n :: U_m<br/>    where<br/>      rule_1: &quot;... ==&gt; (t_1_1, ..., t_1_n) : s z_1 ... z_m&quot;<br/>    | ...<br/><br/>  or<br/><br/>    inductive_set<br/>      s :: &quot;U_1 =&gt; ... =&gt; U_m =&gt; (T_1 * ... * T_n) set&quot;<br/>      and p :: &quot;U_1 =&gt; ... =&gt; U_m =&gt; T_1 =&gt; ... =&gt; T_n =&gt; bool&quot;<br/>      for z_1 :: U_1 and ... and z_n :: U_m<br/>    where<br/>      &quot;p z_1 ... z_m x_1 ... x_n == (x_1, ..., x_n) : s z_1 ... z_m&quot;<br/>    | rule_1: &quot;... ==&gt; p z_1 ... z_m t_1_1 ... t_1_n&quot;<br/>    | ...<br/><br/>  if the additional syntax &quot;p ...&quot; is required.<br/><br/>  Numerous examples can be found in the subdirectories src/HOL/Auth,<br/>  src/HOL/Bali, src/HOL/Induct, and src/HOL/MicroJava.<br/><br/>  INCOMPATIBILITIES:<br/><br/>  - Since declaration and definition of inductive sets or predicates<br/>    is no longer separated, abbreviations involving the newly<br/>    introduced sets or predicates must be specified together with the<br/>    introduction rules after the &#39;where&#39; keyword (see above), rather<br/>    than before the actual inductive definition.<br/><br/>  - The variables in induction and elimination rules are now<br/>    quantified in the order of their occurrence in the introduction<br/>    rules, rather than in alphabetical order. Since this may break<br/>    some proofs, these proofs either have to be repaired, e.g. by<br/>    reordering the variables a_i_1 ... a_i_{k_i} in Isar &#39;case&#39;<br/>    statements of the form<br/><br/>      case (rule_i a_i_1 ... a_i_{k_i})<br/><br/>    or the old order of quantification has to be restored by explicitly adding<br/>    meta-level quantifiers in the introduction rules, i.e.<br/><br/>      | rule_i: &quot;!!a_i_1 ... a_i_{k_i}. ... ==&gt; p z_1 ... z_m t_i_1 ... t_i_n&quot;<br/><br/>  - The format of the elimination rules is now<br/><br/>      p z_1 ... z_m x_1 ... x_n ==&gt;<br/>        (!!a_1_1 ... a_1_{k_1}. x_1 = t_1_1 ==&gt; ... ==&gt; x_n = t_1_n ==&gt; ... ==&gt; P)<br/>        ==&gt; ... ==&gt; P<br/><br/>    for predicates and<br/><br/>      (x_1, ..., x_n) : s z_1 ... z_m ==&gt;<br/>        (!!a_1_1 ... a_1_{k_1}. x_1 = t_1_1 ==&gt; ... ==&gt; x_n = t_1_n ==&gt; ... ==&gt; P)<br/>        ==&gt; ... ==&gt; P<br/><br/>    for sets rather than<br/><br/>      x : s z_1 ... z_m ==&gt;<br/>        (!!a_1_1 ... a_1_{k_1}. x = (t_1_1, ..., t_1_n) ==&gt; ... ==&gt; P)<br/>        ==&gt; ... ==&gt; P<br/><br/>    This may require terms in goals to be expanded to n-tuples<br/>    (e.g. using case_tac or simplification with the split_paired_all<br/>    rule) before the above elimination rule is applicable.<br/><br/>  - The elimination or case analysis rules for (mutually) inductive<br/>    sets or predicates are now called &quot;p_1.cases&quot; ... &quot;p_k.cases&quot;. The<br/>    list of rules &quot;p_1_..._p_k.elims&quot; is no longer available.<br/><br/>* New package &quot;function&quot;/&quot;fun&quot; for general recursive functions,<br/>supporting mutual and nested recursion, definitions in local contexts,<br/>more general pattern matching and partiality. See HOL/ex/Fundefs.thy<br/>for small examples, and the separate tutorial on the function<br/>package. The old recdef &quot;package&quot; is still available as before, but<br/>users are encouraged to use the new package.<br/><br/>* Method &quot;lexicographic_order&quot; automatically synthesizes termination<br/>relations as lexicographic combinations of size measures.<br/><br/>* Case-expressions allow arbitrary constructor-patterns (including<br/>&quot;_&quot;) and take their order into account, like in functional<br/>programming.  Internally, this is translated into nested<br/>case-expressions; missing cases are added and mapped to the predefined<br/>constant &quot;undefined&quot;. In complicated cases printing may no longer show<br/>the original input but the internal form. Lambda-abstractions allow<br/>the same form of pattern matching: &quot;% pat1 =&gt; e1 | ...&quot; is an<br/>abbreviation for &quot;%x. case x of pat1 =&gt; e1 | ...&quot; where x is a new<br/>variable.<br/><br/>* IntDef: The constant &quot;int :: nat =&gt; int&quot; has been removed; now &quot;int&quot;<br/>is an abbreviation for &quot;of_nat :: nat =&gt; int&quot;. The simplification<br/>rules for &quot;of_nat&quot; have been changed to work like &quot;int&quot; did<br/>previously.  Potential INCOMPATIBILITY:<br/>  - &quot;of_nat (Suc m)&quot; simplifies to &quot;1 + of_nat m&quot; instead of &quot;of_nat m + 1&quot;<br/>  - of_nat_diff and of_nat_mult are no longer default simp rules<br/><br/>* Method &quot;algebra&quot; solves polynomial equations over (semi)rings using<br/>Groebner bases. The (semi)ring structure is defined by locales and the<br/>tool setup depends on that generic context. Installing the method for<br/>a specific type involves instantiating the locale and possibly adding<br/>declarations for computation on the coefficients.  The method is<br/>already instantiated for natural numbers and for the axiomatic class<br/>of idoms with numerals.  See also the paper by Chaieb and Wenzel at<br/>CALCULEMUS 2007 for the general principles underlying this<br/>architecture of context-aware proof-tools.<br/><br/>* Method &quot;ferrack&quot; implements quantifier elimination over<br/>special-purpose dense linear orders using locales (analogous to<br/>&quot;algebra&quot;). The method is already installed for class<br/>{ordered_field,recpower,number_ring} which subsumes real, hyperreal,<br/>rat, etc.<br/><br/>* Former constant &quot;List.op @&quot; now named &quot;List.append&quot;.  Use ML<br/>antiquotations @{const_name List.append} or @{term &quot; ... @ ... &quot;} to<br/>circumvent possible incompatibilities when working on ML level.<br/><br/>* primrec: missing cases mapped to &quot;undefined&quot; instead of &quot;arbitrary&quot;.<br/><br/>* New function listsum :: &#39;a list =&gt; &#39;a for arbitrary monoids.<br/>Special syntax: &quot;SUM x &lt;- xs. f x&quot; (and latex variants)<br/><br/>* New syntax for Haskell-like list comprehension (input only), eg.<br/>[(x,y). x &lt;- xs, y &lt;- ys, x ~= y], see also src/HOL/List.thy.<br/><br/>* The special syntax for function &quot;filter&quot; has changed from [x :<br/>xs. P] to [x &lt;- xs. P] to avoid an ambiguity caused by list<br/>comprehension syntax, and for uniformity.  INCOMPATIBILITY.<br/><br/>* [a..b] is now defined for arbitrary linear orders.  It used to be<br/>defined on nat only, as an abbreviation for [a..&lt;Suc b]<br/>INCOMPATIBILITY.<br/><br/>* Renamed lemma &quot;set_take_whileD&quot;  to &quot;set_takeWhileD&quot;.<br/><br/>* New functions &quot;sorted&quot; and &quot;sort&quot; in src/HOL/List.thy.<br/><br/>* New lemma collection field_simps (an extension of ring_simps) for<br/>manipulating (in)equations involving division. Multiplies with all<br/>denominators that can be proved to be non-zero (in equations) or<br/>positive/negative (in inequations).<br/><br/>* Lemma collections ring_eq_simps, group_eq_simps and ring_distrib<br/>have been improved and renamed to ring_simps, group_simps and<br/>ring_distribs.  Removed lemmas field_xyz in theory Ring_and_Field<br/>because they were subsumed by lemmas xyz.  INCOMPATIBILITY.<br/><br/>* Theory Library/Commutative_Ring: switched from recdef to function<br/>package; constants add, mul, pow now curried.  Infix syntax for<br/>algebraic operations.<br/><br/>* Dropped redundant lemma def_imp_eq in favor of meta_eq_to_obj_eq.<br/>INCOMPATIBILITY.<br/><br/>* Dropped redundant lemma if_def2 in favor of if_bool_eq_conj.<br/>INCOMPATIBILITY.<br/><br/>* HOL/records: generalised field-update to take a function on the<br/>field rather than the new value: r(|A := x|) is translated to A_update<br/>(K x) r The K-combinator that is internally used is called K_record.<br/>INCOMPATIBILITY: Usage of the plain update functions has to be<br/>adapted.<br/><br/>* Class &quot;semiring_0&quot; now contains annihilation axioms x * 0 = 0 and 0<br/>* x = 0, which are required for a semiring.  Richer structures do not<br/>inherit from semiring_0 anymore, because this property is a theorem<br/>there, not an axiom.  INCOMPATIBILITY: In instances of semiring_0,<br/>there is more to prove, but this is mostly trivial.<br/><br/>* Class &quot;recpower&quot; is generalized to arbitrary monoids, not just<br/>commutative semirings.  INCOMPATIBILITY: may need to incorporate<br/>commutativity or semiring properties additionally.<br/><br/>* Constant &quot;List.list_all2&quot; in List.thy now uses authentic syntax.<br/>INCOMPATIBILITY: translations containing list_all2 may go wrong,<br/>better use &#39;abbreviation&#39;.<br/><br/>* Renamed constant &quot;List.op mem&quot; to &quot;List.member&quot;.  INCOMPATIBILITY.<br/><br/>* Numeral syntax: type &#39;bin&#39; which was a mere type copy of &#39;int&#39; has<br/>been abandoned in favour of plain &#39;int&#39;.  INCOMPATIBILITY --<br/>significant changes for setting up numeral syntax for types:<br/>  - New constants Numeral.pred and Numeral.succ instead<br/>      of former Numeral.bin_pred and Numeral.bin_succ.<br/>  - Use integer operations instead of bin_add, bin_mult and so on.<br/>  - Numeral simplification theorems named Numeral.numeral_simps instead of Bin_simps.<br/>  - ML structure Bin_Simprocs now named Int_Numeral_Base_Simprocs.<br/><br/>See src/HOL/Integ/IntArith.thy for an example setup.<br/><br/>* Command &#39;normal_form&#39; computes the normal form of a term that may<br/>contain free variables.  For example ``normal_form &quot;rev [a, b, c]&quot;&#39;&#39;<br/>produces ``[b, c, a]&#39;&#39; (without proof).  This command is suitable for<br/>heavy-duty computations because the functions are compiled to ML<br/>first.  Correspondingly, a method &quot;normalization&quot; is provided.  See<br/>further src/HOL/ex/NormalForm.thy and src/Tools/nbe.ML.<br/><br/>* Alternative iff syntax &quot;A &lt;-&gt; B&quot; for equality on bool (with priority<br/>25 like --&gt;); output depends on the &quot;iff&quot; print_mode, the default is<br/>&quot;A = B&quot; (with priority 50).<br/><br/>* Relations less (&lt;) and less_eq (&lt;=) are also available on type bool.<br/>Modified syntax to disallow nesting without explicit parentheses,<br/>e.g. &quot;(x &lt; y) &lt; z&quot; or &quot;x &lt; (y &lt; z)&quot;, but NOT &quot;x &lt; y &lt; z&quot;.  Potential<br/>INCOMPATIBILITY.<br/><br/>* &quot;LEAST x:A. P&quot; expands to &quot;LEAST x. x:A &amp; P&quot; (input only).<br/><br/>* Relation composition operator &quot;op O&quot; now has precedence 75 and binds<br/>stronger than union and intersection. INCOMPATIBILITY.<br/><br/>* The old set interval syntax &quot;{m..n(}&quot; (and relatives) has been<br/>removed.  Use &quot;{m..&lt;n}&quot; (and relatives) instead.<br/><br/>* In the context of the assumption &quot;~(s = t)&quot; the Simplifier rewrites<br/>&quot;t = s&quot; to False (by simproc &quot;neq&quot;).  INCOMPATIBILITY, consider using<br/>``declare [[simproc del: neq]]&#39;&#39;.<br/><br/>* Simplifier: &quot;m dvd n&quot; where m and n are numbers is evaluated to<br/>True/False.<br/><br/>* Theorem Cons_eq_map_conv no longer declared as &quot;simp&quot;.<br/><br/>* Theorem setsum_mult renamed to setsum_right_distrib.<br/><br/>* Prefer ex1I over ex_ex1I in single-step reasoning, e.g. by the<br/>``rule&#39;&#39; method.<br/><br/>* Reimplemented methods &quot;sat&quot; and &quot;satx&quot;, with several improvements:<br/>goals no longer need to be stated as &quot;&lt;prems&gt; ==&gt; False&quot;, equivalences<br/>(i.e. &quot;=&quot; on type bool) are handled, variable names of the form<br/>&quot;lit_&lt;n&gt;&quot; are no longer reserved, significant speedup.<br/><br/>* Methods &quot;sat&quot; and &quot;satx&quot; can now replay MiniSat proof traces.<br/>zChaff is still supported as well.<br/><br/>* &#39;inductive&#39; and &#39;datatype&#39;: provide projections of mutual rules,<br/>bundled as foo_bar.inducts;<br/><br/>* Library: moved theories Parity, GCD, Binomial, Infinite_Set to<br/>Library.<br/><br/>* Library: moved theory Accessible_Part to main HOL.<br/><br/>* Library: added theory Coinductive_List of potentially infinite lists<br/>as greatest fixed-point.<br/><br/>* Library: added theory AssocList which implements (finite) maps as<br/>association lists.<br/><br/>* Method &quot;evaluation&quot; solves goals (i.e. a boolean expression)<br/>efficiently by compiling it to ML.  The goal is &quot;proved&quot; (via an<br/>oracle) if it evaluates to True.<br/><br/>* Linear arithmetic now splits certain operators (e.g. min, max, abs)<br/>also when invoked by the simplifier.  This results in the Simplifier<br/>being more powerful on arithmetic goals.  INCOMPATIBILITY.<br/>Configuration option fast_arith_split_limit=0 recovers the old<br/>behavior.<br/><br/>* Support for hex (0x20) and binary (0b1001) numerals.<br/><br/>* New method: reify eqs (t), where eqs are equations for an<br/>interpretation I :: &#39;a list =&gt; &#39;b =&gt; &#39;c and t::&#39;c is an optional<br/>parameter, computes a term s::&#39;b and a list xs::&#39;a list and proves the<br/>theorem I xs s = t. This is also known as reification or quoting. The<br/>resulting theorem is applied to the subgoal to substitute t with I xs<br/>s.  If t is omitted, the subgoal itself is reified.<br/><br/>* New method: reflection corr_thm eqs (t). The parameters eqs and (t)<br/>are as explained above. corr_thm is a theorem for I vs (f t) = I vs t,<br/>where f is supposed to be a computable function (in the sense of code<br/>generattion). The method uses reify to compute s and xs as above then<br/>applies corr_thm and uses normalization by evaluation to &quot;prove&quot; f s =<br/>r and finally gets the theorem t = r, which is again applied to the<br/>subgoal. An Example is available in src/HOL/ex/ReflectionEx.thy.<br/><br/>* Reflection: Automatic reification now handels binding, an example is<br/>available in src/HOL/ex/ReflectionEx.thy<br/><br/>* HOL-Statespace: ``State Spaces: The Locale Way&#39;&#39; introduces a<br/>command &#39;statespace&#39; that is similar to &#39;record&#39;, but introduces an<br/>abstract specification based on the locale infrastructure instead of<br/>HOL types.  This leads to extra flexibility in composing state spaces,<br/>in particular multiple inheritance and renaming of components.<br/><br/><br/>*** HOL-Complex ***<br/><br/>* Hyperreal: Functions root and sqrt are now defined on negative real<br/>inputs so that root n (- x) = - root n x and sqrt (- x) = - sqrt x.<br/>Nonnegativity side conditions have been removed from many lemmas, so<br/>that more subgoals may now be solved by simplification; potential<br/>INCOMPATIBILITY.<br/><br/>* Real: new type classes formalize real normed vector spaces and<br/>algebras, using new overloaded constants scaleR :: real =&gt; &#39;a =&gt; &#39;a<br/>and norm :: &#39;a =&gt; real.<br/><br/>* Real: constant of_real :: real =&gt; &#39;a::real_algebra_1 injects from<br/>reals into other types. The overloaded constant Reals :: &#39;a set is now<br/>defined as range of_real; potential INCOMPATIBILITY.<br/><br/>* Real: proper support for ML code generation, including &#39;quickcheck&#39;.<br/>Reals are implemented as arbitrary precision rationals.<br/><br/>* Hyperreal: Several constants that previously worked only for the<br/>reals have been generalized, so they now work over arbitrary vector<br/>spaces. Type annotations may need to be added in some cases; potential<br/>INCOMPATIBILITY.<br/><br/>  Infinitesimal  :: (&#39;a::real_normed_vector) star set<br/>  HFinite        :: (&#39;a::real_normed_vector) star set<br/>  HInfinite      :: (&#39;a::real_normed_vector) star set<br/>  approx         :: (&#39;a::real_normed_vector) star =&gt; &#39;a star =&gt; bool<br/>  monad          :: (&#39;a::real_normed_vector) star =&gt; &#39;a star set<br/>  galaxy         :: (&#39;a::real_normed_vector) star =&gt; &#39;a star set<br/>  (NS)LIMSEQ     :: [nat =&gt; &#39;a::real_normed_vector, &#39;a] =&gt; bool<br/>  (NS)convergent :: (nat =&gt; &#39;a::real_normed_vector) =&gt; bool<br/>  (NS)Bseq       :: (nat =&gt; &#39;a::real_normed_vector) =&gt; bool<br/>  (NS)Cauchy     :: (nat =&gt; &#39;a::real_normed_vector) =&gt; bool<br/>  (NS)LIM        :: [&#39;a::real_normed_vector =&gt; &#39;b::real_normed_vector, &#39;a, &#39;b] =&gt; bool<br/>  is(NS)Cont     :: [&#39;a::real_normed_vector =&gt; &#39;b::real_normed_vector, &#39;a] =&gt; bool<br/>  deriv          :: [&#39;a::real_normed_field =&gt; &#39;a, &#39;a, &#39;a] =&gt; bool<br/>  sgn            :: &#39;a::real_normed_vector =&gt; &#39;a<br/>  exp            :: &#39;a::{recpower,real_normed_field,banach} =&gt; &#39;a<br/><br/>* Complex: Some complex-specific constants are now abbreviations for<br/>overloaded ones: complex_of_real = of_real, cmod = norm, hcmod =<br/>hnorm.  Other constants have been entirely removed in favor of the<br/>polymorphic versions (INCOMPATIBILITY):<br/><br/>  approx        &lt;-- capprox<br/>  HFinite       &lt;-- CFinite<br/>  HInfinite     &lt;-- CInfinite<br/>  Infinitesimal &lt;-- CInfinitesimal<br/>  monad         &lt;-- cmonad<br/>  galaxy        &lt;-- cgalaxy<br/>  (NS)LIM       &lt;-- (NS)CLIM, (NS)CRLIM<br/>  is(NS)Cont    &lt;-- is(NS)Contc, is(NS)contCR<br/>  (ns)deriv     &lt;-- (ns)cderiv<br/><br/><br/>*** HOL-Algebra ***<br/><br/>* Formalisation of ideals and the quotient construction over rings.<br/><br/>* Order and lattice theory no longer based on records.<br/>INCOMPATIBILITY.<br/><br/>* Renamed lemmas least_carrier -&gt; least_closed and greatest_carrier -&gt;<br/>greatest_closed.  INCOMPATIBILITY.<br/><br/>* Method algebra is now set up via an attribute.  For examples see<br/>Ring.thy.  INCOMPATIBILITY: the method is now weaker on combinations<br/>of algebraic structures.<br/><br/>* Renamed theory CRing to Ring.<br/><br/><br/>*** HOL-Nominal ***<br/><br/>* Substantial, yet incomplete support for nominal datatypes (binding<br/>structures) based on HOL-Nominal logic.  See src/HOL/Nominal and<br/>src/HOL/Nominal/Examples.  Prospective users should consult<br/>http://isabelle.in.tum.de/nominal/<br/><br/><br/>*** ML ***<br/><br/>* ML basics: just one true type int, which coincides with IntInf.int<br/>(even on SML/NJ).<br/><br/>* ML within Isar: antiquotations allow to embed statically-checked<br/>formal entities in the source, referring to the context available at<br/>compile-time.  For example:<br/><br/>ML {* @{sort &quot;{zero,one}&quot;} *}<br/>ML {* @{typ &quot;&#39;a =&gt; &#39;b&quot;} *}<br/>ML {* @{term &quot;%x. x&quot;} *}<br/>ML {* @{prop &quot;x == y&quot;} *}<br/>ML {* @{ctyp &quot;&#39;a =&gt; &#39;b&quot;} *}<br/>ML {* @{cterm &quot;%x. x&quot;} *}<br/>ML {* @{cprop &quot;x == y&quot;} *}<br/>ML {* @{thm asm_rl} *}<br/>ML {* @{thms asm_rl} *}<br/>ML {* @{type_name c} *}<br/>ML {* @{type_syntax c} *}<br/>ML {* @{const_name c} *}<br/>ML {* @{const_syntax c} *}<br/>ML {* @{context} *}<br/>ML {* @{theory} *}<br/>ML {* @{theory Pure} *}<br/>ML {* @{theory_ref} *}<br/>ML {* @{theory_ref Pure} *}<br/>ML {* @{simpset} *}<br/>ML {* @{claset} *}<br/>ML {* @{clasimpset} *}<br/><br/>The same works for sources being ``used&#39;&#39; within an Isar context.<br/><br/>* ML in Isar: improved error reporting; extra verbosity with<br/>ML_Context.trace enabled.<br/><br/>* Pure/General/table.ML: the join operations now works via exceptions<br/>DUP/SAME instead of type option. This is simpler in simple cases, and<br/>admits slightly more efficient complex applications.<br/><br/>* Pure: &#39;advanced&#39; translation functions (parse_translation etc.) now<br/>use Context.generic instead of just theory.<br/><br/>* Pure: datatype Context.generic joins theory/Proof.context and<br/>provides some facilities for code that works in either kind of<br/>context, notably GenericDataFun for uniform theory and proof data.<br/><br/>* Pure: simplified internal attribute type, which is now always<br/>Context.generic * thm -&gt; Context.generic * thm. Global (theory) vs.<br/>local (Proof.context) attributes have been discontinued, while<br/>minimizing code duplication. Thm.rule_attribute and<br/>Thm.declaration_attribute build canonical attributes; see also structure<br/>Context for further operations on Context.generic, notably<br/>GenericDataFun. INCOMPATIBILITY, need to adapt attribute type<br/>declarations and definitions.<br/><br/>* Context data interfaces (Theory/Proof/GenericDataFun): removed<br/>name/print, uninitialized data defaults to ad-hoc copy of empty value,<br/>init only required for impure data. INCOMPATIBILITY: empty really need<br/>to be empty (no dependencies on theory content!)<br/><br/>* Pure/kernel: consts certification ignores sort constraints given in<br/>signature declarations. (This information is not relevant to the<br/>logic, but only for type inference.) SIGNIFICANT INTERNAL CHANGE,<br/>potential INCOMPATIBILITY.<br/><br/>* Pure: axiomatic type classes are now purely definitional, with<br/>explicit proofs of class axioms and super class relations performed<br/>internally. See Pure/axclass.ML for the main internal interfaces --<br/>notably AxClass.define_class supercedes AxClass.add_axclass, and<br/>AxClass.axiomatize_class/classrel/arity supersede<br/>Sign.add_classes/classrel/arities.<br/><br/>* Pure/Isar: Args/Attrib parsers operate on Context.generic --<br/>global/local versions on theory vs. Proof.context have been<br/>discontinued; Attrib.syntax and Method.syntax have been adapted<br/>accordingly.  INCOMPATIBILITY, need to adapt parser expressions for<br/>attributes, methods, etc.<br/><br/>* Pure: several functions of signature &quot;... -&gt; theory -&gt; theory * ...&quot;<br/>have been reoriented to &quot;... -&gt; theory -&gt; ... * theory&quot; in order to<br/>allow natural usage in combination with the ||&gt;, ||&gt;&gt;, |-&gt; and<br/>fold_map combinators.<br/><br/>* Pure: official theorem names (closed derivations) and additional<br/>comments (tags) are now strictly separate.  Name hints -- which are<br/>maintained as tags -- may be attached any time without affecting the<br/>derivation.<br/><br/>* Pure: primitive rule lift_rule now takes goal cterm instead of an<br/>actual goal state (thm).  Use Thm.lift_rule (Thm.cprem_of st i) to<br/>achieve the old behaviour.<br/><br/>* Pure: the &quot;Goal&quot; constant is now called &quot;prop&quot;, supporting a<br/>slightly more general idea of ``protecting&#39;&#39; meta-level rule<br/>statements.<br/><br/>* Pure: Logic.(un)varify only works in a global context, which is now<br/>enforced instead of silently assumed.  INCOMPATIBILITY, may use<br/>Logic.legacy_(un)varify as temporary workaround.<br/><br/>* Pure: structure Name provides scalable operations for generating<br/>internal variable names, notably Name.variants etc.  This replaces<br/>some popular functions from term.ML:<br/><br/>  Term.variant		-&gt;  Name.variant<br/>  Term.variantlist	-&gt;  Name.variant_list<br/>  Term.invent_names	-&gt;  Name.invent_list<br/><br/>Note that low-level renaming rarely occurs in new code -- operations<br/>from structure Variable are used instead (see below).<br/><br/>* Pure: structure Variable provides fundamental operations for proper<br/>treatment of fixed/schematic variables in a context.  For example,<br/>Variable.import introduces fixes for schematics of given facts and<br/>Variable.export reverses the effect (up to renaming) -- this replaces<br/>various freeze_thaw operations.<br/><br/>* Pure: structure Goal provides simple interfaces for<br/>init/conclude/finish and tactical prove operations (replacing former<br/>Tactic.prove).  Goal.prove is the canonical way to prove results<br/>within a given context; Goal.prove_global is a degraded version for<br/>theory level goals, including a global Drule.standard.  Note that<br/>OldGoals.prove_goalw_cterm has long been obsolete, since it is<br/>ill-behaved in a local proof context (e.g. with local fixes/assumes or<br/>in a locale context).<br/><br/>* Pure/Syntax: generic interfaces for parsing (Syntax.parse_term etc.)<br/>and type checking (Syntax.check_term etc.), with common combinations<br/>(Syntax.read_term etc.). These supersede former Sign.read_term etc.<br/>which are considered legacy and await removal.<br/><br/>* Pure/Syntax: generic interfaces for type unchecking<br/>(Syntax.uncheck_terms etc.) and unparsing (Syntax.unparse_term etc.),<br/>with common combinations (Syntax.pretty_term, Syntax.string_of_term<br/>etc.).  Former Sign.pretty_term, Sign.string_of_term etc. are still<br/>available for convenience, but refer to the very same operations using<br/>a mere theory instead of a full context.<br/><br/>* Isar: simplified treatment of user-level errors, using exception<br/>ERROR of string uniformly.  Function error now merely raises ERROR,<br/>without any side effect on output channels.  The Isar toplevel takes<br/>care of proper display of ERROR exceptions.  ML code may use plain<br/>handle/can/try; cat_error may be used to concatenate errors like this:<br/><br/>  ... handle ERROR msg =&gt; cat_error msg &quot;...&quot;<br/><br/>Toplevel ML code (run directly or through the Isar toplevel) may be<br/>embedded into the Isar toplevel with exception display/debug like<br/>this:<br/><br/>  Isar.toplevel (fn () =&gt; ...)<br/><br/>INCOMPATIBILITY, removed special transform_error facilities, removed<br/>obsolete variants of user-level exceptions (ERROR_MESSAGE,<br/>Context.PROOF, ProofContext.CONTEXT, Proof.STATE, ProofHistory.FAIL)<br/>-- use plain ERROR instead.<br/><br/>* Isar: theory setup now has type (theory -&gt; theory), instead of a<br/>list.  INCOMPATIBILITY, may use #&gt; to compose setup functions.<br/><br/>* Isar: ML toplevel pretty printer for type Proof.context, subject to<br/>ProofContext.debug/verbose flags.<br/><br/>* Isar: Toplevel.theory_to_proof admits transactions that modify the<br/>theory before entering a proof state.  Transactions now always see a<br/>quasi-functional intermediate checkpoint, both in interactive and<br/>batch mode.<br/><br/>* Isar: simplified interfaces for outer syntax.  Renamed<br/>OuterSyntax.add_keywords to OuterSyntax.keywords.  Removed<br/>OuterSyntax.add_parsers -- this functionality is now included in<br/>OuterSyntax.command etc.  INCOMPATIBILITY.<br/><br/>* Simplifier: the simpset of a running simplification process now<br/>contains a proof context (cf. Simplifier.the_context), which is the<br/>very context that the initial simpset has been retrieved from (by<br/>simpset_of/local_simpset_of).  Consequently, all plug-in components<br/>(solver, looper etc.) may depend on arbitrary proof data.<br/><br/>* Simplifier.inherit_context inherits the proof context (plus the<br/>local bounds) of the current simplification process; any simproc<br/>etc. that calls the Simplifier recursively should do this!  Removed<br/>former Simplifier.inherit_bounds, which is already included here --<br/>INCOMPATIBILITY.  Tools based on low-level rewriting may even have to<br/>specify an explicit context using Simplifier.context/theory_context.<br/><br/>* Simplifier/Classical Reasoner: more abstract interfaces<br/>change_simpset/claset for modifying the simpset/claset reference of a<br/>theory; raw versions simpset/claset_ref etc. have been discontinued --<br/>INCOMPATIBILITY.<br/><br/>* Provers: more generic wrt. syntax of object-logics, avoid hardwired<br/>&quot;Trueprop&quot; etc.<br/><br/><br/>*** System ***<br/><br/>* settings: the default heap location within ISABELLE_HOME_USER now<br/>includes ISABELLE_IDENTIFIER.  This simplifies use of multiple<br/>Isabelle installations.<br/><br/>* isabelle-process: option -S (secure mode) disables some critical<br/>operations, notably runtime compilation and evaluation of ML source<br/>code.<br/><br/>* Basic Isabelle mode for jEdit, see Isabelle/lib/jedit/.<br/><br/>* Support for parallel execution, using native multicore support of<br/>Poly/ML 5.1.  The theory loader exploits parallelism when processing<br/>independent theories, according to the given theory header<br/>specifications. The maximum number of worker threads is specified via<br/>usedir option -M or the &quot;max-threads&quot; setting in Proof General. A<br/>speedup factor of 1.5--3.5 can be expected on a 4-core machine, and up<br/>to 6 on a 8-core machine.  User-code needs to observe certain<br/>guidelines for thread-safe programming, see appendix A in the Isar<br/>Implementation manual.<br/><br/><br/><br/>New in Isabelle2005 (October 2005)<br/>----------------------------------<br/><br/>*** General ***<br/><br/>* Theory headers: the new header syntax for Isar theories is<br/><br/>  theory &lt;name&gt;<br/>  imports &lt;theory1&gt; ... &lt;theoryN&gt;<br/>  uses &lt;file1&gt; ... &lt;fileM&gt;<br/>  begin<br/><br/>where the &#39;uses&#39; part is optional.  The previous syntax<br/><br/>  theory &lt;name&gt; = &lt;theory1&gt; + ... + &lt;theoryN&gt;:<br/><br/>will disappear in the next release.  Use isatool fixheaders to convert<br/>existing theory files.  Note that there is no change in ancient<br/>non-Isar theories now, but these will disappear soon.<br/><br/>* Theory loader: parent theories can now also be referred to via<br/>relative and absolute paths.<br/><br/>* Command &#39;find_theorems&#39; searches for a list of criteria instead of a<br/>list of constants. Known criteria are: intro, elim, dest, name:string,<br/>simp:term, and any term. Criteria can be preceded by &#39;-&#39; to select<br/>theorems that do not match. Intro, elim, dest select theorems that<br/>match the current goal, name:s selects theorems whose fully qualified<br/>name contain s, and simp:term selects all simplification rules whose<br/>lhs match term.  Any other term is interpreted as pattern and selects<br/>all theorems matching the pattern. Available in ProofGeneral under<br/>&#39;ProofGeneral -&gt; Find Theorems&#39; or C-c C-f.  Example:<br/><br/>  C-c C-f (100) &quot;(_::nat) + _ + _&quot; intro -name: &quot;HOL.&quot;<br/><br/>prints the last 100 theorems matching the pattern &quot;(_::nat) + _ + _&quot;,<br/>matching the current goal as introduction rule and not having &quot;HOL.&quot;<br/>in their name (i.e. not being defined in theory HOL).<br/><br/>* Command &#39;thms_containing&#39; has been discontinued in favour of<br/>&#39;find_theorems&#39;; INCOMPATIBILITY.<br/><br/>* Communication with Proof General is now 8bit clean, which means that<br/>Unicode text in UTF-8 encoding may be used within theory texts (both<br/>formal and informal parts).  Cf. option -U of the Isabelle Proof<br/>General interface.  Here are some simple examples (cf. src/HOL/ex):<br/><br/>  http://isabelle.in.tum.de/library/HOL/ex/Hebrew.html<br/>  http://isabelle.in.tum.de/library/HOL/ex/Chinese.html<br/><br/>* Improved efficiency of the Simplifier and, to a lesser degree, the<br/>Classical Reasoner.  Typical big applications run around 2 times<br/>faster.<br/><br/><br/>*** Document preparation ***<br/><br/>* Commands &#39;display_drafts&#39; and &#39;print_drafts&#39; perform simple output<br/>of raw sources.  Only those symbols that do not require additional<br/>LaTeX packages (depending on comments in isabellesym.sty) are<br/>displayed properly, everything else is left verbatim.  isatool display<br/>and isatool print are used as front ends (these are subject to the<br/>DVI/PDF_VIEWER and PRINT_COMMAND settings, respectively).<br/><br/>* Command tags control specific markup of certain regions of text,<br/>notably folding and hiding.  Predefined tags include &quot;theory&quot; (for<br/>theory begin and end), &quot;proof&quot; for proof commands, and &quot;ML&quot; for<br/>commands involving ML code; the additional tags &quot;visible&quot; and<br/>&quot;invisible&quot; are unused by default.  Users may give explicit tag<br/>specifications in the text, e.g. &#39;&#39;by %invisible (auto)&#39;&#39;.  The<br/>interpretation of tags is determined by the LaTeX job during document<br/>preparation: see option -V of isatool usedir, or options -n and -t of<br/>isatool document, or even the LaTeX macros \isakeeptag, \isafoldtag,<br/>\isadroptag.<br/><br/>Several document versions may be produced at the same time via isatool<br/>usedir (the generated index.html will link all of them).  Typical<br/>specifications include &#39;&#39;-V document=theory,proof,ML&#39;&#39; to present<br/>theory/proof/ML parts faithfully, &#39;&#39;-V outline=/proof,/ML&#39;&#39; to fold<br/>proof and ML commands, and &#39;&#39;-V mutilated=-theory,-proof,-ML&#39;&#39; to omit<br/>these parts without any formal replacement text.  The Isabelle site<br/>default settings produce &#39;&#39;document&#39;&#39; and &#39;&#39;outline&#39;&#39; versions as<br/>specified above.<br/><br/>* Several new antiquotations:<br/><br/>  @{term_type term} prints a term with its type annotated;<br/><br/>  @{typeof term} prints the type of a term;<br/><br/>  @{const const} is the same as @{term const}, but checks that the<br/>  argument is a known logical constant;<br/><br/>  @{term_style style term} and @{thm_style style thm} print a term or<br/>  theorem applying a &quot;style&quot; to it<br/><br/>  @{ML text}<br/><br/>Predefined styles are &#39;lhs&#39; and &#39;rhs&#39; printing the lhs/rhs of<br/>definitions, equations, inequations etc., &#39;concl&#39; printing only the<br/>conclusion of a meta-logical statement theorem, and &#39;prem1&#39; .. &#39;prem19&#39;<br/>to print the specified premise.  TermStyle.add_style provides an ML<br/>interface for introducing further styles.  See also the &quot;LaTeX Sugar&quot;<br/>document practical applications.  The ML antiquotation prints<br/>type-checked ML expressions verbatim.<br/><br/>* Markup commands &#39;chapter&#39;, &#39;section&#39;, &#39;subsection&#39;, &#39;subsubsection&#39;,<br/>and &#39;text&#39; support optional locale specification &#39;(in loc)&#39;, which<br/>specifies the default context for interpreting antiquotations.  For<br/>example: &#39;text (in lattice) {* @{thm inf_assoc}*}&#39;.<br/><br/>* Option &#39;locale=NAME&#39; of antiquotations specifies an alternative<br/>context interpreting the subsequent argument.  For example: @{thm<br/>[locale=lattice] inf_assoc}.<br/><br/>* Proper output of proof terms (@{prf ...} and @{full_prf ...}) within<br/>a proof context.<br/><br/>* Proper output of antiquotations for theory commands involving a<br/>proof context (such as &#39;locale&#39; or &#39;theorem (in loc) ...&#39;).<br/><br/>* Delimiters of outer tokens (string etc.) now produce separate LaTeX<br/>macros (\isachardoublequoteopen, isachardoublequoteclose etc.).<br/><br/>* isatool usedir: new option -C (default true) controls whether option<br/>-D should include a copy of the original document directory; -C false<br/>prevents unwanted effects such as copying of administrative CVS data.<br/><br/><br/>*** Pure ***<br/><br/>* Considerably improved version of &#39;constdefs&#39; command.  Now performs<br/>automatic type-inference of declared constants; additional support for<br/>local structure declarations (cf. locales and HOL records), see also<br/>isar-ref manual.  Potential INCOMPATIBILITY: need to observe strictly<br/>sequential dependencies of definitions within a single &#39;constdefs&#39;<br/>section; moreover, the declared name needs to be an identifier.  If<br/>all fails, consider to fall back on &#39;consts&#39; and &#39;defs&#39; separately.<br/><br/>* Improved indexed syntax and implicit structures.  First of all,<br/>indexed syntax provides a notational device for subscripted<br/>application, using the new syntax ⇘term⇙ for arbitrary<br/>expressions.  Secondly, in a local context with structure<br/>declarations, number indexes <sub>n</sub> or the empty index (default<br/>number 1) refer to a certain fixed variable implicitly; option<br/>show_structs controls printing of implicit structures.  Typical<br/>applications of these concepts involve record types and locales.<br/><br/>* New command &#39;no_syntax&#39; removes grammar declarations (and<br/>translations) resulting from the given syntax specification, which is<br/>interpreted in the same manner as for the &#39;syntax&#39; command.<br/><br/>* &#39;Advanced&#39; translation functions (parse_translation etc.) may depend<br/>on the signature of the theory context being presently used for<br/>parsing/printing, see also isar-ref manual.<br/><br/>* Improved &#39;oracle&#39; command provides a type-safe interface to turn an<br/>ML expression of type theory -&gt; T -&gt; term into a primitive rule of<br/>type theory -&gt; T -&gt; thm (i.e. the functionality of Thm.invoke_oracle<br/>is already included here); see also FOL/ex/IffExample.thy;<br/>INCOMPATIBILITY.<br/><br/>* axclass: name space prefix for class &quot;c&quot; is now &quot;c_class&quot; (was &quot;c&quot;<br/>before); &quot;cI&quot; is no longer bound, use &quot;c.intro&quot; instead.<br/>INCOMPATIBILITY.  This change avoids clashes of fact bindings for<br/>axclasses vs. locales.<br/><br/>* Improved internal renaming of symbolic identifiers -- attach primes<br/>instead of base 26 numbers.<br/><br/>* New flag show_question_marks controls printing of leading question<br/>marks in schematic variable names.<br/><br/>* In schematic variable names, *any* symbol following \&lt;^isub&gt; or<br/>\&lt;^isup&gt; is now treated as part of the base name.  For example, the<br/>following works without printing of awkward &quot;.0&quot; indexes:<br/><br/>  lemma &quot;x\&lt;^isub&gt;1 = x\&lt;^isub&gt;2 ==&gt; x\&lt;^isub&gt;2 = x\&lt;^isub&gt;1&quot;<br/>    by simp<br/><br/>* Inner syntax includes (*(*nested*) comments*).<br/><br/>* Pretty printer now supports unbreakable blocks, specified in mixfix<br/>annotations as &quot;(00...)&quot;.<br/><br/>* Clear separation of logical types and nonterminals, where the latter<br/>may only occur in &#39;syntax&#39; specifications or type abbreviations.<br/>Before that distinction was only partially implemented via type class<br/>&quot;logic&quot; vs. &quot;{}&quot;.  Potential INCOMPATIBILITY in rare cases of improper<br/>use of &#39;types&#39;/&#39;consts&#39; instead of &#39;nonterminals&#39;/&#39;syntax&#39;.  Some very<br/>exotic syntax specifications may require further adaption<br/>(e.g. Cube/Cube.thy).<br/><br/>* Removed obsolete type class &quot;logic&quot;, use the top sort {} instead.<br/>Note that non-logical types should be declared as &#39;nonterminals&#39;<br/>rather than &#39;types&#39;.  INCOMPATIBILITY for new object-logic<br/>specifications.<br/><br/>* Attributes &#39;induct&#39; and &#39;cases&#39;: type or set names may now be<br/>locally fixed variables as well.<br/><br/>* Simplifier: can now control the depth to which conditional rewriting<br/>is traced via the PG menu Isabelle -&gt; Settings -&gt; Trace Simp Depth<br/>Limit.<br/><br/>* Simplifier: simplification procedures may now take the current<br/>simpset into account (cf. Simplifier.simproc(_i) / mk_simproc<br/>interface), which is very useful for calling the Simplifier<br/>recursively.  Minor INCOMPATIBILITY: the &#39;prems&#39; argument of simprocs<br/>is gone -- use prems_of_ss on the simpset instead.  Moreover, the<br/>low-level mk_simproc no longer applies Logic.varify internally, to<br/>allow for use in a context of fixed variables.<br/><br/>* thin_tac now works even if the assumption being deleted contains !!<br/>or ==&gt;.  More generally, erule now works even if the major premise of<br/>the elimination rule contains !! or ==&gt;.<br/><br/>* Method &#39;rules&#39; has been renamed to &#39;iprover&#39;. INCOMPATIBILITY.<br/><br/>* Reorganized bootstrapping of the Pure theories; CPure is now derived<br/>from Pure, which contains all common declarations already.  Both<br/>theories are defined via plain Isabelle/Isar .thy files.<br/>INCOMPATIBILITY: elements of CPure (such as the CPure.intro /<br/>CPure.elim / CPure.dest attributes) now appear in the Pure name space;<br/>use isatool fixcpure to adapt your theory and ML sources.<br/><br/>* New syntax &#39;name(i-j, i-, i, ...)&#39; for referring to specific<br/>selections of theorems in named facts via index ranges.<br/><br/>* &#39;print_theorems&#39;: in theory mode, really print the difference<br/>wrt. the last state (works for interactive theory development only),<br/>in proof mode print all local facts (cf. &#39;print_facts&#39;);<br/><br/>* &#39;hide&#39;: option &#39;(open)&#39; hides only base names.<br/><br/>* More efficient treatment of intermediate checkpoints in interactive<br/>theory development.<br/><br/>* Code generator is now invoked via code_module (incremental code<br/>generation) and code_library (modular code generation, ML structures<br/>for each theory).  INCOMPATIBILITY: new keywords &#39;file&#39; and &#39;contains&#39;<br/>must be quoted when used as identifiers.<br/><br/>* New &#39;value&#39; command for reading, evaluating and printing terms using<br/>the code generator.  INCOMPATIBILITY: command keyword &#39;value&#39; must be<br/>quoted when used as identifier.<br/><br/><br/>*** Locales ***<br/><br/>* New commands for the interpretation of locale expressions in<br/>theories (1), locales (2) and proof contexts (3).  These generate<br/>proof obligations from the expression specification.  After the<br/>obligations have been discharged, theorems of the expression are added<br/>to the theory, target locale or proof context.  The synopsis of the<br/>commands is a follows:<br/><br/>  (1) interpretation expr inst<br/>  (2) interpretation target &lt; expr<br/>  (3) interpret expr inst<br/><br/>Interpretation in theories and proof contexts require a parameter<br/>instantiation of terms from the current context.  This is applied to<br/>specifications and theorems of the interpreted expression.<br/>Interpretation in locales only permits parameter renaming through the<br/>locale expression.  Interpretation is smart in that interpretations<br/>that are active already do not occur in proof obligations, neither are<br/>instantiated theorems stored in duplicate.  Use &#39;print_interps&#39; to<br/>inspect active interpretations of a particular locale.  For details,<br/>see the Isar Reference manual.  Examples can be found in<br/>HOL/Finite_Set.thy and HOL/Algebra/UnivPoly.thy.<br/><br/>INCOMPATIBILITY: former &#39;instantiate&#39; has been withdrawn, use<br/>&#39;interpret&#39; instead.<br/><br/>* New context element &#39;constrains&#39; for adding type constraints to<br/>parameters.<br/><br/>* Context expressions: renaming of parameters with syntax<br/>redeclaration.<br/><br/>* Locale declaration: &#39;includes&#39; disallowed.<br/><br/>* Proper static binding of attribute syntax -- i.e. types / terms /<br/>facts mentioned as arguments are always those of the locale definition<br/>context, independently of the context of later invocations.  Moreover,<br/>locale operations (renaming and type / term instantiation) are applied<br/>to attribute arguments as expected.<br/><br/>INCOMPATIBILITY of the ML interface: always pass Attrib.src instead of<br/>actual attributes; rare situations may require Attrib.attribute to<br/>embed those attributes into Attrib.src that lack concrete syntax.<br/>Attribute implementations need to cooperate properly with the static<br/>binding mechanism.  Basic parsers Args.XXX_typ/term/prop and<br/>Attrib.XXX_thm etc. already do the right thing without further<br/>intervention.  Only unusual applications -- such as &quot;where&quot; or &quot;of&quot;<br/>(cf. src/Pure/Isar/attrib.ML), which process arguments depending both<br/>on the context and the facts involved -- may have to assign parsed<br/>values to argument tokens explicitly.<br/><br/>* Changed parameter management in theorem generation for long goal<br/>statements with &#39;includes&#39;.  INCOMPATIBILITY: produces a different<br/>theorem statement in rare situations.<br/><br/>* Locale inspection command &#39;print_locale&#39; omits notes elements.  Use<br/>&#39;print_locale!&#39; to have them included in the output.<br/><br/><br/>*** Provers ***<br/><br/>* Provers/hypsubst.ML: improved version of the subst method, for<br/>single-step rewriting: it now works in bound variable contexts. New is<br/>&#39;subst (asm)&#39;, for rewriting an assumption.  INCOMPATIBILITY: may<br/>rewrite a different subterm than the original subst method, which is<br/>still available as &#39;simplesubst&#39;.<br/><br/>* Provers/quasi.ML: new transitivity reasoners for transitivity only<br/>and quasi orders.<br/><br/>* Provers/trancl.ML: new transitivity reasoner for transitive and<br/>reflexive-transitive closure of relations.<br/><br/>* Provers/blast.ML: new reference depth_limit to make blast&#39;s depth<br/>limit (previously hard-coded with a value of 20) user-definable.<br/><br/>* Provers/simplifier.ML has been moved to Pure, where Simplifier.setup<br/>is peformed already.  Object-logics merely need to finish their<br/>initial simpset configuration as before.  INCOMPATIBILITY.<br/><br/><br/>*** HOL ***<br/><br/>* Symbolic syntax of Hilbert Choice Operator is now as follows:<br/><br/>  syntax (epsilon)<br/>    &quot;_Eps&quot; :: &quot;[pttrn, bool] =&gt; &#39;a&quot;    (&quot;(3ϵ_./ _)&quot; [0, 10] 10)<br/><br/>The symbol ϵ is displayed as the alternative epsilon of LaTeX<br/>and x-symbol; use option &#39;-m epsilon&#39; to get it actually printed.<br/>Moreover, the mathematically important symbolic identifier ε<br/>becomes available as variable, constant etc.  INCOMPATIBILITY,<br/><br/>* &quot;x &gt; y&quot; abbreviates &quot;y &lt; x&quot; and &quot;x &gt;= y&quot; abbreviates &quot;y &lt;= x&quot;.<br/>Similarly for all quantifiers: &quot;ALL x &gt; y&quot; etc.  The x-symbol for &gt;=<br/>is ≥. New transitivity rules have been added to HOL/Orderings.thy to<br/>support corresponding Isar calculations.<br/><br/>* &quot;{x:A. P}&quot; abbreviates &quot;{x. x:A &amp; P}&quot;, and similarly for &quot;∈&quot;<br/>instead of &quot;:&quot;.<br/><br/>* theory SetInterval: changed the syntax for open intervals:<br/><br/>  Old       New<br/>  {..n(}    {..&lt;n}<br/>  {)n..}    {n&lt;..}<br/>  {m..n(}   {m..&lt;n}<br/>  {)m..n}   {m&lt;..n}<br/>  {)m..n(}  {m&lt;..&lt;n}<br/><br/>The old syntax is still supported but will disappear in the next<br/>release.  For conversion use the following Emacs search and replace<br/>patterns (these are not perfect but work quite well):<br/><br/>  {)\([^\.]*\)\.\.  -&gt;  {\1&lt;\.\.}<br/>  \.\.\([^(}]*\)(}  -&gt;  \.\.&lt;\1}<br/><br/>* Theory Commutative_Ring (in Library): method comm_ring for proving<br/>equalities in commutative rings; method &#39;algebra&#39; provides a generic<br/>interface.<br/><br/>* Theory Finite_Set: changed the syntax for &#39;setsum&#39;, summation over<br/>finite sets: &quot;setsum (%x. e) A&quot;, which used to be &quot;∑x:A. e&quot;, is<br/>now either &quot;SUM x:A. e&quot; or &quot;∑x ∈ A. e&quot;. The bound variable can<br/>be a tuple pattern.<br/><br/>Some new syntax forms are available:<br/><br/>  &quot;∑x | P. e&quot;      for     &quot;setsum (%x. e) {x. P}&quot;<br/>  &quot;∑x = a..b. e&quot;   for     &quot;setsum (%x. e) {a..b}&quot;<br/>  &quot;∑x = a..&lt;b. e&quot;  for     &quot;setsum (%x. e) {a..&lt;b}&quot;<br/>  &quot;∑x &lt; k. e&quot;      for     &quot;setsum (%x. e) {..&lt;k}&quot;<br/><br/>The latter form &quot;∑x &lt; k. e&quot; used to be based on a separate<br/>function &quot;Summation&quot;, which has been discontinued.<br/><br/>* theory Finite_Set: in structured induction proofs, the insert case<br/>is now &#39;case (insert x F)&#39; instead of the old counterintuitive &#39;case<br/>(insert F x)&#39;.<br/><br/>* The &#39;refute&#39; command has been extended to support a much larger<br/>fragment of HOL, including axiomatic type classes, constdefs and<br/>typedefs, inductive datatypes and recursion.<br/><br/>* New tactics &#39;sat&#39; and &#39;satx&#39; to prove propositional tautologies.<br/>Requires zChaff with proof generation to be installed.  See<br/>HOL/ex/SAT_Examples.thy for examples.<br/><br/>* Datatype induction via method &#39;induct&#39; now preserves the name of the<br/>induction variable. For example, when proving P(xs::&#39;a list) by<br/>induction on xs, the induction step is now P(xs) ==&gt; P(a#xs) rather<br/>than P(list) ==&gt; P(a#list) as previously.  Potential INCOMPATIBILITY<br/>in unstructured proof scripts.<br/><br/>* Reworked implementation of records.  Improved scalability for<br/>records with many fields, avoiding performance problems for type<br/>inference. Records are no longer composed of nested field types, but<br/>of nested extension types. Therefore the record type only grows linear<br/>in the number of extensions and not in the number of fields.  The<br/>top-level (users) view on records is preserved.  Potential<br/>INCOMPATIBILITY only in strange cases, where the theory depends on the<br/>old record representation. The type generated for a record is called<br/>&lt;record_name&gt;_ext_type.<br/><br/>Flag record_quick_and_dirty_sensitive can be enabled to skip the<br/>proofs triggered by a record definition or a simproc (if<br/>quick_and_dirty is enabled).  Definitions of large records can take<br/>quite long.<br/><br/>New simproc record_upd_simproc for simplification of multiple record<br/>updates enabled by default.  Moreover, trivial updates are also<br/>removed: r(|x := x r|) = r.  INCOMPATIBILITY: old proofs break<br/>occasionally, since simplification is more powerful by default.<br/><br/>* typedef: proper support for polymorphic sets, which contain extra<br/>type-variables in the term.<br/><br/>* Simplifier: automatically reasons about transitivity chains<br/>involving &quot;trancl&quot; (r^+) and &quot;rtrancl&quot; (r^*) by setting up tactics<br/>provided by Provers/trancl.ML as additional solvers.  INCOMPATIBILITY:<br/>old proofs break occasionally as simplification may now solve more<br/>goals than previously.<br/><br/>* Simplifier: converts x &lt;= y into x = y if assumption y &lt;= x is<br/>present.  Works for all partial orders (class &quot;order&quot;), in particular<br/>numbers and sets.  For linear orders (e.g. numbers) it treats ~ x &lt; y<br/>just like y &lt;= x.<br/><br/>* Simplifier: new simproc for &quot;let x = a in f x&quot;.  If a is a free or<br/>bound variable or a constant then the let is unfolded.  Otherwise<br/>first a is simplified to b, and then f b is simplified to g. If<br/>possible we abstract b from g arriving at &quot;let x = b in h x&quot;,<br/>otherwise we unfold the let and arrive at g.  The simproc can be<br/>enabled/disabled by the reference use_let_simproc.  Potential<br/>INCOMPATIBILITY since simplification is more powerful by default.<br/><br/>* Classical reasoning: the meson method now accepts theorems as arguments.<br/><br/>* Prover support: pre-release of the Isabelle-ATP linkup, which runs background<br/>jobs to provide advice on the provability of subgoals.<br/><br/>* Theory OrderedGroup and Ring_and_Field: various additions and<br/>improvements to faciliate calculations involving equalities and<br/>inequalities.<br/><br/>The following theorems have been eliminated or modified<br/>(INCOMPATIBILITY):<br/><br/>  abs_eq             now named abs_of_nonneg<br/>  abs_of_ge_0        now named abs_of_nonneg<br/>  abs_minus_eq       now named abs_of_nonpos<br/>  imp_abs_id         now named abs_of_nonneg<br/>  imp_abs_neg_id     now named abs_of_nonpos<br/>  mult_pos           now named mult_pos_pos<br/>  mult_pos_le        now named mult_nonneg_nonneg<br/>  mult_pos_neg_le    now named mult_nonneg_nonpos<br/>  mult_pos_neg2_le   now named mult_nonneg_nonpos2<br/>  mult_neg           now named mult_neg_neg<br/>  mult_neg_le        now named mult_nonpos_nonpos<br/><br/>* The following lemmas in Ring_and_Field have been added to the simplifier:<br/><br/>     zero_le_square<br/>     not_square_less_zero<br/><br/>  The following lemmas have been deleted from Real/RealPow:<br/><br/>     realpow_zero_zero<br/>     realpow_two<br/>     realpow_less<br/>     zero_le_power<br/>     realpow_two_le<br/>     abs_realpow_two<br/>     realpow_two_abs<br/><br/>* Theory Parity: added rules for simplifying exponents.<br/><br/>* Theory List:<br/><br/>The following theorems have been eliminated or modified<br/>(INCOMPATIBILITY):<br/><br/>  list_all_Nil       now named list_all.simps(1)<br/>  list_all_Cons      now named list_all.simps(2)<br/>  list_all_conv      now named list_all_iff<br/>  set_mem_eq         now named mem_iff<br/><br/>* Theories SetsAndFunctions and BigO (see HOL/Library) support<br/>asymptotic &quot;big O&quot; calculations.  See the notes in BigO.thy.<br/><br/><br/>*** HOL-Complex ***<br/><br/>* Theory RealDef: better support for embedding natural numbers and<br/>integers in the reals.<br/><br/>The following theorems have been eliminated or modified<br/>(INCOMPATIBILITY):<br/><br/>  exp_ge_add_one_self  now requires no hypotheses<br/>  real_of_int_add      reversed direction of equality (use [symmetric])<br/>  real_of_int_minus    reversed direction of equality (use [symmetric])<br/>  real_of_int_diff     reversed direction of equality (use [symmetric])<br/>  real_of_int_mult     reversed direction of equality (use [symmetric])<br/><br/>* Theory RComplete: expanded support for floor and ceiling functions.<br/><br/>* Theory Ln is new, with properties of the natural logarithm<br/><br/>* Hyperreal: There is a new type constructor &quot;star&quot; for making<br/>nonstandard types.  The old type names are now type synonyms:<br/><br/>  hypreal = real star<br/>  hypnat = nat star<br/>  hcomplex = complex star<br/><br/>* Hyperreal: Many groups of similarly-defined constants have been<br/>replaced by polymorphic versions (INCOMPATIBILITY):<br/><br/>  star_of &lt;-- hypreal_of_real, hypnat_of_nat, hcomplex_of_complex<br/><br/>  starset      &lt;-- starsetNat, starsetC<br/>  *s*          &lt;-- *sNat*, *sc*<br/>  starset_n    &lt;-- starsetNat_n, starsetC_n<br/>  *sn*         &lt;-- *sNatn*, *scn*<br/>  InternalSets &lt;-- InternalNatSets, InternalCSets<br/><br/>  starfun      &lt;-- starfun{Nat,Nat2,C,RC,CR}<br/>  *f*          &lt;-- *fNat*, *fNat2*, *fc*, *fRc*, *fcR*<br/>  starfun_n    &lt;-- starfun{Nat,Nat2,C,RC,CR}_n<br/>  *fn*         &lt;-- *fNatn*, *fNat2n*, *fcn*, *fRcn*, *fcRn*<br/>  InternalFuns &lt;-- InternalNatFuns, InternalNatFuns2, Internal{C,RC,CR}Funs<br/><br/>* Hyperreal: Many type-specific theorems have been removed in favor of<br/>theorems specific to various axiomatic type classes (INCOMPATIBILITY):<br/><br/>  add_commute &lt;-- {hypreal,hypnat,hcomplex}_add_commute<br/>  add_assoc   &lt;-- {hypreal,hypnat,hcomplex}_add_assocs<br/>  OrderedGroup.add_0 &lt;-- {hypreal,hypnat,hcomplex}_add_zero_left<br/>  OrderedGroup.add_0_right &lt;-- {hypreal,hcomplex}_add_zero_right<br/>  right_minus &lt;-- hypreal_add_minus<br/>  left_minus &lt;-- {hypreal,hcomplex}_add_minus_left<br/>  mult_commute &lt;-- {hypreal,hypnat,hcomplex}_mult_commute<br/>  mult_assoc &lt;-- {hypreal,hypnat,hcomplex}_mult_assoc<br/>  mult_1_left &lt;-- {hypreal,hypnat}_mult_1, hcomplex_mult_one_left<br/>  mult_1_right &lt;-- hcomplex_mult_one_right<br/>  mult_zero_left &lt;-- hcomplex_mult_zero_left<br/>  left_distrib &lt;-- {hypreal,hypnat,hcomplex}_add_mult_distrib<br/>  right_distrib &lt;-- hypnat_add_mult_distrib2<br/>  zero_neq_one &lt;-- {hypreal,hypnat,hcomplex}_zero_not_eq_one<br/>  right_inverse &lt;-- hypreal_mult_inverse<br/>  left_inverse &lt;-- hypreal_mult_inverse_left, hcomplex_mult_inv_left<br/>  order_refl &lt;-- {hypreal,hypnat}_le_refl<br/>  order_trans &lt;-- {hypreal,hypnat}_le_trans<br/>  order_antisym &lt;-- {hypreal,hypnat}_le_anti_sym<br/>  order_less_le &lt;-- {hypreal,hypnat}_less_le<br/>  linorder_linear &lt;-- {hypreal,hypnat}_le_linear<br/>  add_left_mono &lt;-- {hypreal,hypnat}_add_left_mono<br/>  mult_strict_left_mono &lt;-- {hypreal,hypnat}_mult_less_mono2<br/>  add_nonneg_nonneg &lt;-- hypreal_le_add_order<br/><br/>* Hyperreal: Separate theorems having to do with type-specific<br/>versions of constants have been merged into theorems that apply to the<br/>new polymorphic constants (INCOMPATIBILITY):<br/><br/>  STAR_UNIV_set &lt;-- {STAR_real,NatStar_real,STARC_complex}_set<br/>  STAR_empty_set &lt;-- {STAR,NatStar,STARC}_empty_set<br/>  STAR_Un &lt;-- {STAR,NatStar,STARC}_Un<br/>  STAR_Int &lt;-- {STAR,NatStar,STARC}_Int<br/>  STAR_Compl &lt;-- {STAR,NatStar,STARC}_Compl<br/>  STAR_subset &lt;-- {STAR,NatStar,STARC}_subset<br/>  STAR_mem &lt;-- {STAR,NatStar,STARC}_mem<br/>  STAR_mem_Compl &lt;-- {STAR,STARC}_mem_Compl<br/>  STAR_diff &lt;-- {STAR,STARC}_diff<br/>  STAR_star_of_image_subset &lt;-- {STAR_hypreal_of_real, NatStar_hypreal_of_real,<br/>    STARC_hcomplex_of_complex}_image_subset<br/>  starset_n_Un &lt;-- starset{Nat,C}_n_Un<br/>  starset_n_Int &lt;-- starset{Nat,C}_n_Int<br/>  starset_n_Compl &lt;-- starset{Nat,C}_n_Compl<br/>  starset_n_diff &lt;-- starset{Nat,C}_n_diff<br/>  InternalSets_Un &lt;-- Internal{Nat,C}Sets_Un<br/>  InternalSets_Int &lt;-- Internal{Nat,C}Sets_Int<br/>  InternalSets_Compl &lt;-- Internal{Nat,C}Sets_Compl<br/>  InternalSets_diff &lt;-- Internal{Nat,C}Sets_diff<br/>  InternalSets_UNIV_diff &lt;-- Internal{Nat,C}Sets_UNIV_diff<br/>  InternalSets_starset_n &lt;-- Internal{Nat,C}Sets_starset{Nat,C}_n<br/>  starset_starset_n_eq &lt;-- starset{Nat,C}_starset{Nat,C}_n_eq<br/>  starset_n_starset &lt;-- starset{Nat,C}_n_starset{Nat,C}<br/>  starfun_n_starfun &lt;-- starfun{Nat,Nat2,C,RC,CR}_n_starfun{Nat,Nat2,C,RC,CR}<br/>  starfun &lt;-- starfun{Nat,Nat2,C,RC,CR}<br/>  starfun_mult &lt;-- starfun{Nat,Nat2,C,RC,CR}_mult<br/>  starfun_add &lt;-- starfun{Nat,Nat2,C,RC,CR}_add<br/>  starfun_minus &lt;-- starfun{Nat,Nat2,C,RC,CR}_minus<br/>  starfun_diff &lt;-- starfun{C,RC,CR}_diff<br/>  starfun_o &lt;-- starfun{NatNat2,Nat2,_stafunNat,C,C_starfunRC,_starfunCR}_o<br/>  starfun_o2 &lt;-- starfun{NatNat2,_stafunNat,C,C_starfunRC,_starfunCR}_o2<br/>  starfun_const_fun &lt;-- starfun{Nat,Nat2,C,RC,CR}_const_fun<br/>  starfun_inverse &lt;-- starfun{Nat,C,RC,CR}_inverse<br/>  starfun_eq &lt;-- starfun{Nat,Nat2,C,RC,CR}_eq<br/>  starfun_eq_iff &lt;-- starfun{C,RC,CR}_eq_iff<br/>  starfun_Id &lt;-- starfunC_Id<br/>  starfun_approx &lt;-- starfun{Nat,CR}_approx<br/>  starfun_capprox &lt;-- starfun{C,RC}_capprox<br/>  starfun_abs &lt;-- starfunNat_rabs<br/>  starfun_lambda_cancel &lt;-- starfun{C,CR,RC}_lambda_cancel<br/>  starfun_lambda_cancel2 &lt;-- starfun{C,CR,RC}_lambda_cancel2<br/>  starfun_mult_HFinite_approx &lt;-- starfunCR_mult_HFinite_capprox<br/>  starfun_mult_CFinite_capprox &lt;-- starfun{C,RC}_mult_CFinite_capprox<br/>  starfun_add_capprox &lt;-- starfun{C,RC}_add_capprox<br/>  starfun_add_approx &lt;-- starfunCR_add_approx<br/>  starfun_inverse_inverse &lt;-- starfunC_inverse_inverse<br/>  starfun_divide &lt;-- starfun{C,CR,RC}_divide<br/>  starfun_n &lt;-- starfun{Nat,C}_n<br/>  starfun_n_mult &lt;-- starfun{Nat,C}_n_mult<br/>  starfun_n_add &lt;-- starfun{Nat,C}_n_add<br/>  starfun_n_add_minus &lt;-- starfunNat_n_add_minus<br/>  starfun_n_const_fun &lt;-- starfun{Nat,C}_n_const_fun<br/>  starfun_n_minus &lt;-- starfun{Nat,C}_n_minus<br/>  starfun_n_eq &lt;-- starfun{Nat,C}_n_eq<br/><br/>  star_n_add &lt;-- {hypreal,hypnat,hcomplex}_add<br/>  star_n_minus &lt;-- {hypreal,hcomplex}_minus<br/>  star_n_diff &lt;-- {hypreal,hcomplex}_diff<br/>  star_n_mult &lt;-- {hypreal,hcomplex}_mult<br/>  star_n_inverse &lt;-- {hypreal,hcomplex}_inverse<br/>  star_n_le &lt;-- {hypreal,hypnat}_le<br/>  star_n_less &lt;-- {hypreal,hypnat}_less<br/>  star_n_zero_num &lt;-- {hypreal,hypnat,hcomplex}_zero_num<br/>  star_n_one_num &lt;-- {hypreal,hypnat,hcomplex}_one_num<br/>  star_n_abs &lt;-- hypreal_hrabs<br/>  star_n_divide &lt;-- hcomplex_divide<br/><br/>  star_of_add &lt;-- {hypreal_of_real,hypnat_of_nat,hcomplex_of_complex}_add<br/>  star_of_minus &lt;-- {hypreal_of_real,hcomplex_of_complex}_minus<br/>  star_of_diff &lt;-- hypreal_of_real_diff<br/>  star_of_mult &lt;-- {hypreal_of_real,hypnat_of_nat,hcomplex_of_complex}_mult<br/>  star_of_one &lt;-- {hypreal_of_real,hcomplex_of_complex}_one<br/>  star_of_zero &lt;-- {hypreal_of_real,hypnat_of_nat,hcomplex_of_complex}_zero<br/>  star_of_le &lt;-- {hypreal_of_real,hypnat_of_nat}_le_iff<br/>  star_of_less &lt;-- {hypreal_of_real,hypnat_of_nat}_less_iff<br/>  star_of_eq &lt;-- {hypreal_of_real,hypnat_of_nat,hcomplex_of_complex}_eq_iff<br/>  star_of_inverse &lt;-- {hypreal_of_real,hcomplex_of_complex}_inverse<br/>  star_of_divide &lt;-- {hypreal_of_real,hcomplex_of_complex}_divide<br/>  star_of_of_nat &lt;-- {hypreal_of_real,hcomplex_of_complex}_of_nat<br/>  star_of_of_int &lt;-- {hypreal_of_real,hcomplex_of_complex}_of_int<br/>  star_of_number_of &lt;-- {hypreal,hcomplex}_number_of<br/>  star_of_number_less &lt;-- number_of_less_hypreal_of_real_iff<br/>  star_of_number_le &lt;-- number_of_le_hypreal_of_real_iff<br/>  star_of_eq_number &lt;-- hypreal_of_real_eq_number_of_iff<br/>  star_of_less_number &lt;-- hypreal_of_real_less_number_of_iff<br/>  star_of_le_number &lt;-- hypreal_of_real_le_number_of_iff<br/>  star_of_power &lt;-- hypreal_of_real_power<br/>  star_of_eq_0 &lt;-- hcomplex_of_complex_zero_iff<br/><br/>* Hyperreal: new method &quot;transfer&quot; that implements the transfer<br/>principle of nonstandard analysis. With a subgoal that mentions<br/>nonstandard types like &quot;&#39;a star&quot;, the command &quot;apply transfer&quot;<br/>replaces it with an equivalent one that mentions only standard types.<br/>To be successful, all free variables must have standard types; non-<br/>standard variables must have explicit universal quantifiers.<br/><br/>* Hyperreal: A theory of Taylor series.<br/><br/><br/>*** HOLCF ***<br/><br/>* Discontinued special version of &#39;constdefs&#39; (which used to support<br/>continuous functions) in favor of the general Pure one with full<br/>type-inference.<br/><br/>* New simplification procedure for solving continuity conditions; it<br/>is much faster on terms with many nested lambda abstractions (cubic<br/>instead of exponential time).<br/><br/>* New syntax for domain package: selector names are now optional.<br/>Parentheses should be omitted unless argument is lazy, for example:<br/><br/>  domain &#39;a stream = cons &quot;&#39;a&quot; (lazy &quot;&#39;a stream&quot;)<br/><br/>* New command &#39;fixrec&#39; for defining recursive functions with pattern<br/>matching; defining multiple functions with mutual recursion is also<br/>supported.  Patterns may include the constants cpair, spair, up, sinl,<br/>sinr, or any data constructor defined by the domain package. The given<br/>equations are proven as rewrite rules. See HOLCF/ex/Fixrec_ex.thy for<br/>syntax and examples.<br/><br/>* New commands &#39;cpodef&#39; and &#39;pcpodef&#39; for defining predicate subtypes<br/>of cpo and pcpo types. Syntax is exactly like the &#39;typedef&#39; command,<br/>but the proof obligation additionally includes an admissibility<br/>requirement. The packages generate instances of class cpo or pcpo,<br/>with continuity and strictness theorems for Rep and Abs.<br/><br/>* HOLCF: Many theorems have been renamed according to a more standard naming<br/>scheme (INCOMPATIBILITY):<br/><br/>  foo_inject:  &quot;foo$x = foo$y ==&gt; x = y&quot;<br/>  foo_eq:      &quot;(foo$x = foo$y) = (x = y)&quot;<br/>  foo_less:    &quot;(foo$x &lt;&lt; foo$y) = (x &lt;&lt; y)&quot;<br/>  foo_strict:  &quot;foo$UU = UU&quot;<br/>  foo_defined: &quot;... ==&gt; foo$x ~= UU&quot;<br/>  foo_defined_iff: &quot;(foo$x = UU) = (x = UU)&quot;<br/><br/><br/>*** ZF ***<br/><br/>* ZF/ex: theories Group and Ring provide examples in abstract algebra,<br/>including the First Isomorphism Theorem (on quotienting by the kernel<br/>of a homomorphism).<br/><br/>* ZF/Simplifier: install second copy of type solver that actually<br/>makes use of TC rules declared to Isar proof contexts (or locales);<br/>the old version is still required for ML proof scripts.<br/><br/><br/>*** Cube ***<br/><br/>* Converted to Isar theory format; use locales instead of axiomatic<br/>theories.<br/><br/><br/>*** ML ***<br/><br/>* Pure/library.ML: added ##&gt;, ##&gt;&gt;, #&gt;&gt; -- higher-order counterparts<br/>for ||&gt;, ||&gt;&gt;, |&gt;&gt;,<br/><br/>* Pure/library.ML no longer defines its own option datatype, but uses<br/>that of the SML basis, which has constructors NONE and SOME instead of<br/>None and Some, as well as exception Option.Option instead of OPTION.<br/>The functions the, if_none, is_some, is_none have been adapted<br/>accordingly, while Option.map replaces apsome.<br/><br/>* Pure/library.ML: the exception LIST has been given up in favour of<br/>the standard exceptions Empty and Subscript, as well as<br/>Library.UnequalLengths.  Function like Library.hd and Library.tl are<br/>superceded by the standard hd and tl functions etc.<br/><br/>A number of basic list functions are no longer exported to the ML<br/>toplevel, as they are variants of predefined functions.  The following<br/>suggests how one can translate existing code:<br/><br/>    rev_append xs ys = List.revAppend (xs, ys)<br/>    nth_elem (i, xs) = List.nth (xs, i)<br/>    last_elem xs = List.last xs<br/>    flat xss = List.concat xss<br/>    seq fs = List.app fs<br/>    partition P xs = List.partition P xs<br/>    mapfilter f xs = List.mapPartial f xs<br/><br/>* Pure/library.ML: several combinators for linear functional<br/>transformations, notably reverse application and composition:<br/><br/>  x |&gt; f                f #&gt; g<br/>  (x, y) |-&gt; f          f #-&gt; g<br/><br/>* Pure/library.ML: introduced/changed precedence of infix operators:<br/><br/>  infix 1 |&gt; |-&gt; ||&gt; ||&gt;&gt; |&gt;&gt; |&gt;&gt;&gt; #&gt; #-&gt;;<br/>  infix 2 ?;<br/>  infix 3 o oo ooo oooo;<br/>  infix 4 ~~ upto downto;<br/><br/>Maybe INCOMPATIBILITY when any of those is used in conjunction with other<br/>infix operators.<br/><br/>* Pure/library.ML: natural list combinators fold, fold_rev, and<br/>fold_map support linear functional transformations and nesting.  For<br/>example:<br/><br/>  fold f [x1, ..., xN] y =<br/>    y |&gt; f x1 |&gt; ... |&gt; f xN<br/><br/>  (fold o fold) f [xs1, ..., xsN] y =<br/>    y |&gt; fold f xs1 |&gt; ... |&gt; fold f xsN<br/><br/>  fold f [x1, ..., xN] =<br/>    f x1 #&gt; ... #&gt; f xN<br/><br/>  (fold o fold) f [xs1, ..., xsN] =<br/>    fold f xs1 #&gt; ... #&gt; fold f xsN<br/><br/>* Pure/library.ML: the following selectors on type &#39;a option are<br/>available:<br/><br/>  the:               &#39;a option -&gt; &#39;a  (*partial*)<br/>  these:             &#39;a option -&gt; &#39;a  where &#39;a = &#39;b list<br/>  the_default: &#39;a -&gt; &#39;a option -&gt; &#39;a<br/>  the_list:          &#39;a option -&gt; &#39;a list<br/><br/>* Pure/General: structure AList (cf. Pure/General/alist.ML) provides<br/>basic operations for association lists, following natural argument<br/>order; moreover the explicit equality predicate passed here avoids<br/>potentially expensive polymorphic runtime equality checks.<br/>The old functions may be expressed as follows:<br/><br/>  assoc = uncurry (AList.lookup (op =))<br/>  assocs = these oo AList.lookup (op =)<br/>  overwrite = uncurry (AList.update (op =)) o swap<br/><br/>* Pure/General: structure AList (cf. Pure/General/alist.ML) provides<br/><br/>  val make: (&#39;a -&gt; &#39;b) -&gt; &#39;a list -&gt; (&#39;a * &#39;b) list<br/>  val find: (&#39;a * &#39;b -&gt; bool) -&gt; (&#39;c * &#39;b) list -&gt; &#39;a -&gt; &#39;c list<br/><br/>replacing make_keylist and keyfilter (occassionally used)<br/>Naive rewrites:<br/><br/>  make_keylist = AList.make<br/>  keyfilter = AList.find (op =)<br/><br/>* eq_fst and eq_snd now take explicit equality parameter, thus<br/>  avoiding eqtypes. Naive rewrites:<br/><br/>    eq_fst = eq_fst (op =)<br/>    eq_snd = eq_snd (op =)<br/><br/>* Removed deprecated apl and apr (rarely used).<br/>  Naive rewrites:<br/><br/>    apl (n, op) =&gt;&gt;= curry op n<br/>    apr (op, m) =&gt;&gt;= fn n =&gt; op (n, m)<br/><br/>* Pure/General: structure OrdList (cf. Pure/General/ord_list.ML)<br/>provides a reasonably efficient light-weight implementation of sets as<br/>lists.<br/><br/>* Pure/General: generic tables (cf. Pure/General/table.ML) provide a<br/>few new operations; existing lookup and update are now curried to<br/>follow natural argument order (for use with fold etc.);<br/>INCOMPATIBILITY, use (uncurry Symtab.lookup) etc. as last resort.<br/><br/>* Pure/General: output via the Isabelle channels of<br/>writeln/warning/error etc. is now passed through Output.output, with a<br/>hook for arbitrary transformations depending on the print_mode<br/>(cf. Output.add_mode -- the first active mode that provides a output<br/>function wins).  Already formatted output may be embedded into further<br/>text via Output.raw; the result of Pretty.string_of/str_of and derived<br/>functions (string_of_term/cterm/thm etc.) is already marked raw to<br/>accommodate easy composition of diagnostic messages etc.  Programmers<br/>rarely need to care about Output.output or Output.raw at all, with<br/>some notable exceptions: Output.output is required when bypassing the<br/>standard channels (writeln etc.), or in token translations to produce<br/>properly formatted results; Output.raw is required when capturing<br/>already output material that will eventually be presented to the user<br/>a second time.  For the default print mode, both Output.output and<br/>Output.raw have no effect.<br/><br/>* Pure/General: Output.time_accumulator NAME creates an operator (&#39;a<br/>-&gt; &#39;b) -&gt; &#39;a -&gt; &#39;b to measure runtime and count invocations; the<br/>cumulative results are displayed at the end of a batch session.<br/><br/>* Pure/General: File.sysify_path and File.quote_sysify path have been<br/>replaced by File.platform_path and File.shell_path (with appropriate<br/>hooks).  This provides a clean interface for unusual systems where the<br/>internal and external process view of file names are different.<br/><br/>* Pure: more efficient orders for basic syntactic entities: added<br/>fast_string_ord, fast_indexname_ord, fast_term_ord; changed sort_ord<br/>and typ_ord to use fast_string_ord and fast_indexname_ord (term_ord is<br/>NOT affected); structures Symtab, Vartab, Typtab, Termtab use the fast<br/>orders now -- potential INCOMPATIBILITY for code that depends on a<br/>particular order for Symtab.keys, Symtab.dest, etc. (consider using<br/>Library.sort_strings on result).<br/><br/>* Pure/term.ML: combinators fold_atyps, fold_aterms, fold_term_types,<br/>fold_types traverse types/terms from left to right, observing natural<br/>argument order.  Supercedes previous foldl_XXX versions, add_frees,<br/>add_vars etc. have been adapted as well: INCOMPATIBILITY.<br/><br/>* Pure: name spaces have been refined, with significant changes of the<br/>internal interfaces -- INCOMPATIBILITY.  Renamed cond_extern(_table)<br/>to extern(_table).  The plain name entry path is superceded by a<br/>general &#39;naming&#39; context, which also includes the &#39;policy&#39; to produce<br/>a fully qualified name and external accesses of a fully qualified<br/>name; NameSpace.extend is superceded by context dependent<br/>Sign.declare_name.  Several theory and proof context operations modify<br/>the naming context.  Especially note Theory.restore_naming and<br/>ProofContext.restore_naming to get back to a sane state; note that<br/>Theory.add_path is no longer sufficient to recover from<br/>Theory.absolute_path in particular.<br/><br/>* Pure: new flags short_names (default false) and unique_names<br/>(default true) for controlling output of qualified names.  If<br/>short_names is set, names are printed unqualified.  If unique_names is<br/>reset, the name prefix is reduced to the minimum required to achieve<br/>the original result when interning again, even if there is an overlap<br/>with earlier declarations.<br/><br/>* Pure/TheoryDataFun: change of the argument structure; &#39;prep_ext&#39; is<br/>now &#39;extend&#39;, and &#39;merge&#39; gets an additional Pretty.pp argument<br/>(useful for printing error messages).  INCOMPATIBILITY.<br/><br/>* Pure: major reorganization of the theory context.  Type Sign.sg and<br/>Theory.theory are now identified, referring to the universal<br/>Context.theory (see Pure/context.ML).  Actual signature and theory<br/>content is managed as theory data.  The old code and interfaces were<br/>spread over many files and structures; the new arrangement introduces<br/>considerable INCOMPATIBILITY to gain more clarity:<br/><br/>  Context -- theory management operations (name, identity, inclusion,<br/>    parents, ancestors, merge, etc.), plus generic theory data;<br/><br/>  Sign -- logical signature and syntax operations (declaring consts,<br/>    types, etc.), plus certify/read for common entities;<br/><br/>  Theory -- logical theory operations (stating axioms, definitions,<br/>    oracles), plus a copy of logical signature operations (consts,<br/>    types, etc.); also a few basic management operations (Theory.copy,<br/>    Theory.merge, etc.)<br/><br/>The most basic sign_of operations (Theory.sign_of, Thm.sign_of_thm<br/>etc.) as well as the sign field in Thm.rep_thm etc. have been retained<br/>for convenience -- they merely return the theory.<br/><br/>* Pure: type Type.tsig is superceded by theory in most interfaces.<br/><br/>* Pure: the Isar proof context type is already defined early in Pure<br/>as Context.proof (note that ProofContext.context and Proof.context are<br/>aliases, where the latter is the preferred name).  This enables other<br/>Isabelle components to refer to that type even before Isar is present.<br/><br/>* Pure/sign/theory: discontinued named name spaces (i.e. classK,<br/>typeK, constK, axiomK, oracleK), but provide explicit operations for<br/>any of these kinds.  For example, Sign.intern typeK is now<br/>Sign.intern_type, Theory.hide_space Sign.typeK is now<br/>Theory.hide_types.  Also note that former<br/>Theory.hide_classes/types/consts are now<br/>Theory.hide_classes_i/types_i/consts_i, while the non &#39;_i&#39; versions<br/>internalize their arguments!  INCOMPATIBILITY.<br/><br/>* Pure: get_thm interface (of PureThy and ProofContext) expects<br/>datatype thmref (with constructors Name and NameSelection) instead of<br/>plain string -- INCOMPATIBILITY;<br/><br/>* Pure: cases produced by proof methods specify options, where NONE<br/>means to remove case bindings -- INCOMPATIBILITY in<br/>(RAW_)METHOD_CASES.<br/><br/>* Pure: the following operations retrieve axioms or theorems from a<br/>theory node or theory hierarchy, respectively:<br/><br/>  Theory.axioms_of: theory -&gt; (string * term) list<br/>  Theory.all_axioms_of: theory -&gt; (string * term) list<br/>  PureThy.thms_of: theory -&gt; (string * thm) list<br/>  PureThy.all_thms_of: theory -&gt; (string * thm) list<br/><br/>* Pure: print_tac now outputs the goal through the trace channel.<br/><br/>* Isar toplevel: improved diagnostics, mostly for Poly/ML only.<br/>Reference Toplevel.debug (default false) controls detailed printing<br/>and tracing of low-level exceptions; Toplevel.profiling (default 0)<br/>controls execution profiling -- set to 1 for time and 2 for space<br/>(both increase the runtime).<br/><br/>* Isar session: The initial use of ROOT.ML is now always timed,<br/>i.e. the log will show the actual process times, in contrast to the<br/>elapsed wall-clock time that the outer shell wrapper produces.<br/><br/>* Simplifier: improved handling of bound variables (nameless<br/>representation, avoid allocating new strings).  Simprocs that invoke<br/>the Simplifier recursively should use Simplifier.inherit_bounds to<br/>avoid local name clashes.  Failure to do so produces warnings<br/>&quot;Simplifier: renamed bound variable ...&quot;; set Simplifier.debug_bounds<br/>for further details.<br/><br/>* ML functions legacy_bindings and use_legacy_bindings produce ML fact<br/>bindings for all theorems stored within a given theory; this may help<br/>in porting non-Isar theories to Isar ones, while keeping ML proof<br/>scripts for the time being.<br/><br/>* ML operator HTML.with_charset specifies the charset begin used for<br/>generated HTML files.  For example:<br/><br/>  HTML.with_charset &quot;utf-8&quot; use_thy &quot;Hebrew&quot;;<br/>  HTML.with_charset &quot;utf-8&quot; use_thy &quot;Chinese&quot;;<br/><br/><br/>*** System ***<br/><br/>* Allow symlinks to all proper Isabelle executables (Isabelle,<br/>isabelle, isatool etc.).<br/><br/>* ISABELLE_DOC_FORMAT setting specifies preferred document format (for<br/>isatool doc, isatool mkdir, display_drafts etc.).<br/><br/>* isatool usedir: option -f allows specification of the ML file to be<br/>used by Isabelle; default is ROOT.ML.<br/><br/>* New isatool version outputs the version identifier of the Isabelle<br/>distribution being used.<br/><br/>* HOL: new isatool dimacs2hol converts files in DIMACS CNF format<br/>(containing Boolean satisfiability problems) into Isabelle/HOL<br/>theories.<br/><br/><br/><br/>New in Isabelle2004 (April 2004)<br/>--------------------------------<br/><br/>*** General ***<br/><br/>* Provers/order.ML:  new efficient reasoner for partial and linear orders.<br/>  Replaces linorder.ML.<br/><br/>* Pure: Greek letters (except small lambda, λ), as well as Gothic<br/>  (𝔞...𝔷𝔄...ℨ), calligraphic (𝒜...𝒵), and Euler<br/>  (𝖺...𝗓), are now considered normal letters, and can therefore<br/>  be used anywhere where an ASCII letter (a...zA...Z) has until<br/>  now. COMPATIBILITY: This obviously changes the parsing of some<br/>  terms, especially where a symbol has been used as a binder, say<br/>  &#39;Πx. ...&#39;, which is now a type error since Πx will be parsed<br/>  as an identifier.  Fix it by inserting a space around former<br/>  symbols.  Call &#39;isatool fixgreek&#39; to try to fix parsing errors in<br/>  existing theory and ML files.<br/><br/>* Pure: Macintosh and Windows line-breaks are now allowed in theory files.<br/><br/>* Pure: single letter sub/superscripts (\&lt;^isub&gt; and \&lt;^isup&gt;) are now<br/>  allowed in identifiers. Similar to Greek letters \&lt;^isub&gt; is now considered<br/>  a normal (but invisible) letter. For multiple letter subscripts repeat<br/>  \&lt;^isub&gt; like this: x\&lt;^isub&gt;1\&lt;^isub&gt;2.<br/><br/>* Pure: There are now sub-/superscripts that can span more than one<br/>  character. Text between ⇘ and ⇙ is set in subscript in<br/>  ProofGeneral and LaTeX, text between ⇗ and ⇖ in<br/>  superscript. The new control characters are not identifier parts.<br/><br/>* Pure: Control-symbols of the form \&lt;^raw:...&gt; will literally print the<br/>  content of &quot;...&quot; to the latex file instead of \isacntrl... . The &quot;...&quot;<br/>  may consist of any printable characters excluding the end bracket &gt;.<br/><br/>* Pure: Using new Isar command &quot;finalconsts&quot; (or the ML functions<br/>  Theory.add_finals or Theory.add_finals_i) it is now possible to<br/>  declare constants &quot;final&quot;, which prevents their being given a definition<br/>  later.  It is useful for constants whose behaviour is fixed axiomatically<br/>  rather than definitionally, such as the meta-logic connectives.<br/><br/>* Pure: &#39;instance&#39; now handles general arities with general sorts<br/>  (i.e. intersections of classes),<br/><br/>* Presentation: generated HTML now uses a CSS style sheet to make layout<br/>  (somewhat) independent of content. It is copied from lib/html/isabelle.css.<br/>  It can be changed to alter the colors/layout of generated pages.<br/><br/><br/>*** Isar ***<br/><br/>* Tactic emulation methods rule_tac, erule_tac, drule_tac, frule_tac,<br/>  cut_tac, subgoal_tac and thin_tac:<br/>  - Now understand static (Isar) contexts.  As a consequence, users of Isar<br/>    locales are no longer forced to write Isar proof scripts.<br/>    For details see Isar Reference Manual, paragraph 4.3.2: Further tactic<br/>    emulations.<br/>  - INCOMPATIBILITY: names of variables to be instantiated may no<br/>    longer be enclosed in quotes.  Instead, precede variable name with `?&#39;.<br/>    This is consistent with the instantiation attribute &quot;where&quot;.<br/><br/>* Attributes &quot;where&quot; and &quot;of&quot;:<br/>  - Now take type variables of instantiated theorem into account when reading<br/>    the instantiation string.  This fixes a bug that caused instantiated<br/>    theorems to have too special types in some circumstances.<br/>  - &quot;where&quot; permits explicit instantiations of type variables.<br/><br/>* Calculation commands &quot;moreover&quot; and &quot;also&quot; no longer interfere with<br/>  current facts (&quot;this&quot;), admitting arbitrary combinations with &quot;then&quot;<br/>  and derived forms.<br/><br/>* Locales:<br/>  - Goal statements involving the context element &quot;includes&quot; no longer<br/>    generate theorems with internal delta predicates (those ending on<br/>    &quot;_axioms&quot;) in the premise.<br/>    Resolve particular premise with &lt;locale&gt;.intro to obtain old form.<br/>  - Fixed bug in type inference (&quot;unify_frozen&quot;) that prevented mix of target<br/>    specification and &quot;includes&quot; elements in goal statement.<br/>  - Rule sets &lt;locale&gt;.intro and &lt;locale&gt;.axioms no longer declared as<br/>    [intro?] and [elim?] (respectively) by default.<br/>  - Experimental command for instantiation of locales in proof contexts:<br/>        instantiate &lt;label&gt;[&lt;attrs&gt;]: &lt;loc&gt;<br/>    Instantiates locale &lt;loc&gt; and adds all its theorems to the current context<br/>    taking into account their attributes.  Label and attrs are optional<br/>    modifiers, like in theorem declarations.  If present, names of<br/>    instantiated theorems are qualified with &lt;label&gt;, and the attributes<br/>    &lt;attrs&gt; are applied after any attributes these theorems might have already.<br/>      If the locale has assumptions, a chained fact of the form<br/>    &quot;&lt;loc&gt; t1 ... tn&quot; is expected from which instantiations of the parameters<br/>    are derived.  The command does not support old-style locales declared<br/>    with &quot;locale (open)&quot;.<br/>      A few (very simple) examples can be found in FOL/ex/LocaleInst.thy.<br/><br/>* HOL: Tactic emulation methods induct_tac and case_tac understand static<br/>  (Isar) contexts.<br/><br/><br/>*** HOL ***<br/><br/>* Proof import: new image HOL4 contains the imported library from<br/>  the HOL4 system with about 2500 theorems. It is imported by<br/>  replaying proof terms produced by HOL4 in Isabelle. The HOL4 image<br/>  can be used like any other Isabelle image.  See<br/>  HOL/Import/HOL/README for more information.<br/><br/>* Simplifier:<br/>  - Much improved handling of linear and partial orders.<br/>    Reasoners for linear and partial orders are set up for type classes<br/>    &quot;linorder&quot; and &quot;order&quot; respectively, and are added to the default simpset<br/>    as solvers.  This means that the simplifier can build transitivity chains<br/>    to solve goals from the assumptions.<br/>  - INCOMPATIBILITY: old proofs break occasionally.  Typically, applications<br/>    of blast or auto after simplification become unnecessary because the goal<br/>    is solved by simplification already.<br/><br/>* Numerics: new theory Ring_and_Field contains over 250 basic numerical laws,<br/>    all proved in axiomatic type classes for semirings, rings and fields.<br/><br/>* Numerics:<br/>  - Numeric types (nat, int, and in HOL-Complex rat, real, complex, etc.) are<br/>    now formalized using the Ring_and_Field theory mentioned above.<br/>  - INCOMPATIBILITY: simplification and arithmetic behaves somewhat differently<br/>    than before, because now they are set up once in a generic manner.<br/>  - INCOMPATIBILITY: many type-specific arithmetic laws have gone.<br/>    Look for the general versions in Ring_and_Field (and Power if they concern<br/>    exponentiation).<br/><br/>* Type &quot;rat&quot; of the rational numbers is now available in HOL-Complex.<br/><br/>* Records:<br/>  - Record types are now by default printed with their type abbreviation<br/>    instead of the list of all field types. This can be configured via<br/>    the reference &quot;print_record_type_abbr&quot;.<br/>  - Simproc &quot;record_upd_simproc&quot; for simplification of multiple updates added<br/>    (not enabled by default).<br/>  - Simproc &quot;record_ex_sel_eq_simproc&quot; to simplify EX x. sel r = x resp.<br/>    EX x. x = sel r to True (not enabled by default).<br/>  - Tactic &quot;record_split_simp_tac&quot; to split and simplify records added.<br/><br/>* &#39;specification&#39; command added, allowing for definition by<br/>  specification.  There is also an &#39;ax_specification&#39; command that<br/>  introduces the new constants axiomatically.<br/><br/>* arith(_tac) is now able to generate counterexamples for reals as well.<br/><br/>* HOL-Algebra: new locale &quot;ring&quot; for non-commutative rings.<br/><br/>* HOL-ex: InductiveInvariant_examples illustrates advanced recursive function<br/>  definitions, thanks to Sava Krsti\&#39;{c} and John Matthews.<br/><br/>* HOL-Matrix: a first theory for matrices in HOL with an application of<br/>  matrix theory to linear programming.<br/><br/>* Unions and Intersections:<br/>  The latex output syntax of UN and INT has been changed<br/>  from &quot;\Union x \in A. B&quot; to &quot;\Union_{x \in A} B&quot;<br/>  i.e. the index formulae has become a subscript.<br/>  Similarly for &quot;\Union x. B&quot;, and for \Inter instead of \Union.<br/><br/>* Unions and Intersections over Intervals:<br/>  There is new short syntax &quot;UN i&lt;=n. A&quot; for &quot;UN i:{0..n}. A&quot;. There is<br/>  also an x-symbol version with subscripts &quot;⋃⇘i &lt;= n⇙. A&quot;<br/>  like in normal math, and corresponding versions for &lt; and for intersection.<br/><br/>* HOL/List: Ordering &quot;lexico&quot; is renamed &quot;lenlex&quot; and the standard<br/>  lexicographic dictonary ordering has been added as &quot;lexord&quot;.<br/><br/>* ML: the legacy theory structures Int and List have been removed. They had<br/>  conflicted with ML Basis Library structures having the same names.<br/><br/>* &#39;refute&#39; command added to search for (finite) countermodels.  Only works<br/>  for a fragment of HOL.  The installation of an external SAT solver is<br/>  highly recommended.  See &quot;HOL/Refute.thy&quot; for details.<br/><br/>* &#39;quickcheck&#39; command: Allows to find counterexamples by evaluating<br/>  formulae under an assignment of free variables to random values.<br/>  In contrast to &#39;refute&#39;, it can deal with inductive datatypes,<br/>  but cannot handle quantifiers. See &quot;HOL/ex/Quickcheck_Examples.thy&quot;<br/>  for examples.<br/><br/><br/>*** HOLCF ***<br/><br/>* Streams now come with concatenation and are part of the HOLCF image<br/><br/><br/><br/>New in Isabelle2003 (May 2003)<br/>------------------------------<br/><br/>*** General ***<br/><br/>* Provers/simplifier:<br/><br/>  - Completely reimplemented method simp (ML: Asm_full_simp_tac):<br/>    Assumptions are now subject to complete mutual simplification,<br/>    not just from left to right. The simplifier now preserves<br/>    the order of assumptions.<br/><br/>    Potential INCOMPATIBILITY:<br/><br/>    -- simp sometimes diverges where the old version did<br/>       not, e.g. invoking simp on the goal<br/><br/>        [| P (f x); y = x; f x = f y |] ==&gt; Q<br/><br/>       now gives rise to the infinite reduction sequence<br/><br/>        P(f x) --(f x = f y)--&gt; P(f y) --(y = x)--&gt; P(f x) --(f x = f y)--&gt; ...<br/><br/>       Using &quot;simp (asm_lr)&quot; (ML: Asm_lr_simp_tac) instead often solves this<br/>       kind of problem.<br/><br/>    -- Tactics combining classical reasoner and simplification (such as auto)<br/>       are also affected by this change, because many of them rely on<br/>       simp. They may sometimes diverge as well or yield a different numbers<br/>       of subgoals. Try to use e.g. force, fastsimp, or safe instead of auto<br/>       in case of problems. Sometimes subsequent calls to the classical<br/>       reasoner will fail because a preceeding call to the simplifier too<br/>       eagerly simplified the goal, e.g. deleted redundant premises.<br/><br/>  - The simplifier trace now shows the names of the applied rewrite rules<br/><br/>  - You can limit the number of recursive invocations of the simplifier<br/>    during conditional rewriting (where the simplifie tries to solve the<br/>    conditions before applying the rewrite rule):<br/>    ML &quot;simp_depth_limit := n&quot;<br/>    where n is an integer. Thus you can force termination where previously<br/>    the simplifier would diverge.<br/><br/>  - Accepts free variables as head terms in congruence rules.  Useful in Isar.<br/><br/>  - No longer aborts on failed congruence proof.  Instead, the<br/>    congruence is ignored.<br/><br/>* Pure: New generic framework for extracting programs from constructive<br/>  proofs. See HOL/Extraction.thy for an example instantiation, as well<br/>  as HOL/Extraction for some case studies.<br/><br/>* Pure: The main goal of the proof state is no longer shown by default, only<br/>the subgoals. This behaviour is controlled by a new flag.<br/>   PG menu: Isabelle/Isar -&gt; Settings -&gt; Show Main Goal<br/>(ML: Proof.show_main_goal).<br/><br/>* Pure: You can find all matching introduction rules for subgoal 1, i.e. all<br/>rules whose conclusion matches subgoal 1:<br/>      PG menu: Isabelle/Isar -&gt; Show me -&gt; matching rules<br/>The rules are ordered by how closely they match the subgoal.<br/>In particular, rules that solve a subgoal outright are displayed first<br/>(or rather last, the way they are printed).<br/>(ML: ProofGeneral.print_intros())<br/><br/>* Pure: New flag trace_unify_fail causes unification to print<br/>diagnostic information (PG: in trace buffer) when it fails. This is<br/>useful for figuring out why single step proofs like rule, erule or<br/>assumption failed.<br/><br/>* Pure: Locale specifications now produce predicate definitions<br/>according to the body of text (covering assumptions modulo local<br/>definitions); predicate &quot;loc_axioms&quot; covers newly introduced text,<br/>while &quot;loc&quot; is cumulative wrt. all included locale expressions; the<br/>latter view is presented only on export into the global theory<br/>context; potential INCOMPATIBILITY, use &quot;(open)&quot; option to fall back<br/>on the old view without predicates;<br/><br/>* Pure: predefined locales &quot;var&quot; and &quot;struct&quot; are useful for sharing<br/>parameters (as in CASL, for example); just specify something like<br/>``var x + var y + struct M&#39;&#39; as import;<br/><br/>* Pure: improved thms_containing: proper indexing of facts instead of<br/>raw theorems; check validity of results wrt. current name space;<br/>include local facts of proof configuration (also covers active<br/>locales), cover fixed variables in index; may use &quot;_&quot; in term<br/>specification; an optional limit for the number of printed facts may<br/>be given (the default is 40);<br/><br/>* Pure: disallow duplicate fact bindings within new-style theory files<br/>(batch-mode only);<br/><br/>* Provers: improved induct method: assumptions introduced by case<br/>&quot;foo&quot; are split into &quot;foo.hyps&quot; (from the rule) and &quot;foo.prems&quot; (from<br/>the goal statement); &quot;foo&quot; still refers to all facts collectively;<br/><br/>* Provers: the function blast.overloaded has been removed: all constants<br/>are regarded as potentially overloaded, which improves robustness in exchange<br/>for slight decrease in efficiency;<br/><br/>* Provers/linorder: New generic prover for transitivity reasoning over<br/>linear orders.  Note: this prover is not efficient!<br/><br/>* Isar: preview of problems to finish &#39;show&#39; now produce an error<br/>rather than just a warning (in interactive mode);<br/><br/><br/>*** HOL ***<br/><br/>* arith(_tac)<br/><br/> - Produces a counter example if it cannot prove a goal.<br/>   Note that the counter example may be spurious if the goal is not a formula<br/>   of quantifier-free linear arithmetic.<br/>   In ProofGeneral the counter example appears in the trace buffer.<br/><br/> - Knows about div k and mod k where k is a numeral of type nat or int.<br/><br/> - Calls full Presburger arithmetic (by Amine Chaieb) if quantifier-free<br/>   linear arithmetic fails. This takes account of quantifiers and divisibility.<br/>   Presburger arithmetic can also be called explicitly via presburger(_tac).<br/><br/>* simp&#39;s arithmetic capabilities have been enhanced a bit: it now<br/>takes ~= in premises into account (by performing a case split);<br/><br/>* simp reduces &quot;m*(n div m) + n mod m&quot; to n, even if the two summands<br/>are distributed over a sum of terms;<br/><br/>* New tactic &quot;trans_tac&quot; and method &quot;trans&quot; instantiate<br/>Provers/linorder.ML for axclasses &quot;order&quot; and &quot;linorder&quot; (predicates<br/>&quot;&lt;=&quot;, &quot;&lt;&quot; and &quot;=&quot;).<br/><br/>* function INCOMPATIBILITIES: Pi-sets have been redefined and moved from main<br/>HOL to Library/FuncSet; constant &quot;Fun.op o&quot; is now called &quot;Fun.comp&quot;;<br/><br/>* &#39;typedef&#39; command has new option &quot;open&quot; to suppress the set<br/>definition;<br/><br/>* functions Min and Max on finite sets have been introduced (theory<br/>Finite_Set);<br/><br/>* attribute [symmetric] now works for relations as well; it turns<br/>(x,y) : R^-1 into (y,x) : R, and vice versa;<br/><br/>* induct over a !!-quantified statement (say !!x1..xn):<br/>  each &quot;case&quot; automatically performs &quot;fix x1 .. xn&quot; with exactly those names.<br/><br/>* Map: `empty&#39; is no longer a constant but a syntactic abbreviation for<br/>%x. None. Warning: empty_def now refers to the previously hidden definition<br/>of the empty set.<br/><br/>* Algebra: formalization of classical algebra.  Intended as base for<br/>any algebraic development in Isabelle.  Currently covers group theory<br/>(up to Sylow&#39;s theorem) and ring theory (Universal Property of<br/>Univariate Polynomials).  Contributions welcome;<br/><br/>* GroupTheory: deleted, since its material has been moved to Algebra;<br/><br/>* Complex: new directory of the complex numbers with numeric constants,<br/>nonstandard complex numbers, and some complex analysis, standard and<br/>nonstandard (Jacques Fleuriot);<br/><br/>* HOL-Complex: new image for analysis, replacing HOL-Real and HOL-Hyperreal;<br/><br/>* Hyperreal: introduced Gauge integration and hyperreal logarithms (Jacques<br/>Fleuriot);<br/><br/>* Real/HahnBanach: updated and adapted to locales;<br/><br/>* NumberTheory: added Gauss&#39;s law of quadratic reciprocity (by Avigad,<br/>Gray and Kramer);<br/><br/>* UNITY: added the Meier-Sanders theory of progress sets;<br/><br/>* MicroJava: bytecode verifier and lightweight bytecode verifier<br/>as abstract algorithms, instantiated to the JVM;<br/><br/>* Bali: Java source language formalization. Type system, operational<br/>semantics, axiomatic semantics. Supported language features:<br/>classes, interfaces, objects,virtual methods, static methods,<br/>static/instance fields, arrays, access modifiers, definite<br/>assignment, exceptions.<br/><br/><br/>*** ZF ***<br/><br/>* ZF/Constructible: consistency proof for AC (Gdel&#39;s constructible<br/>universe, etc.);<br/><br/>* Main ZF: virtually all theories converted to new-style format;<br/><br/><br/>*** ML ***<br/><br/>* Pure: Tactic.prove provides sane interface for internal proofs;<br/>omits the infamous &quot;standard&quot; operation, so this is more appropriate<br/>than prove_goalw_cterm in many situations (e.g. in simprocs);<br/><br/>* Pure: improved error reporting of simprocs;<br/><br/>* Provers: Simplifier.simproc(_i) provides sane interface for setting<br/>up simprocs;<br/><br/><br/>*** Document preparation ***<br/><br/>* uses \par instead of \\ for line breaks in theory text. This may<br/>shift some page breaks in large documents. To get the old behaviour<br/>use \renewcommand{\isanewline}{\mbox{}\\\mbox{}} in root.tex.<br/><br/>* minimized dependencies of isabelle.sty and isabellesym.sty on<br/>other packages<br/><br/>* € now needs package babel/greek instead of marvosym (which<br/>broke \Rightarrow)<br/><br/>* normal size for 𝟬...𝟵 (uses \mathbf instead of<br/>textcomp package)<br/><br/><br/><br/>New in Isabelle2002 (March 2002)<br/>--------------------------------<br/><br/>*** Document preparation ***<br/><br/>* greatly simplified document preparation setup, including more<br/>graceful interpretation of isatool usedir -i/-d/-D options, and more<br/>instructive isatool mkdir; users should basically be able to get<br/>started with &quot;isatool mkdir HOL Test &amp;&amp; isatool make&quot;; alternatively,<br/>users may run a separate document processing stage manually like this:<br/>&quot;isatool usedir -D output HOL Test &amp;&amp; isatool document Test/output&quot;;<br/><br/>* theory dependency graph may now be incorporated into documents;<br/>isatool usedir -g true will produce session_graph.eps/.pdf for use<br/>with \includegraphics of LaTeX;<br/><br/>* proper spacing of consecutive markup elements, especially text<br/>blocks after section headings;<br/><br/>* support bold style (for single symbols only), input syntax is like<br/>this: &quot;<b>α</b>&quot; or &quot;<b>A</b>&quot;;<br/><br/>* ∙ is now output as bold \cdot by default, which looks much<br/>better in printed text;<br/><br/>* added default LaTeX bindings for ⊩ and ⊫;<br/>note that these symbols are currently unavailable in Proof General /<br/>X-Symbol; new symbols 𝟬, 𝟭, ..., 𝟵, and €;<br/><br/>* isatool latex no longer depends on changed TEXINPUTS, instead<br/>isatool document copies the Isabelle style files to the target<br/>location;<br/><br/><br/>*** Isar ***<br/><br/>* Pure/Provers: improved proof by cases and induction;<br/>  - &#39;case&#39; command admits impromptu naming of parameters (such as<br/>    &quot;case (Suc n)&quot;);<br/>  - &#39;induct&#39; method divinates rule instantiation from the inductive<br/>    claim; no longer requires excessive ?P bindings for proper<br/>    instantiation of cases;<br/>  - &#39;induct&#39; method properly enumerates all possibilities of set/type<br/>    rules; as a consequence facts may be also passed through *type*<br/>    rules without further ado;<br/>  - &#39;induct&#39; method now derives symbolic cases from the *rulified*<br/>    rule (before it used to rulify cases stemming from the internal<br/>    atomized version); this means that the context of a non-atomic<br/>    statement becomes is included in the hypothesis, avoiding the<br/>    slightly cumbersome show &quot;PROP ?case&quot; form;<br/>  - &#39;induct&#39; may now use elim-style induction rules without chaining<br/>    facts, using ``missing&#39;&#39; premises from the goal state; this allows<br/>    rules stemming from inductive sets to be applied in unstructured<br/>    scripts, while still benefitting from proper handling of non-atomic<br/>    statements; NB: major inductive premises need to be put first, all<br/>    the rest of the goal is passed through the induction;<br/>  - &#39;induct&#39; proper support for mutual induction involving non-atomic<br/>    rule statements (uses the new concept of simultaneous goals, see<br/>    below);<br/>  - append all possible rule selections, but only use the first<br/>    success (no backtracking);<br/>  - removed obsolete &quot;(simplified)&quot; and &quot;(stripped)&quot; options of methods;<br/>  - undeclared rule case names default to numbers 1, 2, 3, ...;<br/>  - added &#39;print_induct_rules&#39; (covered by help item in recent Proof<br/>    General versions);<br/>  - moved induct/cases attributes to Pure, methods to Provers;<br/>  - generic method setup instantiated for FOL and HOL;<br/><br/>* Pure: support multiple simultaneous goal statements, for example<br/>&quot;have a: A and b: B&quot; (same for &#39;theorem&#39; etc.); being a pure<br/>meta-level mechanism, this acts as if several individual goals had<br/>been stated separately; in particular common proof methods need to be<br/>repeated in order to cover all claims; note that a single elimination<br/>step is *not* sufficient to establish the two conjunctions, so this<br/>fails:<br/><br/>  assume &quot;A &amp; B&quot; then have A and B ..   (*&quot;..&quot; fails*)<br/><br/>better use &quot;obtain&quot; in situations as above; alternative refer to<br/>multi-step methods like &#39;auto&#39;, &#39;simp_all&#39;, &#39;blast+&#39; etc.;<br/><br/>* Pure: proper integration with ``locales&#39;&#39;; unlike the original<br/>version by Florian Kammller, Isar locales package high-level proof<br/>contexts rather than raw logical ones (e.g. we admit to include<br/>attributes everywhere); operations on locales include merge and<br/>rename; support for implicit arguments (``structures&#39;&#39;); simultaneous<br/>type-inference over imports and text; see also HOL/ex/Locales.thy for<br/>some examples;<br/><br/>* Pure: the following commands have been ``localized&#39;&#39;, supporting a<br/>target locale specification &quot;(in name)&quot;: &#39;lemma&#39;, &#39;theorem&#39;,<br/>&#39;corollary&#39;, &#39;lemmas&#39;, &#39;theorems&#39;, &#39;declare&#39;; the results will be<br/>stored both within the locale and at the theory level (exported and<br/>qualified by the locale name);<br/><br/>* Pure: theory goals may now be specified in ``long&#39;&#39; form, with<br/>ad-hoc contexts consisting of arbitrary locale elements. for example<br/>``lemma foo: fixes x assumes &quot;A x&quot; shows &quot;B x&quot;&#39;&#39; (local syntax and<br/>definitions may be given, too); the result is a meta-level rule with<br/>the context elements being discharged in the obvious way;<br/><br/>* Pure: new proof command &#39;using&#39; allows to augment currently used<br/>facts after a goal statement (&#39;using&#39; is syntactically analogous to<br/>&#39;apply&#39;, but acts on the goal&#39;s facts only); this allows chained facts<br/>to be separated into parts given before and after a claim, as in<br/>``from a and b have C using d and e &lt;proof&gt;&#39;&#39;;<br/><br/>* Pure: renamed &quot;antecedent&quot; case to &quot;rule_context&quot;;<br/><br/>* Pure: new &#39;judgment&#39; command records explicit information about the<br/>object-logic embedding (used by several tools internally); no longer<br/>use hard-wired &quot;Trueprop&quot;;<br/><br/>* Pure: added &#39;corollary&#39; command;<br/><br/>* Pure: fixed &#39;token_translation&#39; command;<br/><br/>* Pure: removed obsolete &#39;exported&#39; attribute;<br/><br/>* Pure: dummy pattern &quot;_&quot; in is/let is now automatically lifted over<br/>bound variables: &quot;ALL x. P x --&gt; Q x&quot; (is &quot;ALL x. _ --&gt; ?C x&quot;)<br/>supersedes more cumbersome ... (is &quot;ALL x. _ x --&gt; ?C x&quot;);<br/><br/>* Pure: method &#39;atomize&#39; presents local goal premises as object-level<br/>statements (atomic meta-level propositions); setup controlled via<br/>rewrite rules declarations of &#39;atomize&#39; attribute; example<br/>application: &#39;induct&#39; method with proper rule statements in improper<br/>proof *scripts*;<br/><br/>* Pure: emulation of instantiation tactics (rule_tac, cut_tac, etc.)<br/>now consider the syntactic context of assumptions, giving a better<br/>chance to get type-inference of the arguments right (this is<br/>especially important for locales);<br/><br/>* Pure: &quot;sorry&quot; no longer requires quick_and_dirty in interactive<br/>mode;<br/><br/>* Pure/obtain: the formal conclusion &quot;thesis&quot;, being marked as<br/>``internal&#39;&#39;, may no longer be reference directly in the text;<br/>potential INCOMPATIBILITY, may need to use &quot;?thesis&quot; in rare<br/>situations;<br/><br/>* Pure: generic &#39;sym&#39; attribute which declares a rule both as pure<br/>&#39;elim?&#39; and for the &#39;symmetric&#39; operation;<br/><br/>* Pure: marginal comments ``--&#39;&#39; may now occur just anywhere in the<br/>text; the fixed correlation with particular command syntax has been<br/>discontinued;<br/><br/>* Pure: new method &#39;rules&#39; is particularly well-suited for proof<br/>search in intuitionistic logic; a bit slower than &#39;blast&#39; or &#39;fast&#39;,<br/>but often produces more compact proof terms with less detours;<br/><br/>* Pure/Provers/classical: simplified integration with pure rule<br/>attributes and methods; the classical &quot;intro?/elim?/dest?&quot;<br/>declarations coincide with the pure ones; the &quot;rule&quot; method no longer<br/>includes classically swapped intros; &quot;intro&quot; and &quot;elim&quot; methods no<br/>longer pick rules from the context; also got rid of ML declarations<br/>AddXIs/AddXEs/AddXDs; all of this has some potential for<br/>INCOMPATIBILITY;<br/><br/>* Provers/classical: attribute &#39;swapped&#39; produces classical inversions<br/>of introduction rules;<br/><br/>* Provers/simplifier: &#39;simplified&#39; attribute may refer to explicit<br/>rules instead of full simplifier context; &#39;iff&#39; attribute handles<br/>conditional rules;<br/><br/>* HOL: &#39;typedef&#39; now allows alternative names for Rep/Abs morphisms;<br/><br/>* HOL: &#39;recdef&#39; now fails on unfinished automated proofs, use<br/>&quot;(permissive)&quot; option to recover old behavior;<br/><br/>* HOL: &#39;inductive&#39; no longer features separate (collective) attributes<br/>for &#39;intros&#39; (was found too confusing);<br/><br/>* HOL: properly declared induction rules less_induct and<br/>wf_induct_rule;<br/><br/><br/>*** HOL ***<br/><br/>* HOL: moved over to sane numeral syntax; the new policy is as<br/>follows:<br/><br/>  - 0 and 1 are polymorphic constants, which are defined on any<br/>  numeric type (nat, int, real etc.);<br/><br/>  - 2, 3, 4, ... and -1, -2, -3, ... are polymorphic numerals, based<br/>  binary representation internally;<br/><br/>  - type nat has special constructor Suc, and generally prefers Suc 0<br/>  over 1::nat and Suc (Suc 0) over 2::nat;<br/><br/>This change may cause significant problems of INCOMPATIBILITY; here<br/>are some hints on converting existing sources:<br/><br/>  - due to the new &quot;num&quot; token, &quot;-0&quot; and &quot;-1&quot; etc. are now atomic<br/>  entities, so expressions involving &quot;-&quot; (unary or binary minus) need<br/>  to be spaced properly;<br/><br/>  - existing occurrences of &quot;1&quot; may need to be constraint &quot;1::nat&quot; or<br/>  even replaced by Suc 0; similar for old &quot;2&quot;;<br/><br/>  - replace &quot;#nnn&quot; by &quot;nnn&quot;, and &quot;#-nnn&quot; by &quot;-nnn&quot;;<br/><br/>  - remove all special provisions on numerals in proofs;<br/><br/>* HOL: simp rules nat_number expand numerals on nat to Suc/0<br/>representation (depends on bin_arith_simps in the default context);<br/><br/>* HOL: symbolic syntax for x^2 (numeral 2);<br/><br/>* HOL: the class of all HOL types is now called &quot;type&quot; rather than<br/>&quot;term&quot;; INCOMPATIBILITY, need to adapt references to this type class<br/>in axclass/classes, instance/arities, and (usually rare) occurrences<br/>in typings (of consts etc.); internally the class is called<br/>&quot;HOL.type&quot;, ML programs should refer to HOLogic.typeS;<br/><br/>* HOL/record package improvements:<br/>  - new derived operations &quot;fields&quot; to build a partial record section,<br/>    &quot;extend&quot; to promote a fixed record to a record scheme, and<br/>    &quot;truncate&quot; for the reverse; cf. theorems &quot;xxx.defs&quot;, which are *not*<br/>    declared as simp by default;<br/>  - shared operations (&quot;more&quot;, &quot;fields&quot;, etc.) now need to be always<br/>    qualified) --- potential INCOMPATIBILITY;<br/>  - removed &quot;make_scheme&quot; operations (use &quot;make&quot; with &quot;extend&quot;) --<br/>    INCOMPATIBILITY;<br/>  - removed &quot;more&quot; class (simply use &quot;term&quot;) -- INCOMPATIBILITY;<br/>  - provides cases/induct rules for use with corresponding Isar<br/>    methods (for concrete records, record schemes, concrete more<br/>    parts, and schematic more parts -- in that order);<br/>  - internal definitions directly based on a light-weight abstract<br/>    theory of product types over typedef rather than datatype;<br/><br/>* HOL: generic code generator for generating executable ML code from<br/>specifications; specific support for HOL constructs such as inductive<br/>datatypes and sets, as well as recursive functions; can be invoked<br/>via &#39;generate_code&#39; theory section;<br/><br/>* HOL: canonical cases/induct rules for n-tuples (n = 3..7);<br/><br/>* HOL: consolidated and renamed several theories.  In particular:<br/>        Ord.thy has been absorbed into HOL.thy<br/>        String.thy has been absorbed into List.thy<br/><br/>* HOL: concrete setsum syntax &quot;∑i:A. b&quot; == &quot;setsum (%i. b) A&quot;<br/>(beware of argument permutation!);<br/><br/>* HOL: linorder_less_split superseded by linorder_cases;<br/><br/>* HOL/List: &quot;nodups&quot; renamed to &quot;distinct&quot;;<br/><br/>* HOL: added &quot;The&quot; definite description operator; move Hilbert&#39;s &quot;Eps&quot;<br/>to peripheral theory &quot;Hilbert_Choice&quot;; some INCOMPATIBILITIES:<br/>  - Ex_def has changed, now need to use some_eq_ex<br/><br/>* HOL: made split_all_tac safe; EXISTING PROOFS MAY FAIL OR LOOP, so<br/>in this (rare) case use:<br/><br/>  delSWrapper &quot;split_all_tac&quot;<br/>  addSbefore (&quot;unsafe_split_all_tac&quot;, unsafe_split_all_tac)<br/><br/>* HOL: added safe wrapper &quot;split_conv_tac&quot; to claset; EXISTING PROOFS<br/>MAY FAIL;<br/><br/>* HOL: introduced f^n = f o ... o f; warning: due to the limits of<br/>Isabelle&#39;s type classes, ^ on functions and relations has too general<br/>a domain, namely (&#39;a * &#39;b) set and &#39;a =&gt; &#39;b; this means that it may be<br/>necessary to attach explicit type constraints;<br/><br/>* HOL/Relation: the prefix name of the infix &quot;O&quot; has been changed from<br/>&quot;comp&quot; to &quot;rel_comp&quot;; INCOMPATIBILITY: a few theorems have been<br/>renamed accordingly (eg &quot;compI&quot; -&gt; &quot;rel_compI&quot;).<br/><br/>* HOL: syntax translations now work properly with numerals and records<br/>expressions;<br/><br/>* HOL: bounded abstraction now uses syntax &quot;%&quot; / &quot;λ&quot; instead<br/>of &quot;lam&quot; -- INCOMPATIBILITY;<br/><br/>* HOL: got rid of some global declarations (potential INCOMPATIBILITY<br/>for ML tools): const &quot;()&quot; renamed &quot;Product_Type.Unity&quot;, type &quot;unit&quot;<br/>renamed &quot;Product_Type.unit&quot;;<br/><br/>* HOL: renamed rtrancl_into_rtrancl2 to converse_rtrancl_into_rtrancl<br/><br/>* HOL: removed obsolete theorem &quot;optionE&quot; (use &quot;option.exhaust&quot;, or<br/>the &quot;cases&quot; method);<br/><br/>* HOL/GroupTheory: group theory examples including Sylow&#39;s theorem (by<br/>Florian Kammller);<br/><br/>* HOL/IMP: updated and converted to new-style theory format; several<br/>parts turned into readable document, with proper Isar proof texts and<br/>some explanations (by Gerwin Klein);<br/><br/>* HOL-Real: added Complex_Numbers (by Gertrud Bauer);<br/><br/>* HOL-Hyperreal is now a logic image;<br/><br/><br/>*** HOLCF ***<br/><br/>* Isar: consts/constdefs supports mixfix syntax for continuous<br/>operations;<br/><br/>* Isar: domain package adapted to new-style theory format, e.g. see<br/>HOLCF/ex/Dnat.thy;<br/><br/>* theory Lift: proper use of rep_datatype lift instead of ML hacks --<br/>potential INCOMPATIBILITY; now use plain induct_tac instead of former<br/>lift.induct_tac, always use UU instead of Undef;<br/><br/>* HOLCF/IMP: updated and converted to new-style theory;<br/><br/><br/>*** ZF ***<br/><br/>* Isar: proper integration of logic-specific tools and packages,<br/>including theory commands &#39;(co)inductive&#39;, &#39;(co)datatype&#39;,<br/>&#39;rep_datatype&#39;, &#39;inductive_cases&#39;, as well as methods &#39;ind_cases&#39;,<br/>&#39;induct_tac&#39;, &#39;case_tac&#39;, and &#39;typecheck&#39; (with attribute &#39;TC&#39;);<br/><br/>* theory Main no longer includes AC; for the Axiom of Choice, base<br/>your theory on Main_ZFC;<br/><br/>* the integer library now covers quotients and remainders, with many<br/>laws relating division to addition, multiplication, etc.;<br/><br/>* ZF/UNITY: Chandy and Misra&#39;s UNITY is now available in ZF, giving a<br/>typeless version of the formalism;<br/><br/>* ZF/AC, Coind, IMP, Resid: updated and converted to new-style theory<br/>format;<br/><br/>* ZF/Induct: new directory for examples of inductive definitions,<br/>including theory Multiset for multiset orderings; converted to<br/>new-style theory format;<br/><br/>* ZF: many new theorems about lists, ordinals, etc.;<br/><br/><br/>*** General ***<br/><br/>* Pure/kernel: meta-level proof terms (by Stefan Berghofer); reference<br/>variable proof controls level of detail: 0 = no proofs (only oracle<br/>dependencies), 1 = lemma dependencies, 2 = compact proof terms; see<br/>also ref manual for further ML interfaces;<br/><br/>* Pure/axclass: removed obsolete ML interface<br/>goal_subclass/goal_arity;<br/><br/>* Pure/syntax: new token syntax &quot;num&quot; for plain numerals (without &quot;#&quot;<br/>of &quot;xnum&quot;); potential INCOMPATIBILITY, since -0, -1 etc. are now<br/>separate tokens, so expressions involving minus need to be spaced<br/>properly;<br/><br/>* Pure/syntax: support non-oriented infixes, using keyword &quot;infix&quot;<br/>rather than &quot;infixl&quot; or &quot;infixr&quot;;<br/><br/>* Pure/syntax: concrete syntax for dummy type variables admits genuine<br/>sort constraint specifications in type inference; e.g. &quot;x::_::foo&quot;<br/>ensures that the type of &quot;x&quot; is of sort &quot;foo&quot; (but not necessarily a<br/>type variable);<br/><br/>* Pure/syntax: print modes &quot;type_brackets&quot; and &quot;no_type_brackets&quot;<br/>control output of nested =&gt; (types); the default behavior is<br/>&quot;type_brackets&quot;;<br/><br/>* Pure/syntax: builtin parse translation for &quot;_constify&quot; turns valued<br/>tokens into AST constants;<br/><br/>* Pure/syntax: prefer later declarations of translations and print<br/>translation functions; potential INCOMPATIBILITY: need to reverse<br/>multiple declarations for same syntax element constant;<br/><br/>* Pure/show_hyps reset by default (in accordance to existing Isar<br/>practice);<br/><br/>* Provers/classical: renamed addaltern to addafter, addSaltern to<br/>addSafter;<br/><br/>* Provers/clasimp: ``iff&#39;&#39; declarations now handle conditional rules<br/>as well;<br/><br/>* system: tested support for MacOS X; should be able to get Isabelle +<br/>Proof General to work in a plain Terminal after installing Poly/ML<br/>(e.g. from the Isabelle distribution area) and GNU bash alone<br/>(e.g. from http://www.apple.com); full X11, XEmacs and X-Symbol<br/>support requires further installations, e.g. from<br/>http://fink.sourceforge.net/);<br/><br/>* system: support Poly/ML 4.1.1 (able to manage larger heaps);<br/><br/>* system: reduced base memory usage by Poly/ML (approx. 20 MB instead<br/>of 40 MB), cf. ML_OPTIONS;<br/><br/>* system: Proof General keywords specification is now part of the<br/>Isabelle distribution (see etc/isar-keywords.el);<br/><br/>* system: support for persistent Proof General sessions (refrain from<br/>outdating all loaded theories on startup); user may create writable<br/>logic images like this: ``isabelle -q HOL Test&#39;&#39;;<br/><br/>* system: smart selection of Isabelle process versus Isabelle<br/>interface, accommodates case-insensitive file systems (e.g. HFS+); may<br/>run both &quot;isabelle&quot; and &quot;Isabelle&quot; even if file names are badly<br/>damaged (executable inspects the case of the first letter of its own<br/>name); added separate &quot;isabelle-process&quot; and &quot;isabelle-interface&quot;;<br/><br/>* system: refrain from any attempt at filtering input streams; no<br/>longer support ``8bit&#39;&#39; encoding of old isabelle font, instead proper<br/>iso-latin characters may now be used; the related isatools<br/>&quot;symbolinput&quot; and &quot;nonascii&quot; have disappeared as well;<br/><br/>* system: removed old &quot;xterm&quot; interface (the print modes &quot;xterm&quot; and<br/>&quot;xterm_color&quot; are still available for direct use in a suitable<br/>terminal);<br/><br/><br/><br/>New in Isabelle99-2 (February 2001)<br/>-----------------------------------<br/><br/>*** Overview of INCOMPATIBILITIES ***<br/><br/>* HOL: please note that theories in the Library and elsewhere often use the<br/>new-style (Isar) format; to refer to their theorems in an ML script you must<br/>bind them to ML identifers by e.g.      val thm_name = thm &quot;thm_name&quot;;<br/><br/>* HOL: inductive package no longer splits induction rule aggressively,<br/>but only as far as specified by the introductions given; the old<br/>format may be recovered via ML function complete_split_rule or attribute<br/>&#39;split_rule (complete)&#39;;<br/><br/>* HOL: induct renamed to lfp_induct, lfp_Tarski to lfp_unfold,<br/>gfp_Tarski to gfp_unfold;<br/><br/>* HOL: contrapos, contrapos2 renamed to contrapos_nn, contrapos_pp;<br/><br/>* HOL: infix &quot;dvd&quot; now has priority 50 rather than 70 (because it is a<br/>relation); infix &quot;^^&quot; has been renamed &quot;``&quot;; infix &quot;``&quot; has been<br/>renamed &quot;`&quot;; &quot;univalent&quot; has been renamed &quot;single_valued&quot;;<br/><br/>* HOL/Real: &quot;rinv&quot; and &quot;hrinv&quot; replaced by overloaded &quot;inverse&quot;<br/>operation;<br/><br/>* HOLCF: infix &quot;`&quot; has been renamed &quot;$&quot;; the symbol syntax is ⋅;<br/><br/>* Isar: &#39;obtain&#39; no longer declares &quot;that&quot; fact as simp/intro;<br/><br/>* Isar/HOL: method &#39;induct&#39; now handles non-atomic goals; as a<br/>consequence, it is no longer monotonic wrt. the local goal context<br/>(which is now passed through the inductive cases);<br/><br/>* Document preparation: renamed standard symbols 𝔩 to ≪ and<br/>𝔤 to ≫;<br/><br/><br/>*** Document preparation ***<br/><br/>* \isabellestyle{NAME} selects version of Isabelle output (currently<br/>available: are &quot;it&quot; for near math-mode best-style output, &quot;sl&quot; for<br/>slanted text style, and &quot;tt&quot; for plain type-writer; if no<br/>\isabellestyle command is given, output is according to slanted<br/>type-writer);<br/><br/>* support sub/super scripts (for single symbols only), input syntax is<br/>like this: &quot;A<sup>*</sup>&quot; or &quot;A<sup>⋆</sup>&quot;;<br/><br/>* some more standard symbols; see Appendix A of the system manual for<br/>the complete list of symbols defined in isabellesym.sty;<br/><br/>* improved isabelle style files; more abstract symbol implementation<br/>(should now use \isamath{...} and \isatext{...} in custom symbol<br/>definitions);<br/><br/>* antiquotation @{goals} and @{subgoals} for output of *dynamic* goals<br/>state; Note that presentation of goal states does not conform to<br/>actual human-readable proof documents.  Please do not include goal<br/>states into document output unless you really know what you are doing!<br/><br/>* proper indentation of antiquoted output with proportional LaTeX<br/>fonts;<br/><br/>* no_document ML operator temporarily disables LaTeX document<br/>generation;<br/><br/>* isatool unsymbolize tunes sources for plain ASCII communication;<br/><br/><br/>*** Isar ***<br/><br/>* Pure: Isar now suffers initial goal statements to contain unbound<br/>schematic variables (this does not conform to actual readable proof<br/>documents, due to unpredictable outcome and non-compositional proof<br/>checking); users who know what they are doing may use schematic goals<br/>for Prolog-style synthesis of proven results;<br/><br/>* Pure: assumption method (an implicit finishing) now handles actual<br/>rules as well;<br/><br/>* Pure: improved &#39;obtain&#39; --- moved to Pure, insert &quot;that&quot; into<br/>initial goal, declare &quot;that&quot; only as Pure intro (only for single<br/>steps); the &quot;that&quot; rule assumption may now be involved in implicit<br/>finishing, thus &quot;..&quot; becomes a feasible for trivial obtains;<br/><br/>* Pure: default proof step now includes &#39;intro_classes&#39;; thus trivial<br/>instance proofs may be performed by &quot;..&quot;;<br/><br/>* Pure: ?thesis / ?this / &quot;...&quot; now work for pure meta-level<br/>statements as well;<br/><br/>* Pure: more robust selection of calculational rules;<br/><br/>* Pure: the builtin notion of &#39;finished&#39; goal now includes the ==-refl<br/>rule (as well as the assumption rule);<br/><br/>* Pure: &#39;thm_deps&#39; command visualizes dependencies of theorems and<br/>lemmas, using the graph browser tool;<br/><br/>* Pure: predict failure of &quot;show&quot; in interactive mode;<br/><br/>* Pure: &#39;thms_containing&#39; now takes actual terms as arguments;<br/><br/>* HOL: improved method &#39;induct&#39; --- now handles non-atomic goals<br/>(potential INCOMPATIBILITY); tuned error handling;<br/><br/>* HOL: cases and induct rules now provide explicit hints about the<br/>number of facts to be consumed (0 for &quot;type&quot; and 1 for &quot;set&quot; rules);<br/>any remaining facts are inserted into the goal verbatim;<br/><br/>* HOL: local contexts (aka cases) may now contain term bindings as<br/>well; the &#39;cases&#39; and &#39;induct&#39; methods new provide a ?case binding for<br/>the result to be shown in each case;<br/><br/>* HOL: added &#39;recdef_tc&#39; command;<br/><br/>* isatool convert assists in eliminating legacy ML scripts;<br/><br/><br/>*** HOL ***<br/><br/>* HOL/Library: a collection of generic theories to be used together<br/>with main HOL; the theory loader path already includes this directory<br/>by default; the following existing theories have been moved here:<br/>HOL/Induct/Multiset, HOL/Induct/Acc (as Accessible_Part), HOL/While<br/>(as While_Combinator), HOL/Lex/Prefix (as List_Prefix);<br/><br/>* HOL/Unix: &quot;Some aspects of Unix file-system security&quot;, a typical<br/>modelling and verification task performed in Isabelle/HOL +<br/>Isabelle/Isar + Isabelle document preparation (by Markus Wenzel).<br/><br/>* HOL/Algebra: special summation operator SUM no longer exists, it has<br/>been replaced by setsum; infix &#39;assoc&#39; now has priority 50 (like<br/>&#39;dvd&#39;); axiom &#39;one_not_zero&#39; has been moved from axclass &#39;ring&#39; to<br/>&#39;domain&#39;, this makes the theory consistent with mathematical<br/>literature;<br/><br/>* HOL basics: added overloaded operations &quot;inverse&quot; and &quot;divide&quot;<br/>(infix &quot;/&quot;), syntax for generic &quot;abs&quot; operation, generic summation<br/>operator ∑;<br/><br/>* HOL/typedef: simplified package, provide more useful rules (see also<br/>HOL/subset.thy);<br/><br/>* HOL/datatype: induction rule for arbitrarily branching datatypes is<br/>now expressed as a proper nested rule (old-style tactic scripts may<br/>require atomize_strip_tac to cope with non-atomic premises);<br/><br/>* HOL: renamed theory &quot;Prod&quot; to &quot;Product_Type&quot;, renamed &quot;split&quot; rule<br/>to &quot;split_conv&quot; (old name still available for compatibility);<br/><br/>* HOL: improved concrete syntax for strings (e.g. allows translation<br/>rules with string literals);<br/><br/>* HOL-Real-Hyperreal: this extends HOL-Real with the hyperreals<br/> and Fleuriot&#39;s mechanization of analysis, including the transcendental<br/> functions for the reals;<br/><br/>* HOL/Real, HOL/Hyperreal: improved arithmetic simplification;<br/><br/><br/>*** CTT ***<br/><br/>* CTT: x-symbol support for Pi, Sigma, --&gt;, : (membership); note that<br/>&quot;lam&quot; is displayed as TWO lambda-symbols<br/><br/>* CTT: theory Main now available, containing everything (that is, Bool<br/>and Arith);<br/><br/><br/>*** General ***<br/><br/>* Pure: the Simplifier has been implemented properly as a derived rule<br/>outside of the actual kernel (at last!); the overall performance<br/>penalty in practical applications is about 50%, while reliability of<br/>the Isabelle inference kernel has been greatly improved;<br/><br/>* print modes &quot;brackets&quot; and &quot;no_brackets&quot; control output of nested =&gt;<br/>(types) and ==&gt; (props); the default behaviour is &quot;brackets&quot;;<br/><br/>* Provers: fast_tac (and friends) now handle actual object-logic rules<br/>as assumptions as well;<br/><br/>* system: support Poly/ML 4.0;<br/><br/>* system: isatool install handles KDE version 1 or 2;<br/><br/><br/><br/>New in Isabelle99-1 (October 2000)<br/>----------------------------------<br/><br/>*** Overview of INCOMPATIBILITIES ***<br/><br/>* HOL: simplification of natural numbers is much changed; to partly<br/>recover the old behaviour (e.g. to prevent n+n rewriting to #2*n)<br/>issue the following ML commands:<br/><br/>  Delsimprocs Nat_Numeral_Simprocs.cancel_numerals;<br/>  Delsimprocs [Nat_Numeral_Simprocs.combine_numerals];<br/><br/>* HOL: simplification no longer dives into case-expressions; this is<br/>controlled by &quot;t.weak_case_cong&quot; for each datatype t;<br/><br/>* HOL: nat_less_induct renamed to less_induct;<br/><br/>* HOL: systematic renaming of the SOME (Eps) rules, may use isatool<br/>fixsome to patch .thy and .ML sources automatically;<br/><br/>  select_equality  -&gt; some_equality<br/>  select_eq_Ex     -&gt; some_eq_ex<br/>  selectI2EX       -&gt; someI2_ex<br/>  selectI2         -&gt; someI2<br/>  selectI          -&gt; someI<br/>  select1_equality -&gt; some1_equality<br/>  Eps_sym_eq       -&gt; some_sym_eq_trivial<br/>  Eps_eq           -&gt; some_eq_trivial<br/><br/>* HOL: exhaust_tac on datatypes superceded by new generic case_tac;<br/><br/>* HOL: removed obsolete theorem binding expand_if (refer to split_if<br/>instead);<br/><br/>* HOL: the recursion equations generated by &#39;recdef&#39; are now called<br/>f.simps instead of f.rules;<br/><br/>* HOL: qed_spec_mp now also handles bounded ALL as well;<br/><br/>* HOL: 0 is now overloaded, so the type constraint &quot;:: nat&quot; may<br/>sometimes be needed;<br/><br/>* HOL: the constant for &quot;f``x&quot; is now &quot;image&quot; rather than &quot;op ``&quot;;<br/><br/>* HOL: the constant for &quot;f-``x&quot; is now &quot;vimage&quot; rather than &quot;op -``&quot;;<br/><br/>* HOL: the disjoint sum is now &quot;&lt;+&gt;&quot; instead of &quot;Plus&quot;; the cartesian<br/>product is now &quot;&lt;*&gt;&quot; instead of &quot;Times&quot;; the lexicographic product is<br/>now &quot;&lt;*lex*&gt;&quot; instead of &quot;**&quot;;<br/><br/>* HOL: theory Sexp is now in HOL/Induct examples (it used to be part<br/>of main HOL, but was unused); better use HOL&#39;s datatype package;<br/><br/>* HOL: removed &quot;symbols&quot; syntax for constant &quot;override&quot; of theory Map;<br/>the old syntax may be recovered as follows:<br/><br/>  syntax (symbols)<br/>    override  :: &quot;(&#39;a ~=&gt; &#39;b) =&gt; (&#39;a ~=&gt; &#39;b) =&gt; (&#39;a ~=&gt; &#39;b)&quot;<br/>      (infixl &quot;\⊕&quot; 100)<br/><br/>* HOL/Real: &quot;rabs&quot; replaced by overloaded &quot;abs&quot; function;<br/><br/>* HOL/ML: even fewer consts are declared as global (see theories Ord,<br/>Lfp, Gfp, WF); this only affects ML packages that refer to const names<br/>internally;<br/><br/>* HOL and ZF: syntax for quotienting wrt an equivalence relation<br/>changed from A/r to A//r;<br/><br/>* ZF: new treatment of arithmetic (nat &amp; int) may break some old<br/>proofs;<br/><br/>* Isar: renamed some attributes (RS -&gt; THEN, simplify -&gt; simplified,<br/>rulify -&gt; rule_format, elimify -&gt; elim_format, ...);<br/><br/>* Isar/Provers: intro/elim/dest attributes changed; renamed<br/>intro/intro!/intro!! flags to intro!/intro/intro? (in most cases, one<br/>should have to change intro!! to intro? only); replaced &quot;delrule&quot; by<br/>&quot;rule del&quot;;<br/><br/>* Isar/HOL: renamed &quot;intrs&quot; to &quot;intros&quot; in inductive definitions;<br/><br/>* Provers: strengthened force_tac by using new first_best_tac;<br/><br/>* LaTeX document preparation: several changes of isabelle.sty (see<br/>lib/texinputs);<br/><br/><br/>*** Document preparation ***<br/><br/>* formal comments (text blocks etc.) in new-style theories may now<br/>contain antiquotations of thm/prop/term/typ/text to be presented<br/>according to latex print mode; concrete syntax is like this:<br/>@{term[show_types] &quot;f(x) = a + x&quot;};<br/><br/>* isatool mkdir provides easy setup of Isabelle session directories,<br/>including proper document sources;<br/><br/>* generated LaTeX sources are now deleted after successful run<br/>(isatool document -c); may retain a copy somewhere else via -D option<br/>of isatool usedir;<br/><br/>* isatool usedir -D now lets isatool latex -o sty update the Isabelle<br/>style files, achieving self-contained LaTeX sources and simplifying<br/>LaTeX debugging;<br/><br/>* old-style theories now produce (crude) LaTeX output as well;<br/><br/>* browser info session directories are now self-contained (may be put<br/>on WWW server seperately); improved graphs of nested sessions; removed<br/>graph for &#39;all sessions&#39;;<br/><br/>* several improvements in isabelle style files; \isabellestyle{it}<br/>produces fake math mode output; \isamarkupheader is now \section by<br/>default; see lib/texinputs/isabelle.sty etc.;<br/><br/><br/>*** Isar ***<br/><br/>* Isar/Pure: local results and corresponding term bindings are now<br/>subject to Hindley-Milner polymorphism (similar to ML); this<br/>accommodates incremental type-inference very nicely;<br/><br/>* Isar/Pure: new derived language element &#39;obtain&#39; supports<br/>generalized existence reasoning;<br/><br/>* Isar/Pure: new calculational elements &#39;moreover&#39; and &#39;ultimately&#39;<br/>support accumulation of results, without applying any rules yet;<br/>useful to collect intermediate results without explicit name<br/>references, and for use with transitivity rules with more than 2<br/>premises;<br/><br/>* Isar/Pure: scalable support for case-analysis type proofs: new<br/>&#39;case&#39; language element refers to local contexts symbolically, as<br/>produced by certain proof methods; internally, case names are attached<br/>to theorems as &quot;tags&quot;;<br/><br/>* Isar/Pure: theory command &#39;hide&#39; removes declarations from<br/>class/type/const name spaces;<br/><br/>* Isar/Pure: theory command &#39;defs&#39; supports option &quot;(overloaded)&quot; to<br/>indicate potential overloading;<br/><br/>* Isar/Pure: changed syntax of local blocks from {{ }} to { };<br/><br/>* Isar/Pure: syntax of sorts made &#39;inner&#39;, i.e. have to write<br/>&quot;{a,b,c}&quot; instead of {a,b,c};<br/><br/>* Isar/Pure now provides its own version of intro/elim/dest<br/>attributes; useful for building new logics, but beware of confusion<br/>with the version in Provers/classical;<br/><br/>* Isar/Pure: the local context of (non-atomic) goals is provided via<br/>case name &#39;antecedent&#39;;<br/><br/>* Isar/Pure: removed obsolete &#39;transfer&#39; attribute (transfer of thms<br/>to the current context is now done automatically);<br/><br/>* Isar/Pure: theory command &#39;method_setup&#39; provides a simple interface<br/>for definining proof methods in ML;<br/><br/>* Isar/Provers: intro/elim/dest attributes changed; renamed<br/>intro/intro!/intro!! flags to intro!/intro/intro? (INCOMPATIBILITY, in<br/>most cases, one should have to change intro!! to intro? only);<br/>replaced &quot;delrule&quot; by &quot;rule del&quot;;<br/><br/>* Isar/Provers: new &#39;hypsubst&#39; method, plain &#39;subst&#39; method and<br/>&#39;symmetric&#39; attribute (the latter supercedes [RS sym]);<br/><br/>* Isar/Provers: splitter support (via &#39;split&#39; attribute and &#39;simp&#39;<br/>method modifier); &#39;simp&#39; method: &#39;only:&#39; modifier removes loopers as<br/>well (including splits);<br/><br/>* Isar/Provers: Simplifier and Classical methods now support all kind<br/>of modifiers used in the past, including &#39;cong&#39;, &#39;iff&#39;, etc.<br/><br/>* Isar/Provers: added &#39;fastsimp&#39; and &#39;clarsimp&#39; methods (combination<br/>of Simplifier and Classical reasoner);<br/><br/>* Isar/HOL: new proof method &#39;cases&#39; and improved version of &#39;induct&#39;<br/>now support named cases; major packages (inductive, datatype, primrec,<br/>recdef) support case names and properly name parameters;<br/><br/>* Isar/HOL: new transitivity rules for substitution in inequalities --<br/>monotonicity conditions are extracted to be proven at end of<br/>calculations;<br/><br/>* Isar/HOL: removed &#39;case_split&#39; thm binding, should use &#39;cases&#39; proof<br/>method anyway;<br/><br/>* Isar/HOL: removed old expand_if = split_if; theorems if_splits =<br/>split_if split_if_asm; datatype package provides theorems foo.splits =<br/>foo.split foo.split_asm for each datatype;<br/><br/>* Isar/HOL: tuned inductive package, rename &quot;intrs&quot; to &quot;intros&quot;<br/>(potential INCOMPATIBILITY), emulation of mk_cases feature for proof<br/>scripts: new &#39;inductive_cases&#39; command and &#39;ind_cases&#39; method; (Note:<br/>use &quot;(cases (simplified))&quot; method in proper proof texts);<br/><br/>* Isar/HOL: added global &#39;arith_split&#39; attribute for &#39;arith&#39; method;<br/><br/>* Isar: names of theorems etc. may be natural numbers as well;<br/><br/>* Isar: &#39;pr&#39; command: optional arguments for goals_limit and<br/>ProofContext.prems_limit; no longer prints theory contexts, but only<br/>proof states;<br/><br/>* Isar: diagnostic commands &#39;pr&#39;, &#39;thm&#39;, &#39;prop&#39;, &#39;term&#39;, &#39;typ&#39; admit<br/>additional print modes to be specified; e.g. &quot;pr(latex)&quot; will print<br/>proof state according to the Isabelle LaTeX style;<br/><br/>* Isar: improved support for emulating tactic scripts, including proof<br/>methods &#39;rule_tac&#39; etc., &#39;cut_tac&#39;, &#39;thin_tac&#39;, &#39;subgoal_tac&#39;,<br/>&#39;rename_tac&#39;, &#39;rotate_tac&#39;, &#39;tactic&#39;, and &#39;case_tac&#39; / &#39;induct_tac&#39;<br/>(for HOL datatypes);<br/><br/>* Isar: simplified (more robust) goal selection of proof methods: 1st<br/>goal, all goals, or explicit goal specifier (tactic emulation); thus<br/>&#39;proof method scripts&#39; have to be in depth-first order;<br/><br/>* Isar: tuned &#39;let&#39; syntax: replaced &#39;as&#39; keyword by &#39;and&#39;;<br/><br/>* Isar: removed &#39;help&#39; command, which hasn&#39;t been too helpful anyway;<br/>should instead use individual commands for printing items<br/>(print_commands, print_methods etc.);<br/><br/>* Isar: added &#39;nothing&#39; --- the empty list of theorems;<br/><br/><br/>*** HOL ***<br/><br/>* HOL/MicroJava: formalization of a fragment of Java, together with a<br/>corresponding virtual machine and a specification of its bytecode<br/>verifier and a lightweight bytecode verifier, including proofs of<br/>type-safety; by Gerwin Klein, Tobias Nipkow, David von Oheimb, and<br/>Cornelia Pusch (see also the homepage of project Bali at<br/>http://isabelle.in.tum.de/Bali/);<br/><br/>* HOL/Algebra: new theory of rings and univariate polynomials, by<br/>Clemens Ballarin;<br/><br/>* HOL/NumberTheory: fundamental Theorem of Arithmetic, Chinese<br/>Remainder Theorem, Fermat/Euler Theorem, Wilson&#39;s Theorem, by Thomas M<br/>Rasmussen;<br/><br/>* HOL/Lattice: fundamental concepts of lattice theory and order<br/>structures, including duals, properties of bounds versus algebraic<br/>laws, lattice operations versus set-theoretic ones, the Knaster-Tarski<br/>Theorem for complete lattices etc.; may also serve as a demonstration<br/>for abstract algebraic reasoning using axiomatic type classes, and<br/>mathematics-style proof in Isabelle/Isar; by Markus Wenzel;<br/><br/>* HOL/Prolog: a (bare-bones) implementation of Lambda-Prolog, by David<br/>von Oheimb;<br/><br/>* HOL/IMPP: extension of IMP with local variables and mutually<br/>recursive procedures, by David von Oheimb;<br/><br/>* HOL/Lambda: converted into new-style theory and document;<br/><br/>* HOL/ex/Multiquote: example of multiple nested quotations and<br/>anti-quotations -- basically a generalized version of de-Bruijn<br/>representation; very useful in avoiding lifting of operations;<br/><br/>* HOL/record: added general record equality rule to simpset; fixed<br/>select-update simplification procedure to handle extended records as<br/>well; admit &quot;r&quot; as field name;<br/><br/>* HOL: 0 is now overloaded over the new sort &quot;zero&quot;, allowing its use with<br/>other numeric types and also as the identity of groups, rings, etc.;<br/><br/>* HOL: new axclass plus_ac0 for addition with the AC-laws and 0 as identity.<br/>Types nat and int belong to this axclass;<br/><br/>* HOL: greatly improved simplification involving numerals of type nat, int, real:<br/>   (i + #8 + j) = Suc k simplifies to  #7 + (i + j) = k<br/>   i*j + k + j*#3*i     simplifies to  #4*(i*j) + k<br/>  two terms #m*u and #n*u are replaced by #(m+n)*u<br/>    (where #m, #n and u can implicitly be 1; this is simproc combine_numerals)<br/>  and the term/formula #m*u+x ~~ #n*u+y simplifies simplifies to #(m-n)+x ~~ y<br/>    or x ~~ #(n-m)+y, where ~~ is one of = &lt; &lt;= or - (simproc cancel_numerals);<br/><br/>* HOL: meson_tac is available (previously in ex/meson.ML); it is a<br/>powerful prover for predicate logic but knows nothing of clasets; see<br/>ex/mesontest.ML and ex/mesontest2.ML for example applications;<br/><br/>* HOL: new version of &quot;case_tac&quot; subsumes both boolean case split and<br/>&quot;exhaust_tac&quot; on datatypes; INCOMPATIBILITY: exhaust_tac no longer<br/>exists, may define val exhaust_tac = case_tac for ad-hoc portability;<br/><br/>* HOL: simplification no longer dives into case-expressions: only the<br/>selector expression is simplified, but not the remaining arms; to<br/>enable full simplification of case-expressions for datatype t, you may<br/>remove t.weak_case_cong from the simpset, either globally (Delcongs<br/>[thm&quot;t.weak_case_cong&quot;];) or locally (delcongs [...]).<br/><br/>* HOL/recdef: the recursion equations generated by &#39;recdef&#39; for<br/>function &#39;f&#39; are now called f.simps instead of f.rules; if all<br/>termination conditions are proved automatically, these simplification<br/>rules are added to the simpset, as in primrec; rules may be named<br/>individually as well, resulting in a separate list of theorems for<br/>each equation;<br/><br/>* HOL/While is a new theory that provides a while-combinator. It<br/>permits the definition of tail-recursive functions without the<br/>provision of a termination measure. The latter is necessary once the<br/>invariant proof rule for while is applied.<br/><br/>* HOL: new (overloaded) notation for the set of elements below/above<br/>some element: {..u}, {..u(}, {l..}, {)l..}. See theory SetInterval.<br/><br/>* HOL: theorems impI, allI, ballI bound as &quot;strip&quot;;<br/><br/>* HOL: new tactic induct_thm_tac: thm -&gt; string -&gt; int -&gt; tactic<br/>induct_tac th &quot;x1 ... xn&quot; expects th to have a conclusion of the form<br/>P v1 ... vn and abbreviates res_inst_tac [(&quot;v1&quot;,&quot;x1&quot;),...,(&quot;vn&quot;,&quot;xn&quot;)] th;<br/><br/>* HOL/Real: &quot;rabs&quot; replaced by overloaded &quot;abs&quot; function;<br/><br/>* HOL: theory Sexp now in HOL/Induct examples (it used to be part of<br/>main HOL, but was unused);<br/><br/>* HOL: fewer consts declared as global (e.g. have to refer to<br/>&quot;Lfp.lfp&quot; instead of &quot;lfp&quot; internally; affects ML packages only);<br/><br/>* HOL: tuned AST representation of nested pairs, avoiding bogus output<br/>in case of overlap with user translations (e.g. judgements over<br/>tuples); (note that the underlying logical represenation is still<br/>bogus);<br/><br/><br/>*** ZF ***<br/><br/>* ZF: simplification automatically cancels common terms in arithmetic<br/>expressions over nat and int;<br/><br/>* ZF: new treatment of nat to minimize type-checking: all operators<br/>coerce their operands to a natural number using the function natify,<br/>making the algebraic laws unconditional;<br/><br/>* ZF: as above, for int: operators coerce their operands to an integer<br/>using the function intify;<br/><br/>* ZF: the integer library now contains many of the usual laws for the<br/>orderings, including $&lt;=, and monotonicity laws for $+ and $*;<br/><br/>* ZF: new example ZF/ex/NatSum to demonstrate integer arithmetic<br/>simplification;<br/><br/>* FOL and ZF: AddIffs now available, giving theorems of the form P&lt;-&gt;Q<br/>to the simplifier and classical reasoner simultaneously;<br/><br/><br/>*** General ***<br/><br/>* Provers: blast_tac now handles actual object-logic rules as<br/>assumptions; note that auto_tac uses blast_tac internally as well;<br/><br/>* Provers: new functions rulify/rulify_no_asm: thm -&gt; thm for turning<br/>outer --&gt;/All/Ball into ==&gt;/!!; qed_spec_mp now uses rulify_no_asm;<br/><br/>* Provers: delrules now handles destruct rules as well (no longer need<br/>explicit make_elim);<br/><br/>* Provers: Blast_tac now warns of and ignores &quot;weak elimination rules&quot; e.g.<br/>  [| inj ?f;          ?f ?x = ?f ?y; ?x = ?y ==&gt; ?W |] ==&gt; ?W<br/>use instead the strong form,<br/>  [| inj ?f; ~ ?W ==&gt; ?f ?x = ?f ?y; ?x = ?y ==&gt; ?W |] ==&gt; ?W<br/>in HOL, FOL and ZF the function cla_make_elim will create such rules<br/>from destruct-rules;<br/><br/>* Provers: Simplifier.easy_setup provides a fast path to basic<br/>Simplifier setup for new object-logics;<br/><br/>* Pure: AST translation rules no longer require constant head on LHS;<br/><br/>* Pure: improved name spaces: ambiguous output is qualified; support<br/>for hiding of names;<br/><br/>* system: smart setup of canonical ML_HOME, ISABELLE_INTERFACE, and<br/>XSYMBOL_HOME; no longer need to do manual configuration in most<br/>situations;<br/><br/>* system: compression of ML heaps images may now be controlled via -c<br/>option of isabelle and isatool usedir (currently only observed by<br/>Poly/ML);<br/><br/>* system: isatool installfonts may handle X-Symbol fonts as well (very<br/>useful for remote X11);<br/><br/>* system: provide TAGS file for Isabelle sources;<br/><br/>* ML: infix &#39;OF&#39; is a version of &#39;MRS&#39; with more appropriate argument<br/>order;<br/><br/>* ML: renamed flags Syntax.trace_norm_ast to Syntax.trace_ast; global<br/>timing flag supersedes proof_timing and Toplevel.trace;<br/><br/>* ML: new combinators |&gt;&gt; and |&gt;&gt;&gt; for incremental transformations<br/>with secondary results (e.g. certain theory extensions):<br/><br/>* ML: PureThy.add_defs gets additional argument to indicate potential<br/>overloading (usually false);<br/><br/>* ML: PureThy.add_thms/add_axioms/add_defs now return theorems as<br/>results;<br/><br/><br/><br/>New in Isabelle99 (October 1999)<br/>--------------------------------<br/><br/>*** Overview of INCOMPATIBILITIES (see below for more details) ***<br/><br/>* HOL: The THEN and ELSE parts of conditional expressions (if P then x else y)<br/>are no longer simplified.  (This allows the simplifier to unfold recursive<br/>functional programs.)  To restore the old behaviour, declare<br/><br/>    Delcongs [if_weak_cong];<br/><br/>* HOL: Removed the obsolete syntax &quot;Compl A&quot;; use -A for set<br/>complement;<br/><br/>* HOL: the predicate &quot;inj&quot; is now defined by translation to &quot;inj_on&quot;;<br/><br/>* HOL/datatype: mutual_induct_tac no longer exists --<br/>  use induct_tac &quot;x_1 ... x_n&quot; instead of mutual_induct_tac [&quot;x_1&quot;, ..., &quot;x_n&quot;]<br/><br/>* HOL/typedef: fixed type inference for representing set; type<br/>arguments now have to occur explicitly on the rhs as type constraints;<br/><br/>* ZF: The con_defs part of an inductive definition may no longer refer<br/>to constants declared in the same theory;<br/><br/>* HOL, ZF: the function mk_cases, generated by the inductive<br/>definition package, has lost an argument.  To simplify its result, it<br/>uses the default simpset instead of a supplied list of theorems.<br/><br/>* HOL/List: the constructors of type list are now Nil and Cons;<br/><br/>* Simplifier: the type of the infix ML functions<br/>        setSSolver addSSolver setSolver addSolver<br/>is now  simpset * solver -&gt; simpset  where `solver&#39; is a new abstract type<br/>for packaging solvers. A solver is created via<br/>        mk_solver: string -&gt; (thm list -&gt; int -&gt; tactic) -&gt; solver<br/>where the string argument is only a comment.<br/><br/><br/>*** Proof tools ***<br/><br/>* Provers/Arith/fast_lin_arith.ML contains a functor for creating a<br/>decision procedure for linear arithmetic. Currently it is used for<br/>types `nat&#39;, `int&#39;, and `real&#39; in HOL (see below); it can, should and<br/>will be instantiated for other types and logics as well.<br/><br/>* The simplifier now accepts rewrite rules with flexible heads, eg<br/>     hom ?f ==&gt; ?f(?x+?y) = ?f ?x + ?f ?y<br/>  They are applied like any rule with a non-pattern lhs, i.e. by first-order<br/>  matching.<br/><br/><br/>*** General ***<br/><br/>* New Isabelle/Isar subsystem provides an alternative to traditional<br/>tactical theorem proving; together with the ProofGeneral/isar user<br/>interface it offers an interactive environment for developing human<br/>readable proof documents (Isar == Intelligible semi-automated<br/>reasoning); for further information see isatool doc isar-ref,<br/>src/HOL/Isar_examples and http://isabelle.in.tum.de/Isar/<br/><br/>* improved and simplified presentation of theories: better HTML markup<br/>(including colors), graph views in several sizes; isatool usedir now<br/>provides a proper interface for user theories (via -P option); actual<br/>document preparation based on (PDF)LaTeX is available as well (for<br/>new-style theories only); see isatool doc system for more information;<br/><br/>* native support for Proof General, both for classic Isabelle and<br/>Isabelle/Isar;<br/><br/>* ML function thm_deps visualizes dependencies of theorems and lemmas,<br/>using the graph browser tool;<br/><br/>* Isabelle manuals now also available as PDF;<br/><br/>* theory loader rewritten from scratch (may not be fully<br/>bug-compatible); old loadpath variable has been replaced by show_path,<br/>add_path, del_path, reset_path functions; new operations such as<br/>update_thy, touch_thy, remove_thy, use/update_thy_only (see also<br/>isatool doc ref);<br/><br/>* improved isatool install: option -k creates KDE application icon,<br/>option -p DIR installs standalone binaries;<br/><br/>* added ML_PLATFORM setting (useful for cross-platform installations);<br/>more robust handling of platform specific ML images for SML/NJ;<br/><br/>* the settings environment is now statically scoped, i.e. it is never<br/>created again in sub-processes invoked from isabelle, isatool, or<br/>Isabelle;<br/><br/>* path element specification &#39;~~&#39; refers to &#39;$ISABELLE_HOME&#39;;<br/><br/>* in locales, the &quot;assumes&quot; and &quot;defines&quot; parts may be omitted if<br/>empty;<br/><br/>* new print_mode &quot;xsymbols&quot; for extended symbol support (e.g. genuine<br/>long arrows);<br/><br/>* new print_mode &quot;HTML&quot;;<br/><br/>* new flag show_tags controls display of tags of theorems (which are<br/>basically just comments that may be attached by some tools);<br/><br/>* Isamode 2.6 requires patch to accomodate change of Isabelle font<br/>mode and goal output format:<br/><br/>diff -r Isamode-2.6/elisp/isa-load.el Isamode/elisp/isa-load.el<br/>244c244<br/>&lt;       (list (isa-getenv &quot;ISABELLE&quot;) &quot;-msymbols&quot; logic-name)<br/>---<br/>&gt;       (list (isa-getenv &quot;ISABELLE&quot;) &quot;-misabelle_font&quot; &quot;-msymbols&quot; logic-name)<br/>diff -r Isabelle-2.6/elisp/isa-proofstate.el Isamode/elisp/isa-proofstate.el<br/>181c181<br/>&lt; (defconst proofstate-proofstart-regexp &quot;^Level [0-9]+$&quot;<br/>---<br/>&gt; (defconst proofstate-proofstart-regexp &quot;^Level [0-9]+&quot;<br/><br/>* function bind_thms stores lists of theorems (cf. bind_thm);<br/><br/>* new shorthand tactics ftac, eatac, datac, fatac;<br/><br/>* qed (and friends) now accept &quot;&quot; as result name; in that case the<br/>theorem is not stored, but proper checks and presentation of the<br/>result still apply;<br/><br/>* theorem database now also indexes constants &quot;Trueprop&quot;, &quot;all&quot;,<br/>&quot;==&gt;&quot;, &quot;==&quot;; thus thms_containing, findI etc. may retrieve more rules;<br/><br/><br/>*** HOL ***<br/><br/>** HOL arithmetic **<br/><br/>* There are now decision procedures for linear arithmetic over nat and<br/>int:<br/><br/>1. arith_tac copes with arbitrary formulae involving `=&#39;, `&lt;&#39;, `&lt;=&#39;,<br/>`+&#39;, `-&#39;, `Suc&#39;, `min&#39;, `max&#39; and numerical constants; other subterms<br/>are treated as atomic; subformulae not involving type `nat&#39; or `int&#39;<br/>are ignored; quantified subformulae are ignored unless they are<br/>positive universal or negative existential. The tactic has to be<br/>invoked by hand and can be a little bit slow. In particular, the<br/>running time is exponential in the number of occurrences of `min&#39; and<br/>`max&#39;, and `-&#39; on `nat&#39;.<br/><br/>2. fast_arith_tac is a cut-down version of arith_tac: it only takes<br/>(negated) (in)equalities among the premises and the conclusion into<br/>account (i.e. no compound formulae) and does not know about `min&#39; and<br/>`max&#39;, and `-&#39; on `nat&#39;. It is fast and is used automatically by the<br/>simplifier.<br/><br/>NB: At the moment, these decision procedures do not cope with mixed<br/>nat/int formulae where the two parts interact, such as `m &lt; n ==&gt;<br/>int(m) &lt; int(n)&#39;.<br/><br/>* HOL/Numeral provides a generic theory of numerals (encoded<br/>efficiently as bit strings); setup for types nat/int/real is in place;<br/>INCOMPATIBILITY: since numeral syntax is now polymorphic, rather than<br/>int, existing theories and proof scripts may require a few additional<br/>type constraints;<br/><br/>* integer division and remainder can now be performed on constant<br/>arguments;<br/><br/>* many properties of integer multiplication, division and remainder<br/>are now available;<br/><br/>* An interface to the Stanford Validity Checker (SVC) is available through the<br/>tactic svc_tac.  Propositional tautologies and theorems of linear arithmetic<br/>are proved automatically.  SVC must be installed separately, and its results<br/>must be TAKEN ON TRUST (Isabelle does not check the proofs, but tags any<br/>invocation of the underlying oracle).  For SVC see<br/>  http://verify.stanford.edu/SVC<br/><br/>* IsaMakefile: the HOL-Real target now builds an actual image;<br/><br/><br/>** HOL misc **<br/><br/>* HOL/Real/HahnBanach: the Hahn-Banach theorem for real vector spaces<br/>(in Isabelle/Isar) -- by Gertrud Bauer;<br/><br/>* HOL/BCV: generic model of bytecode verification, i.e. data-flow<br/>analysis for assembly languages with subtypes;<br/><br/>* HOL/TLA (Lamport&#39;s Temporal Logic of Actions): major reorganization<br/>-- avoids syntactic ambiguities and treats state, transition, and<br/>temporal levels more uniformly; introduces INCOMPATIBILITIES due to<br/>changed syntax and (many) tactics;<br/><br/>* HOL/inductive: Now also handles more general introduction rules such<br/>  as &quot;ALL y. (y, x) : r --&gt; y : acc r ==&gt; x : acc r&quot;; monotonicity<br/>  theorems are now maintained within the theory (maintained via the<br/>  &quot;mono&quot; attribute);<br/><br/>* HOL/datatype: Now also handles arbitrarily branching datatypes<br/>  (using function types) such as<br/><br/>  datatype &#39;a tree = Atom &#39;a | Branch &quot;nat =&gt; &#39;a tree&quot;<br/><br/>* HOL/record: record_simproc (part of the default simpset) takes care<br/>of selectors applied to updated records; record_split_tac is no longer<br/>part of the default claset; update_defs may now be removed from the<br/>simpset in many cases; COMPATIBILITY: old behavior achieved by<br/><br/>  claset_ref () := claset() addSWrapper record_split_wrapper;<br/>  Delsimprocs [record_simproc]<br/><br/>* HOL/typedef: fixed type inference for representing set; type<br/>arguments now have to occur explicitly on the rhs as type constraints;<br/><br/>* HOL/recdef (TFL): &#39;congs&#39; syntax now expects comma separated list of theorem<br/>names rather than an ML expression;<br/><br/>* HOL/defer_recdef (TFL): like recdef but the well-founded relation can be<br/>supplied later.  Program schemes can be defined, such as<br/>    &quot;While B C s = (if B s then While B C (C s) else s)&quot;<br/>where the well-founded relation can be chosen after B and C have been given.<br/><br/>* HOL/List: the constructors of type list are now Nil and Cons;<br/>INCOMPATIBILITY: while [] and infix # syntax is still there, of<br/>course, ML tools referring to List.list.op # etc. have to be adapted;<br/><br/>* HOL_quantifiers flag superseded by &quot;HOL&quot; print mode, which is<br/>disabled by default; run isabelle with option -m HOL to get back to<br/>the original Gordon/HOL-style output;<br/><br/>* HOL/Ord.thy: new bounded quantifier syntax (input only): ALL x&lt;y. P,<br/>ALL x&lt;=y. P, EX x&lt;y. P, EX x&lt;=y. P;<br/><br/>* HOL basic syntax simplified (more orthogonal): all variants of<br/>All/Ex now support plain / symbolic / HOL notation; plain syntax for<br/>Eps operator is provided as well: &quot;SOME x. P[x]&quot;;<br/><br/>* HOL/Sum.thy: sum_case has been moved to HOL/Datatype;<br/><br/>* HOL/Univ.thy: infix syntax &lt;*&gt;, &lt;+&gt;, &lt;**&gt;, &lt;+&gt; eliminated and made<br/>thus available for user theories;<br/><br/>* HOLCF/IOA/Sequents: renamed &#39;Cons&#39; to &#39;Consq&#39; to avoid clash with<br/>HOL/List; hardly an INCOMPATIBILITY since &#39;&gt;&gt;&#39; syntax is used all the<br/>time;<br/><br/>* HOL: new tactic smp_tac: int -&gt; int -&gt; tactic, which applies spec<br/>several times and then mp;<br/><br/><br/>*** LK ***<br/><br/>* the notation &lt;&lt;...&gt;&gt; is now available as a notation for sequences of<br/>formulas;<br/><br/>* the simplifier is now installed<br/><br/>* the axiom system has been generalized (thanks to Soren Heilmann)<br/><br/>* the classical reasoner now has a default rule database<br/><br/><br/>*** ZF ***<br/><br/>* new primrec section allows primitive recursive functions to be given<br/>directly (as in HOL) over datatypes and the natural numbers;<br/><br/>* new tactics induct_tac and exhaust_tac for induction (or case<br/>analysis) over datatypes and the natural numbers;<br/><br/>* the datatype declaration of type T now defines the recursor T_rec;<br/><br/>* simplification automatically does freeness reasoning for datatype<br/>constructors;<br/><br/>* automatic type-inference, with AddTCs command to insert new<br/>type-checking rules;<br/><br/>* datatype introduction rules are now added as Safe Introduction rules<br/>to the claset;<br/><br/>* the syntax &quot;if P then x else y&quot; is now available in addition to<br/>if(P,x,y);<br/><br/><br/>*** Internal programming interfaces ***<br/><br/>* tuned simplifier trace output; new flag debug_simp;<br/><br/>* structures Vartab / Termtab (instances of TableFun) offer efficient<br/>tables indexed by indexname_ord / term_ord (compatible with aconv);<br/><br/>* AxClass.axclass_tac lost the theory argument;<br/><br/>* tuned current_goals_markers semantics: begin / end goal avoids<br/>printing empty lines;<br/><br/>* removed prs and prs_fn hook, which was broken because it did not<br/>include \n in its semantics, forcing writeln to add one<br/>uncoditionally; replaced prs_fn by writeln_fn; consider std_output:<br/>string -&gt; unit if you really want to output text without newline;<br/><br/>* Symbol.output subject to print mode; INCOMPATIBILITY: defaults to<br/>plain output, interface builders may have to enable &#39;isabelle_font&#39;<br/>mode to get Isabelle font glyphs as before;<br/><br/>* refined token_translation interface; INCOMPATIBILITY: output length<br/>now of type real instead of int;<br/><br/>* theory loader actions may be traced via new ThyInfo.add_hook<br/>interface (see src/Pure/Thy/thy_info.ML); example application: keep<br/>your own database of information attached to *whole* theories -- as<br/>opposed to intra-theory data slots offered via TheoryDataFun;<br/><br/>* proper handling of dangling sort hypotheses (at last!);<br/>Thm.strip_shyps and Drule.strip_shyps_warning take care of removing<br/>extra sort hypotheses that can be witnessed from the type signature;<br/>the force_strip_shyps flag is gone, any remaining shyps are simply<br/>left in the theorem (with a warning issued by strip_shyps_warning);<br/><br/><br/><br/>New in Isabelle98-1 (October 1998)<br/>----------------------------------<br/><br/>*** Overview of INCOMPATIBILITIES (see below for more details) ***<br/><br/>* several changes of automated proof tools;<br/><br/>* HOL: major changes to the inductive and datatype packages, including<br/>some minor incompatibilities of theory syntax;<br/><br/>* HOL: renamed r^-1 to &#39;converse&#39; from &#39;inverse&#39;; &#39;inj_onto&#39; is now<br/>called `inj_on&#39;;<br/><br/>* HOL: removed duplicate thms in Arith:<br/>  less_imp_add_less  should be replaced by  trans_less_add1<br/>  le_imp_add_le      should be replaced by  trans_le_add1<br/><br/>* HOL: unary minus is now overloaded (new type constraints may be<br/>required);<br/><br/>* HOL and ZF: unary minus for integers is now #- instead of #~.  In<br/>ZF, expressions such as n#-1 must be changed to n#- 1, since #-1 is<br/>now taken as an integer constant.<br/><br/>* Pure: ML function &#39;theory_of&#39; renamed to &#39;theory&#39;;<br/><br/><br/>*** Proof tools ***<br/><br/>* Simplifier:<br/>  1. Asm_full_simp_tac is now more aggressive.<br/>     1. It will sometimes reorient premises if that increases their power to<br/>        simplify.<br/>     2. It does no longer proceed strictly from left to right but may also<br/>        rotate premises to achieve further simplification.<br/>     For compatibility reasons there is now Asm_lr_simp_tac which is like the<br/>     old Asm_full_simp_tac in that it does not rotate premises.<br/>  2. The simplifier now knows a little bit about nat-arithmetic.<br/><br/>* Classical reasoner: wrapper mechanism for the classical reasoner now<br/>allows for selected deletion of wrappers, by introduction of names for<br/>wrapper functionals.  This implies that addbefore, addSbefore,<br/>addaltern, and addSaltern now take a pair (name, tactic) as argument,<br/>and that adding two tactics with the same name overwrites the first<br/>one (emitting a warning).<br/>  type wrapper = (int -&gt; tactic) -&gt; (int -&gt; tactic)<br/>  setWrapper, setSWrapper, compWrapper and compSWrapper are replaced by<br/>  addWrapper, addSWrapper: claset * (string * wrapper) -&gt; claset<br/>  delWrapper, delSWrapper: claset *  string            -&gt; claset<br/>  getWrapper is renamed to appWrappers, getSWrapper to appSWrappers;<br/><br/>* Classical reasoner: addbefore/addSbefore now have APPEND/ORELSE<br/>semantics; addbefore now affects only the unsafe part of step_tac<br/>etc.; this affects addss/auto_tac/force_tac, so EXISTING PROOFS MAY<br/>FAIL, but proofs should be fixable easily, e.g. by replacing Auto_tac<br/>by Force_tac;<br/><br/>* Classical reasoner: setwrapper to setWrapper and compwrapper to<br/>compWrapper; added safe wrapper (and access functions for it);<br/><br/>* HOL/split_all_tac is now much faster and fails if there is nothing<br/>to split.  Some EXISTING PROOFS MAY REQUIRE ADAPTION because the order<br/>and the names of the automatically generated variables have changed.<br/>split_all_tac has moved within claset() from unsafe wrappers to safe<br/>wrappers, which means that !!-bound variables are split much more<br/>aggressively, and safe_tac and clarify_tac now split such variables.<br/>If this splitting is not appropriate, use delSWrapper &quot;split_all_tac&quot;.<br/>Note: the same holds for record_split_tac, which does the job of<br/>split_all_tac for record fields.<br/><br/>* HOL/Simplifier: Rewrite rules for case distinctions can now be added<br/>permanently to the default simpset using Addsplits just like<br/>Addsimps. They can be removed via Delsplits just like<br/>Delsimps. Lower-case versions are also available.<br/><br/>* HOL/Simplifier: The rule split_if is now part of the default<br/>simpset. This means that the simplifier will eliminate all occurrences<br/>of if-then-else in the conclusion of a goal. To prevent this, you can<br/>either remove split_if completely from the default simpset by<br/>`Delsplits [split_if]&#39; or remove it in a specific call of the<br/>simplifier using `... delsplits [split_if]&#39;.  You can also add/delete<br/>other case splitting rules to/from the default simpset: every datatype<br/>generates suitable rules `split_t_case&#39; and `split_t_case_asm&#39; (where<br/>t is the name of the datatype).<br/><br/>* Classical reasoner / Simplifier combination: new force_tac (and<br/>derivatives Force_tac, force) combines rewriting and classical<br/>reasoning (and whatever other tools) similarly to auto_tac, but is<br/>aimed to solve the given subgoal completely.<br/><br/><br/>*** General ***<br/><br/>* new top-level commands `Goal&#39; and `Goalw&#39; that improve upon `goal&#39;<br/>and `goalw&#39;: the theory is no longer needed as an explicit argument -<br/>the current theory context is used; assumptions are no longer returned<br/>at the ML-level unless one of them starts with ==&gt; or !!; it is<br/>recommended to convert to these new commands using isatool fixgoal<br/>(backup your sources first!);<br/><br/>* new top-level commands &#39;thm&#39; and &#39;thms&#39; for retrieving theorems from<br/>the current theory context, and &#39;theory&#39; to lookup stored theories;<br/><br/>* new theory section &#39;locale&#39; for declaring constants, assumptions and<br/>definitions that have local scope;<br/><br/>* new theory section &#39;nonterminals&#39; for purely syntactic types;<br/><br/>* new theory section &#39;setup&#39; for generic ML setup functions<br/>(e.g. package initialization);<br/><br/>* the distribution now includes Isabelle icons: see<br/>lib/logo/isabelle-{small,tiny}.xpm;<br/><br/>* isatool install - install binaries with absolute references to<br/>ISABELLE_HOME/bin;<br/><br/>* isatool logo -- create instances of the Isabelle logo (as EPS);<br/><br/>* print mode &#39;emacs&#39; reserved for Isamode;<br/><br/>* support multiple print (ast) translations per constant name;<br/><br/>* theorems involving oracles are now printed with a suffixed [!];<br/><br/><br/>*** HOL ***<br/><br/>* there is now a tutorial on Isabelle/HOL (do &#39;isatool doc tutorial&#39;);<br/><br/>* HOL/inductive package reorganized and improved: now supports mutual<br/>definitions such as<br/><br/>  inductive EVEN ODD<br/>    intrs<br/>      null &quot;0 : EVEN&quot;<br/>      oddI &quot;n : EVEN ==&gt; Suc n : ODD&quot;<br/>      evenI &quot;n : ODD ==&gt; Suc n : EVEN&quot;<br/><br/>new theorem list &quot;elims&quot; contains an elimination rule for each of the<br/>recursive sets; inductive definitions now handle disjunctive premises<br/>correctly (also ZF);<br/><br/>INCOMPATIBILITIES: requires Inductive as an ancestor; component<br/>&quot;mutual_induct&quot; no longer exists - the induction rule is always<br/>contained in &quot;induct&quot;;<br/><br/><br/>* HOL/datatype package re-implemented and greatly improved: now<br/>supports mutually recursive datatypes such as<br/><br/>  datatype<br/>    &#39;a aexp = IF_THEN_ELSE (&#39;a bexp) (&#39;a aexp) (&#39;a aexp)<br/>            | SUM (&#39;a aexp) (&#39;a aexp)<br/>            | DIFF (&#39;a aexp) (&#39;a aexp)<br/>            | NUM &#39;a<br/>  and<br/>    &#39;a bexp = LESS (&#39;a aexp) (&#39;a aexp)<br/>            | AND (&#39;a bexp) (&#39;a bexp)<br/>            | OR (&#39;a bexp) (&#39;a bexp)<br/><br/>as well as indirectly recursive datatypes such as<br/><br/>  datatype<br/>    (&#39;a, &#39;b) term = Var &#39;a<br/>                  | App &#39;b (((&#39;a, &#39;b) term) list)<br/><br/>The new tactic  mutual_induct_tac [&lt;var_1&gt;, ..., &lt;var_n&gt;] i  performs<br/>induction on mutually / indirectly recursive datatypes.<br/><br/>Primrec equations are now stored in theory and can be accessed via<br/>&lt;function_name&gt;.simps.<br/><br/>INCOMPATIBILITIES:<br/><br/>  - Theories using datatypes must now have theory Datatype as an<br/>    ancestor.<br/>  - The specific &lt;typename&gt;.induct_tac no longer exists - use the<br/>    generic induct_tac instead.<br/>  - natE has been renamed to nat.exhaust - use exhaust_tac<br/>    instead of res_inst_tac ... natE. Note that the variable<br/>    names in nat.exhaust differ from the names in natE, this<br/>    may cause some &quot;fragile&quot; proofs to fail.<br/>  - The theorems split_&lt;typename&gt;_case and split_&lt;typename&gt;_case_asm<br/>    have been renamed to &lt;typename&gt;.split and &lt;typename&gt;.split_asm.<br/>  - Since default sorts of type variables are now handled correctly,<br/>    some datatype definitions may have to be annotated with explicit<br/>    sort constraints.<br/>  - Primrec definitions no longer require function name and type<br/>    of recursive argument.<br/><br/>Consider using isatool fixdatatype to adapt your theories and proof<br/>scripts to the new package (backup your sources first!).<br/><br/><br/>* HOL/record package: considerably improved implementation; now<br/>includes concrete syntax for record types, terms, updates; theorems<br/>for surjective pairing and splitting !!-bound record variables; proof<br/>support is as follows:<br/><br/>  1) standard conversions (selectors or updates applied to record<br/>constructor terms) are part of the standard simpset;<br/><br/>  2) inject equations of the form ((x, y) = (x&#39;, y&#39;)) == x=x&#39; &amp; y=y&#39; are<br/>made part of standard simpset and claset via addIffs;<br/><br/>  3) a tactic for record field splitting (record_split_tac) is part of<br/>the standard claset (addSWrapper);<br/><br/>To get a better idea about these rules you may retrieve them via<br/>something like &#39;thms &quot;foo.simps&quot;&#39; or &#39;thms &quot;foo.iffs&quot;&#39;, where &quot;foo&quot; is<br/>the name of your record type.<br/><br/>The split tactic 3) conceptually simplifies by the following rule:<br/><br/>  &quot;(!!x. PROP ?P x) == (!!a b. PROP ?P (a, b))&quot;<br/><br/>Thus any record variable that is bound by meta-all will automatically<br/>blow up into some record constructor term, consequently the<br/>simplifications of 1), 2) apply.  Thus force_tac, auto_tac etc. shall<br/>solve record problems automatically.<br/><br/><br/>* reorganized the main HOL image: HOL/Integ and String loaded by<br/>default; theory Main includes everything;<br/><br/>* automatic simplification of integer sums and comparisons, using cancellation;<br/><br/>* added option_map_eq_Some and not_Some_eq to the default simpset and claset;<br/><br/>* added disj_not1 = &quot;(~P | Q) = (P --&gt; Q)&quot; to the default simpset;<br/><br/>* many new identities for unions, intersections, set difference, etc.;<br/><br/>* expand_if, expand_split, expand_sum_case and expand_nat_case are now<br/>called split_if, split_split, split_sum_case and split_nat_case (to go<br/>with add/delsplits);<br/><br/>* HOL/Prod introduces simplification procedure unit_eq_proc rewriting<br/>(?x::unit) = (); this is made part of the default simpset, which COULD<br/>MAKE EXISTING PROOFS FAIL under rare circumstances (consider<br/>&#39;Delsimprocs [unit_eq_proc];&#39; as last resort); also note that<br/>unit_abs_eta_conv is added in order to counter the effect of<br/>unit_eq_proc on (%u::unit. f u), replacing it by f rather than by<br/>%u.f();<br/><br/>* HOL/Fun INCOMPATIBILITY: `inj_onto&#39; is now called `inj_on&#39; (which<br/>makes more sense);<br/><br/>* HOL/Set INCOMPATIBILITY: rule `equals0D&#39; is now a well-formed destruct rule;<br/>  It and &#39;sym RS equals0D&#39; are now in the default  claset, giving automatic<br/>  disjointness reasoning but breaking a few old proofs.<br/><br/>* HOL/Relation INCOMPATIBILITY: renamed the relational operator r^-1<br/>to &#39;converse&#39; from &#39;inverse&#39; (for compatibility with ZF and some<br/>literature);<br/><br/>* HOL/recdef can now declare non-recursive functions, with {} supplied as<br/>the well-founded relation;<br/><br/>* HOL/Set INCOMPATIBILITY: the complement of set A is now written -A instead of<br/>    Compl A.  The &quot;Compl&quot; syntax remains available as input syntax for this<br/>    release ONLY.<br/><br/>* HOL/Update: new theory of function updates:<br/>    f(a:=b) == %x. if x=a then b else f x<br/>may also be iterated as in f(a:=b,c:=d,...);<br/><br/>* HOL/Vimage: new theory for inverse image of a function, syntax f-``B;<br/><br/>* HOL/List:<br/>  - new function list_update written xs[i:=v] that updates the i-th<br/>    list position. May also be iterated as in xs[i:=a,j:=b,...].<br/>  - new function `upt&#39; written [i..j(] which generates the list<br/>    [i,i+1,...,j-1], i.e. the upper bound is excluded. To include the upper<br/>    bound write [i..j], which is a shorthand for [i..j+1(].<br/>  - new lexicographic orderings and corresponding wellfoundedness theorems.<br/><br/>* HOL/Arith:<br/>  - removed &#39;pred&#39; (predecessor) function;<br/>  - generalized some theorems about n-1;<br/>  - many new laws about &quot;div&quot; and &quot;mod&quot;;<br/>  - new laws about greatest common divisors (see theory ex/Primes);<br/><br/>* HOL/Relation: renamed the relational operator r^-1 &quot;converse&quot;<br/>instead of &quot;inverse&quot;;<br/><br/>* HOL/Induct/Multiset: a theory of multisets, including the wellfoundedness<br/>  of the multiset ordering;<br/><br/>* directory HOL/Real: a construction of the reals using Dedekind cuts<br/>  (not included by default);<br/><br/>* directory HOL/UNITY: Chandy and Misra&#39;s UNITY formalism;<br/><br/>* directory HOL/Hoare: a new version of Hoare logic which permits many-sorted<br/>  programs, i.e. different program variables may have different types.<br/><br/>* calling (stac rew i) now fails if &quot;rew&quot; has no effect on the goal<br/>  [previously, this check worked only if the rewrite rule was unconditional]<br/>  Now rew can involve either definitions or equalities (either == or =).<br/><br/><br/>*** ZF ***<br/><br/>* theory Main includes everything; INCOMPATIBILITY: theory ZF.thy contains<br/>  only the theorems proved on ZF.ML;<br/><br/>* ZF INCOMPATIBILITY: rule `equals0D&#39; is now a well-formed destruct rule;<br/>  It and &#39;sym RS equals0D&#39; are now in the default  claset, giving automatic<br/>  disjointness reasoning but breaking a few old proofs.<br/><br/>* ZF/Update: new theory of function updates<br/>    with default rewrite rule  f(x:=y) ` z = if(z=x, y, f`z)<br/>  may also be iterated as in f(a:=b,c:=d,...);<br/><br/>* in  let x=t in u(x), neither t nor u(x) has to be an FOL term.<br/><br/>* calling (stac rew i) now fails if &quot;rew&quot; has no effect on the goal<br/>  [previously, this check worked only if the rewrite rule was unconditional]<br/>  Now rew can involve either definitions or equalities (either == or =).<br/><br/>* case_tac provided for compatibility with HOL<br/>    (like the old excluded_middle_tac, but with subgoals swapped)<br/><br/><br/>*** Internal programming interfaces ***<br/><br/>* Pure: several new basic modules made available for general use, see<br/>also src/Pure/README;<br/><br/>* improved the theory data mechanism to support encapsulation (data<br/>kind name replaced by private Object.kind, acting as authorization<br/>key); new type-safe user interface via functor TheoryDataFun; generic<br/>print_data function becomes basically useless;<br/><br/>* removed global_names compatibility flag -- all theory declarations<br/>are qualified by default;<br/><br/>* module Pure/Syntax now offers quote / antiquote translation<br/>functions (useful for Hoare logic etc. with implicit dependencies);<br/>see HOL/ex/Antiquote for an example use;<br/><br/>* Simplifier now offers conversions (asm_)(full_)rewrite: simpset -&gt;<br/>cterm -&gt; thm;<br/><br/>* new tactical CHANGED_GOAL for checking that a tactic modifies a<br/>subgoal;<br/><br/>* Display.print_goals function moved to Locale.print_goals;<br/><br/>* standard print function for goals supports current_goals_markers<br/>variable for marking begin of proof, end of proof, start of goal; the<br/>default is (&quot;&quot;, &quot;&quot;, &quot;&quot;); setting current_goals_markers := (&quot;&lt;proof&gt;&quot;,<br/>&quot;&lt;/proof&gt;&quot;, &quot;&lt;goal&gt;&quot;) causes SGML like tagged proof state printing,<br/>for example;<br/><br/><br/><br/>New in Isabelle98 (January 1998)<br/>--------------------------------<br/><br/>*** Overview of INCOMPATIBILITIES (see below for more details) ***<br/><br/>* changed lexical syntax of terms / types: dots made part of long<br/>identifiers, e.g. &quot;%x.x&quot; no longer possible, should be &quot;%x. x&quot;;<br/><br/>* simpset (and claset) reference variable replaced by functions<br/>simpset / simpset_ref;<br/><br/>* no longer supports theory aliases (via merge) and non-trivial<br/>implicit merge of thms&#39; signatures;<br/><br/>* most internal names of constants changed due to qualified names;<br/><br/>* changed Pure/Sequence interface (see Pure/seq.ML);<br/><br/><br/>*** General Changes ***<br/><br/>* hierachically structured name spaces (for consts, types, axms, thms<br/>etc.); new lexical class &#39;longid&#39; (e.g. Foo.bar.x) may render much of<br/>old input syntactically incorrect (e.g. &quot;%x.x&quot;); COMPATIBILITY:<br/>isatool fixdots ensures space after dots (e.g. &quot;%x. x&quot;); set<br/>long_names for fully qualified output names; NOTE: ML programs<br/>(special tactics, packages etc.) referring to internal names may have<br/>to be adapted to cope with fully qualified names; in case of severe<br/>backward campatibility problems try setting &#39;global_names&#39; at compile<br/>time to have enrything declared within a flat name space; one may also<br/>fine tune name declarations in theories via the &#39;global&#39; and &#39;local&#39;<br/>section;<br/><br/>* reimplemented the implicit simpset and claset using the new anytype<br/>data filed in signatures; references simpset:simpset ref etc. are<br/>replaced by functions simpset:unit-&gt;simpset and<br/>simpset_ref:unit-&gt;simpset ref; COMPATIBILITY: use isatool fixclasimp<br/>to patch your ML files accordingly;<br/><br/>* HTML output now includes theory graph data for display with Java<br/>applet or isatool browser; data generated automatically via isatool<br/>usedir (see -i option, ISABELLE_USEDIR_OPTIONS);<br/><br/>* defs may now be conditional; improved rewrite_goals_tac to handle<br/>conditional equations;<br/><br/>* defs now admits additional type arguments, using TYPE(&#39;a) syntax;<br/><br/>* theory aliases via merge (e.g. M=A+B+C) no longer supported, always<br/>creates a new theory node; implicit merge of thms&#39; signatures is<br/>restricted to &#39;trivial&#39; ones; COMPATIBILITY: one may have to use<br/>transfer:theory-&gt;thm-&gt;thm in (rare) cases;<br/><br/>* improved handling of draft signatures / theories; draft thms (and<br/>ctyps, cterms) are automatically promoted to real ones;<br/><br/>* slightly changed interfaces for oracles: admit many per theory, named<br/>(e.g. oracle foo = mlfun), additional name argument for invoke_oracle;<br/><br/>* print_goals: optional output of const types (set show_consts and<br/>show_types);<br/><br/>* improved output of warnings (###) and errors (***);<br/><br/>* subgoal_tac displays a warning if the new subgoal has type variables;<br/><br/>* removed old README and Makefiles;<br/><br/>* replaced print_goals_ref hook by print_current_goals_fn and result_error_fn;<br/><br/>* removed obsolete init_pps and init_database;<br/><br/>* deleted the obsolete tactical STATE, which was declared by<br/>    fun STATE tacfun st = tacfun st st;<br/><br/>* cd and use now support path variables, e.g. $ISABELLE_HOME, or ~<br/>(which abbreviates $HOME);<br/><br/>* changed Pure/Sequence interface (see Pure/seq.ML); COMPATIBILITY:<br/>use isatool fixseq to adapt your ML programs (this works for fully<br/>qualified references to the Sequence structure only!);<br/><br/>* use_thy no longer requires writable current directory; it always<br/>reloads .ML *and* .thy file, if either one is out of date;<br/><br/><br/>*** Classical Reasoner ***<br/><br/>* Clarify_tac, clarify_tac, clarify_step_tac, Clarify_step_tac: new<br/>tactics that use classical reasoning to simplify a subgoal without<br/>splitting it into several subgoals;<br/><br/>* Safe_tac: like safe_tac but uses the default claset;<br/><br/><br/>*** Simplifier ***<br/><br/>* added simplification meta rules:<br/>    (asm_)(full_)simplify: simpset -&gt; thm -&gt; thm;<br/><br/>* simplifier.ML no longer part of Pure -- has to be loaded by object<br/>logics (again);<br/><br/>* added prems argument to simplification procedures;<br/><br/>* HOL, FOL, ZF: added infix function `addsplits&#39;:<br/>  instead of `&lt;simpset&gt; setloop (split_tac &lt;thms&gt;)&#39;<br/>  you can simply write `&lt;simpset&gt; addsplits &lt;thms&gt;&#39;<br/><br/><br/>*** Syntax ***<br/><br/>* TYPE(&#39;a) syntax for type reflection terms;<br/><br/>* no longer handles consts with name &quot;&quot; -- declare as &#39;syntax&#39; instead;<br/><br/>* pretty printer: changed order of mixfix annotation preference (again!);<br/><br/>* Pure: fixed idt/idts vs. pttrn/pttrns syntactic categories;<br/><br/><br/>*** HOL ***<br/><br/>* HOL: there is a new splitter `split_asm_tac&#39; that can be used e.g.<br/>  with `addloop&#39; of the simplifier to faciliate case splitting in premises.<br/><br/>* HOL/TLA: Stephan Merz&#39;s formalization of Lamport&#39;s Temporal Logic of Actions;<br/><br/>* HOL/Auth: new protocol proofs including some for the Internet<br/>  protocol TLS;<br/><br/>* HOL/Map: new theory of `maps&#39; a la VDM;<br/><br/>* HOL/simplifier: simplification procedures nat_cancel_sums for<br/>cancelling out common nat summands from =, &lt;, &lt;= (in)equalities, or<br/>differences; simplification procedures nat_cancel_factor for<br/>cancelling common factor from =, &lt;, &lt;= (in)equalities over natural<br/>sums; nat_cancel contains both kinds of procedures, it is installed by<br/>default in Arith.thy -- this COULD MAKE EXISTING PROOFS FAIL;<br/><br/>* HOL/simplifier: terms of the form<br/>  `? x. P1(x) &amp; ... &amp; Pn(x) &amp; x=t &amp; Q1(x) &amp; ... Qn(x)&#39;  (or t=x)<br/>  are rewritten to<br/>  `P1(t) &amp; ... &amp; Pn(t) &amp; Q1(t) &amp; ... Qn(t)&#39;,<br/>  and those of the form<br/>  `! x. P1(x) &amp; ... &amp; Pn(x) &amp; x=t &amp; Q1(x) &amp; ... Qn(x) --&gt; R(x)&#39;  (or t=x)<br/>  are rewritten to<br/>  `P1(t) &amp; ... &amp; Pn(t) &amp; Q1(t) &amp; ... Qn(t) --&gt; R(t)&#39;,<br/><br/>* HOL/datatype<br/>  Each datatype `t&#39; now comes with a theorem `split_t_case&#39; of the form<br/><br/>  P(t_case f1 ... fn x) =<br/>     ( (!y1 ... ym1. x = C1 y1 ... ym1 --&gt; P(f1 y1 ... ym1)) &amp;<br/>        ...<br/>       (!y1 ... ymn. x = Cn y1 ... ymn --&gt; P(f1 y1 ... ymn))<br/>     )<br/><br/>  and a theorem `split_t_case_asm&#39; of the form<br/><br/>  P(t_case f1 ... fn x) =<br/>    ~( (? y1 ... ym1. x = C1 y1 ... ym1 &amp; ~P(f1 y1 ... ym1)) |<br/>        ...<br/>       (? y1 ... ymn. x = Cn y1 ... ymn &amp; ~P(f1 y1 ... ymn))<br/>     )<br/>  which can be added to a simpset via `addsplits&#39;. The existing theorems<br/>  expand_list_case and expand_option_case have been renamed to<br/>  split_list_case and split_option_case.<br/><br/>* HOL/Arithmetic:<br/>  - `pred n&#39; is automatically converted to `n-1&#39;.<br/>    Users are strongly encouraged not to use `pred&#39; any longer,<br/>    because it will disappear altogether at some point.<br/>  - Users are strongly encouraged to write &quot;0 &lt; n&quot; rather than<br/>    &quot;n ~= 0&quot;. Theorems and proof tools have been modified towards this<br/>    `standard&#39;.<br/><br/>* HOL/Lists:<br/>  the function &quot;set_of_list&quot; has been renamed &quot;set&quot; (and its theorems too);<br/>  the function &quot;nth&quot; now takes its arguments in the reverse order and<br/>  has acquired the infix notation &quot;!&quot; as in &quot;xs!n&quot;.<br/><br/>* HOL/Set: UNIV is now a constant and is no longer translated to Compl{};<br/><br/>* HOL/Set: The operator (UN x.B x) now abbreviates (UN x:UNIV. B x) and its<br/>  specialist theorems (like UN1_I) are gone.  Similarly for (INT x.B x);<br/><br/>* HOL/record: extensible records with schematic structural subtyping<br/>(single inheritance); EXPERIMENTAL version demonstrating the encoding,<br/>still lacks various theorems and concrete record syntax;<br/><br/><br/>*** HOLCF ***<br/><br/>* removed &quot;axioms&quot; and &quot;generated by&quot; sections;<br/><br/>* replaced &quot;ops&quot; section by extended &quot;consts&quot; section, which is capable of<br/>  handling the continuous function space &quot;-&gt;&quot; directly;<br/><br/>* domain package:<br/>  . proves theorems immediately and stores them in the theory,<br/>  . creates hierachical name space,<br/>  . now uses normal mixfix annotations (instead of cinfix...),<br/>  . minor changes to some names and values (for consistency),<br/>  . e.g. cases -&gt; casedist, dists_eq -&gt; dist_eqs, [take_lemma] -&gt; take_lemmas,<br/>  . separator between mutual domain defs: changed &quot;,&quot; to &quot;and&quot;,<br/>  . improved handling of sort constraints;  now they have to<br/>    appear on the left-hand side of the equations only;<br/><br/>* fixed LAM &lt;x,y,zs&gt;.b syntax;<br/><br/>* added extended adm_tac to simplifier in HOLCF -- can now discharge<br/>adm (%x. P (t x)), where P is chainfinite and t continuous;<br/><br/><br/>*** FOL and ZF ***<br/><br/>* FOL: there is a new splitter `split_asm_tac&#39; that can be used e.g.<br/>  with `addloop&#39; of the simplifier to faciliate case splitting in premises.<br/><br/>* qed_spec_mp, qed_goal_spec_mp, qed_goalw_spec_mp are available, as<br/>in HOL, they strip ALL and --&gt; from proved theorems;<br/><br/><br/><br/>New in Isabelle94-8 (May 1997)<br/>------------------------------<br/><br/>*** General Changes ***<br/><br/>* new utilities to build / run / maintain Isabelle etc. (in parts<br/>still somewhat experimental); old Makefiles etc. still functional;<br/><br/>* new &#39;Isabelle System Manual&#39;;<br/><br/>* INSTALL text, together with ./configure and ./build scripts;<br/><br/>* reimplemented type inference for greater efficiency, better error<br/>messages and clean internal interface;<br/><br/>* prlim command for dealing with lots of subgoals (an easier way of<br/>setting goals_limit);<br/><br/><br/>*** Syntax ***<br/><br/>* supports alternative (named) syntax tables (parser and pretty<br/>printer); internal interface is provided by add_modesyntax(_i);<br/><br/>* Pure, FOL, ZF, HOL, HOLCF now support symbolic input and output; to<br/>be used in conjunction with the Isabelle symbol font; uses the<br/>&quot;symbols&quot; syntax table;<br/><br/>* added token_translation interface (may translate name tokens in<br/>arbitrary ways, dependent on their type (free, bound, tfree, ...) and<br/>the current print_mode); IMPORTANT: user print translation functions<br/>are responsible for marking newly introduced bounds<br/>(Syntax.mark_boundT);<br/><br/>* token translations for modes &quot;xterm&quot; and &quot;xterm_color&quot; that display<br/>names in bold, underline etc. or colors (which requires a color<br/>version of xterm);<br/><br/>* infixes may now be declared with names independent of their syntax;<br/><br/>* added typed_print_translation (like print_translation, but may<br/>access type of constant);<br/><br/><br/>*** Classical Reasoner ***<br/><br/>Blast_tac: a new tactic!  It is often more powerful than fast_tac, but has<br/>some limitations.  Blast_tac...<br/>  + ignores addss, addbefore, addafter; this restriction is intrinsic<br/>  + ignores elimination rules that don&#39;t have the correct format<br/>        (the conclusion MUST be a formula variable)<br/>  + ignores types, which can make HOL proofs fail<br/>  + rules must not require higher-order unification, e.g. apply_type in ZF<br/>    [message &quot;Function Var&#39;s argument not a bound variable&quot; relates to this]<br/>  + its proof strategy is more general but can actually be slower<br/><br/>* substitution with equality assumptions no longer permutes other<br/>assumptions;<br/><br/>* minor changes in semantics of addafter (now called addaltern); renamed<br/>setwrapper to setWrapper and compwrapper to compWrapper; added safe wrapper<br/>(and access functions for it);<br/><br/>* improved combination of classical reasoner and simplifier:<br/>  + functions for handling clasimpsets<br/>  + improvement of addss: now the simplifier is called _after_ the<br/>    safe steps.<br/>  + safe variant of addss called addSss: uses safe simplifications<br/>    _during_ the safe steps. It is more complete as it allows multiple<br/>    instantiations of unknowns (e.g. with slow_tac).<br/><br/>*** Simplifier ***<br/><br/>* added interface for simplification procedures (functions that<br/>produce *proven* rewrite rules on the fly, depending on current<br/>redex);<br/><br/>* ordering on terms as parameter (used for ordered rewriting);<br/><br/>* new functions delcongs, deleqcongs, and Delcongs. richer rep_ss;<br/><br/>* the solver is now split into a safe and an unsafe part.<br/>This should be invisible for the normal user, except that the<br/>functions setsolver and addsolver have been renamed to setSolver and<br/>addSolver; added safe_asm_full_simp_tac;<br/><br/><br/>*** HOL ***<br/><br/>* a generic induction tactic `induct_tac&#39; which works for all datatypes and<br/>also for type `nat&#39;;<br/><br/>* a generic case distinction tactic `exhaust_tac&#39; which works for all<br/>datatypes and also for type `nat&#39;;<br/><br/>* each datatype comes with a function `size&#39;;<br/><br/>* patterns in case expressions allow tuple patterns as arguments to<br/>constructors, for example `case x of [] =&gt; ... | (x,y,z)#ps =&gt; ...&#39;;<br/><br/>* primrec now also works with type nat;<br/><br/>* recdef: a new declaration form, allows general recursive functions to be<br/>defined in theory files.  See HOL/ex/Fib, HOL/ex/Primes, HOL/Subst/Unify.<br/><br/>* the constant for negation has been renamed from &quot;not&quot; to &quot;Not&quot; to<br/>harmonize with FOL, ZF, LK, etc.;<br/><br/>* HOL/ex/LFilter theory of a corecursive &quot;filter&quot; functional for<br/>infinite lists;<br/><br/>* HOL/Modelcheck demonstrates invocation of model checker oracle;<br/><br/>* HOL/ex/Ring.thy declares cring_simp, which solves equational<br/>problems in commutative rings, using axiomatic type classes for + and *;<br/><br/>* more examples in HOL/MiniML and HOL/Auth;<br/><br/>* more default rewrite rules for quantifiers, union/intersection;<br/><br/>* a new constant `arbitrary == @x.False&#39;;<br/><br/>* HOLCF/IOA replaces old HOL/IOA;<br/><br/>* HOLCF changes: derived all rules and arities<br/>  + axiomatic type classes instead of classes<br/>  + typedef instead of faking type definitions<br/>  + eliminated the internal constants less_fun, less_cfun, UU_fun, UU_cfun etc.<br/>  + new axclasses cpo, chfin, flat with flat &lt; chfin &lt; pcpo &lt; cpo &lt; po<br/>  + eliminated the types void, one, tr<br/>  + use unit lift and bool lift (with translations) instead of one and tr<br/>  + eliminated blift from Lift3.thy (use Def instead of blift)<br/>  all eliminated rules are derived as theorems --&gt; no visible changes ;<br/><br/><br/>*** ZF ***<br/><br/>* ZF now has Fast_tac, Simp_tac and Auto_tac.  Union_iff is a now a default<br/>rewrite rule; this may affect some proofs.  eq_cs is gone but can be put back<br/>as ZF_cs addSIs [equalityI];<br/><br/><br/><br/>New in Isabelle94-7 (November 96)<br/>---------------------------------<br/><br/>* allowing negative levels (as offsets) in prlev and choplev;<br/><br/>* super-linear speedup for large simplifications;<br/><br/>* FOL, ZF and HOL now use miniscoping: rewriting pushes<br/>quantifications in as far as possible (COULD MAKE EXISTING PROOFS<br/>FAIL); can suppress it using the command Delsimps (ex_simps @<br/>all_simps); De Morgan laws are also now included, by default;<br/><br/>* improved printing of ==&gt;  :  ~:<br/><br/>* new object-logic &quot;Sequents&quot; adds linear logic, while replacing LK<br/>and Modal (thanks to Sara Kalvala);<br/><br/>* HOL/Auth: correctness proofs for authentication protocols;<br/><br/>* HOL: new auto_tac combines rewriting and classical reasoning (many<br/>examples on HOL/Auth);<br/><br/>* HOL: new command AddIffs for declaring theorems of the form P=Q to<br/>the rewriter and classical reasoner simultaneously;<br/><br/>* function uresult no longer returns theorems in &quot;standard&quot; format;<br/>regain previous version by: val uresult = standard o uresult;<br/><br/><br/><br/>New in Isabelle94-6<br/>-------------------<br/><br/>* oracles -- these establish an interface between Isabelle and trusted<br/>external reasoners, which may deliver results as theorems;<br/><br/>* proof objects (in particular record all uses of oracles);<br/><br/>* Simp_tac, Fast_tac, etc. that refer to implicit simpset / claset;<br/><br/>* &quot;constdefs&quot; section in theory files;<br/><br/>* &quot;primrec&quot; section (HOL) no longer requires names;<br/><br/>* internal type &quot;tactic&quot; now simply &quot;thm -&gt; thm Sequence.seq&quot;;<br/><br/><br/><br/>New in Isabelle94-5<br/>-------------------<br/><br/>* reduced space requirements;<br/><br/>* automatic HTML generation from theories;<br/><br/>* theory files no longer require &quot;...&quot; (quotes) around most types;<br/><br/>* new examples, including two proofs of the Church-Rosser theorem;<br/><br/>* non-curried (1994) version of HOL is no longer distributed;<br/><br/><br/><br/>New in Isabelle94-4<br/>-------------------<br/><br/>* greatly reduced space requirements;<br/><br/>* theory files (.thy) no longer require \...\ escapes at line breaks;<br/><br/>* searchable theorem database (see the section &quot;Retrieving theorems&quot; on<br/>page 8 of the Reference Manual);<br/><br/>* new examples, including Grabczewski&#39;s monumental case study of the<br/>Axiom of Choice;<br/><br/>* The previous version of HOL renamed to Old_HOL;<br/><br/>* The new version of HOL (previously called CHOL) uses a curried syntax<br/>for functions.  Application looks like f a b instead of f(a,b);<br/><br/>* Mutually recursive inductive definitions finally work in HOL;<br/><br/>* In ZF, pattern-matching on tuples is now available in all abstractions and<br/>translates to the operator &quot;split&quot;;<br/><br/><br/><br/>New in Isabelle94-3<br/>-------------------<br/><br/>* new infix operator, addss, allowing the classical reasoner to<br/>perform simplification at each step of its search.  Example:<br/>        fast_tac (cs addss ss)<br/><br/>* a new logic, CHOL, the same as HOL, but with a curried syntax<br/>for functions.  Application looks like f a b instead of f(a,b).  Also pairs<br/>look like (a,b) instead of &lt;a,b&gt;;<br/><br/>* PLEASE NOTE: CHOL will eventually replace HOL!<br/><br/>* In CHOL, pattern-matching on tuples is now available in all abstractions.<br/>It translates to the operator &quot;split&quot;.  A new theory of integers is available;<br/><br/>* In ZF, integer numerals now denote two&#39;s-complement binary integers.<br/>Arithmetic operations can be performed by rewriting.  See ZF/ex/Bin.ML;<br/><br/>* Many new examples: I/O automata, Church-Rosser theorem, equivalents<br/>of the Axiom of Choice;<br/><br/><br/><br/>New in Isabelle94-2<br/>-------------------<br/><br/>* Significantly faster resolution;<br/><br/>* the different sections in a .thy file can now be mixed and repeated<br/>freely;<br/><br/>* Database of theorems for FOL, HOL and ZF.  New<br/>commands including qed, qed_goal and bind_thm store theorems in the database.<br/><br/>* Simple database queries: return a named theorem (get_thm) or all theorems of<br/>a given theory (thms_of), or find out what theory a theorem was proved in<br/>(theory_of_thm);<br/><br/>* Bugs fixed in the inductive definition and datatype packages;<br/><br/>* The classical reasoner provides deepen_tac and depth_tac, making FOL_dup_cs<br/>and HOL_dup_cs obsolete;<br/><br/>* Syntactic ambiguities caused by the new treatment of syntax in Isabelle94-1<br/>have been removed;<br/><br/>* Simpler definition of function space in ZF;<br/><br/>* new results about cardinal and ordinal arithmetic in ZF;<br/><br/>* &#39;subtype&#39; facility in HOL for introducing new types as subsets of existing<br/>types;<br/><br/>:mode=isabelle-news:wrap=hard:maxLineLen=72:<br/></pre>

</div>
</body>
</html>
